<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/16/Getting-Started-With-RxSwift-and-RxCocoa/" itemprop="url">
                  Getting Started With RxSwift and RxCocoa
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-16T08:13:39+08:00" content="2017-01-16">
              2017-01-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由Ellen Shapiro发表于raywenderlich，原文地址是<a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="external">https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa</a></p>
</blockquote>
<hr>
<p>代码能按你的意愿执行总是件很棒的事。在程序中改变一些东西，告诉代码，然后它就照做了。嗯，这是坨好代码！</p>
<p>在面向对象时代，大多数程序都像这样运行：你的代码告诉你的程序需要做什么，并且有很多方法来监听变化–但同时你又必须主动告诉系统什么时候发生的变化。</p>
<p>目前为止还是很不错，不过如果变化发生时，代码能自动响应更新，生活是不是会更美好呢？这就是响应式编程的基本思想：你的程序可以对底层数据的变化做出响应，而不需要你直接告诉它。这样，你可以更专注于所需要处理的业务逻辑，而不需要去维护特定的状态。</p>
<p>在Objective-C和Swift都可以实现这种操作，主要是通过<code>Key-value Observation</code>，在Swift中还可以使用<code>setter</code>或<code>didSet</code>方法。不过，有时这些方法并不那么好使。为了避免这些问题，现在市面上已经有一些Objective-C和Swift的框架，来实现响应式编程。</p>
<blockquote>
<p>如果你想了解更多的信息，可以看看 ‘<a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="external">ReactiveCocoa vs RxSwift</a>‘ 这篇文章。</p>
</blockquote>
<p>今天我们将使用一个很棒的框架，RxSwift和它的小伙伴RxCocoa，来实现一个购买巧克力的App，并从那令人恼火的命令式编程过渡到相当awesome的响应式编程。</p>
<h2 id="RxSwift和RxCocoa是什么？"><a href="#RxSwift和RxCocoa是什么？" class="headerlink" title="RxSwift和RxCocoa是什么？"></a>RxSwift和RxCocoa是什么？</h2><p>RxSwift和RxCocoa是ReactiveX工具套件的一部分，这个套件包含了多种编程语言和平台。ReactiveX起源于.Net/C#生态体系，不过现在已经非常受Rubyists、JavaScripers、尤其是Java和Android开发人员的欢迎了。</p>
<p>RxSwift是一个用于与Swift语言交互的框架，而RxCocoa是在响应式编程中让Cocoa APIs更容易使用的一个框架。</p>
<p>ReactiveX框架相当于提供了一个词汇表，以方便在不同的语言中描述相同的任务。这让你可以在多语言切换中，专注于语言本身的语法，而不是把时间浪费在将一个普通任务从一种语言转换为另一种新语言。</p>
<h3 id="Observables和Observers"><a href="#Observables和Observers" class="headerlink" title="Observables和Observers"></a>Observables和Observers</h3><p>这里有两个基本的概念：<code>Observable</code>和<code>Observer</code>。</p>
<ul>
<li><code>Observable</code>是发出变化通知的对象；</li>
<li><code>Observer</code>是订阅<code>Observable</code>的对象，以便在<code>Observable</code>变化时接收通知</li>
</ul>
<p>可以有多个<code>Observer</code>监听同一个<code>Observable</code>。这意味着当<code>Observable</code>发生变化时，会通知所有相关的<code>Observer</code>。</p>
<h3 id="DisposeBag"><a href="#DisposeBag" class="headerlink" title="DisposeBag"></a>DisposeBag</h3><p>RxSwift和RxCocoa还有一个额外的工具来辅助处理ARC和内存管理：即<code>DisposeBag</code>。这是<code>Observer</code>对象的一个虚拟”包”，当它们的父对象被释放时，这个虚拟包会被丢弃。</p>
<p>当带有<code>DisposeBag</code>属性的对象调用<code>deinit()</code>时，虚拟包将被清空，且每一个一次性(disposable)<code>Observer</code>会自动取消订阅它所观察的内容。这允许ARC像通常一样回收内存。</p>
<p>如果没有<code>DisposeBag</code>，会有两种结果：或者<code>Observer</code>会产生一个<code>retain cycle</code>，被无限期的绑定到被观察对象上；或者意外地被释放，导致程序崩溃。</p>
<p>所以要成为一个ARC的良民，记得设置<code>Observable</code>对象时，将它们添加到<code>DisposeBag</code>中。这样，它们才能被很好地清理掉。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>让我们去买巧克力吧！本教程的初始工程<strong>Chocotastic</strong>可以在<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/Chocotastic-starter-s3-rxs-3b1.zip" target="_blank" rel="external">这里</a>获取。下载zip文件并在Xcode中打开工程。</p>
<blockquote>
<p>该项目使用CocoaPods，因此需要打开Chocotastic.xcworkspace文件。</p>
</blockquote>
<p>构建并运行程序。你会看到以下效果，其中列出了你可以从欧洲购买的几种巧克力，以及各自的价格：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" width="300" align="center"></p>
<p>点击单元格，可以将对应的巧克力添加到你的购物车中：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" width="300" align="center"></p>
<p>点击右上角的购物车就可以进入付款或重置购物车的界面：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/checkout.png" width="300" align="center"></p>
<p>如果点击<code>Checkout</code>，将显示一个信用卡输入页面：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/cc_form.png" width="300" align="center"></p>
<p>在本教程的后面，你将使用纯响应式来解决问题。点击<code>Cart</code>按钮将返回购物车清单，点击<code>Reset</code>按钮将返回主界面，并显示空购物车。</p>
<h3 id="起点：非响应式"><a href="#起点：非响应式" class="headerlink" title="起点：非响应式"></a>起点：非响应式</h3><p>你现在已经知道了程序将做什么，现在该来看看是怎么做的了。打开<code>ChocolatesOfTheWorldViewController.swift</code>文件，在这里你可以看到一些标准的<code>UITableViewDelegate</code>和<code>UITableViewDataSource</code>方法。</p>
<p>还有一个<code>updateCartButton()</code>方法，它用购物车中现有的巧克力数量来更新购物车按钮。这个方法在两个地方被调用：</p>
<ul>
<li>在<code>viewWillAppear(_:)</code>中，即视图控制器即将被显示时；</li>
<li>在<code>tableView(_:didSelectRowAt:)</code>中，即新添加一个巧克力到购物车后。</li>
</ul>
<p>这些都是以命令式方法来修改计数：你必须显示调用方法来更新计数。</p>
<p>目前为止，你必须跟踪你要改变值的位置，不过我们要使用响应式技术来重写这些代码。这样，购物车按钮将自已更新，而不关心计数器在哪和怎样被更新。</p>
<h2 id="RxSwift：让购物车按钮响应"><a href="#RxSwift：让购物车按钮响应" class="headerlink" title="RxSwift：让购物车按钮响应"></a>RxSwift：让购物车按钮响应</h2><p>所有引用购物车中的项目的方法都使用<code>ShoppingCart.sharedCart</code>单例。打开<code>ShoppingCart.swift</code>文件，你将看到单例实例上一个变量的标准设置方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chocolates = [<span class="type">Chocolate</span>]()</div></pre></td></tr></table></figure>
<p>现在，巧克力内容的变更不会被观察到。你可以在它的定义中添加一个<code>didSet</code>闭包，但它只有在整个数组被更新才会被调用，而不是它的元素被更新时。</p>
<p>幸运的是，RxSwift有一个解决方案。使用下面这行代码来替代变量的创建：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> chocolates: <span class="type">Variable</span>&lt;[<span class="type">Chocolate</span>]&gt; = <span class="type">Variable</span>([])</div></pre></td></tr></table></figure>
<blockquote>
<p>这个更改暂时会导致一系列编译错误，不过很快会在下面解决这些问题。</p>
</blockquote>
<p>这种语法可能稍微有点难理解，所以下面我们来慢慢了解到底发生了什么。</p>
<p>在这里我们不是将<code>chocolates</code>设置为<code>Chocolate</code>对象的数组，而将其定义为一个RxSwift的<code>Variable</code>对象，其中泛型类型指定为<code>Chocolate</code>数组。</p>
<p><code>Variable</code>是一个类，所以它使用引用语义–即<code>chocolates</code>引用了一个<code>Variable</code>实例。</p>
<p><code>Variable</code>对象有一个<code>value</code>属性。这是你的<code>Chocolate</code>对象数组的存储位置。</p>
<p><code>Variable</code>的魔力来自于它的<code>asObservable()</code>方法。你可以添加一个<code>Observer</code>来观察这个值，而不是每次手动去确认这个值。当值发生变化时，<code>Observer</code>会通知你，以便你对任何更新做出响应。</p>
<p>这个设置有一个缺点，即当你需要访问或更新<code>Chocolates</code>数组中的元素时，你必须使用<code>value</code>属性，而不能直接使用它；这就是编译器提示错误的原因。是时候来解决它们了。</p>
<p>在<code>ShoppingCart.swift</code>中，找到<code>totalCost()</code>并修改下面这行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> chocolates.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> chocolates.value.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</div></pre></td></tr></table></figure>
<p>在<code>itemCountString()</code>，修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> chocolates.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> chocolates.value.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div></pre></td></tr></table></figure>
<p>并修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> setOfChocolates = <span class="type">Set</span>&lt;<span class="type">Chocolate</span>&gt;(chocolates)</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> setOfChocolates = <span class="type">Set</span>&lt;<span class="type">Chocolate</span>&gt;(chocolates.value)</div></pre></td></tr></table></figure>
<p>最后，修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">count</span>: <span class="type">Int</span> = chocolates.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">count</span>: <span class="type">Int</span> = chocolates.value.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</div></pre></td></tr></table></figure>
<p>在<code>CartViewController.swift</code>中，找到<code>reset()</code>并修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ShoppingCart</span>.sharedCart.chocolates = []</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ShoppingCart</span>.sharedCart.chocolates.value = []</div></pre></td></tr></table></figure>
<p>回到<code>ChocolatesOfTheWorldViewController.swift</code>中，修改<code>updateCartButton()</code>的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cartButton.title = <span class="string">"<span class="subst">\(ShoppingCart.sharedCart.chocolates.value.<span class="built_in">count</span>)</span> \u&#123;1f36b&#125;"</span></div></pre></td></tr></table></figure>
<p>及在<code>tableView(_:didSelectRowAt:)</code>中，修改下面这行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ShoppingCart</span>.sharedCart.chocolates.append(chocolate)</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ShoppingCart</span>.sharedCart.chocolates.value.append(chocolate)</div></pre></td></tr></table></figure>
<p>哇！这回Xcode高兴了，不再报错了。同时<code>chocolates</code>也可以被监听了。</p>
<p>打开<code>ChocolatesOfTheWorldViewController.swift</code>文件并添加以下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure>
<p>这里创建了一个<code>DisposeBag</code>对象，用于确保设置的<code>Observer</code>在<code>deinit()</code>中被清理掉。</p>
<p>在 <strong>//MARK: Rx Setup</strong> 注释下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MARK: Rx Setup</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCartObserver</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="type">ShoppingCart</span>.sharedCart.chocolates.asObservable()</div><div class="line">    .subscribe(onNext: &#123; <span class="comment">//2</span></div><div class="line">      chocolates <span class="keyword">in</span></div><div class="line">      <span class="keyword">self</span>.cartButton.title = <span class="string">"<span class="subst">\(chocolates.<span class="built_in">count</span>)</span> \u&#123;1f36b&#125;"</span></div><div class="line">    &#125;)</div><div class="line">    .addDisposableTo(disposeBag) <span class="comment">//3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将设置一个响应式的<code>Observer</code>来自动更新购物车。如你所见，RxSwift大量使用链式函数，这意味着每一个函数都接受前一个函数的结果。</p>
<p>来解释一下发生的事情：</p>
<ol>
<li>首先，把购物车的<code>chocolates</code>变量作为一个<code>Observable</code>；</li>
<li>在这个<code>Observable</code>上调用<code>subscribe(onNext:)</code>方法，以了解<code>Observable</code>的值的变化。<code>subscribe(onNext:)</code>接受一个闭包作为参数，在每次值改变时，会执行这个闭包。闭包的传入参数是<code>Observable</code>的新值。你将会接受到变更通知，直到你取消订阅或者你的订阅被丢弃。从这个方法得到的是一个实现了<code>Disposable</code>的<code>Observer</code>对象；</li>
<li>将上一步得到的<code>Observer</code>对象添加到<code>disposeBag</code>中，以确保在订阅对象被释放时你的订阅被丢弃。</li>
</ol>
<p>最后，删除命令式的<code>updateCartButton()</code>方法。这将导致在<code>viewWillAppear(_:)</code>和<code>tableView(_:didSelectRowAt:)</code>中报错。</p>
<p>要修复它们，可以删除整个<code>viewWillAppear(_:)</code>方法(因为这里除了调用super外，调用<code>updateCartButton()</code>方法是它唯一做的事情)，并删除<code>tableView(_:didSelectRowAt:)</code>中<code>updateCartButton()</code>方法的调用。</p>
<p>构建并运行。你将看到下面的列表：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-9.26.45-PM.png" width="300" align="center"></p>
<p>但是注意，购物车的按钮只显示了<code>&#39;Item&#39;</code>。当你开始点击列表时，什么都没有发生。这是咋回事？</p>
<p>你创建了一个函数来设置你的<code>Rx Observers</code>，但是现在并没有实际调用它，所以也并没有设置<code>Observers</code>。要解决这个问题，可以在<code>viewDidLoad()</code>里面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setupCartObserver()</div></pre></td></tr></table></figure>
<p>编译并运行程序，可以看到下面的列表：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" width="300" align="center"></p>
<p>点击单元格，购物车中的数量现在可以自动更新了！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" width="300" align="center"></p>
<p>哈哈，现在所有的巧克力都可以添加到购物车了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/rage_chocolate1-1.png" width="300" align="center"></p>
<h2 id="RxCocoa-让TableView响应"><a href="#RxCocoa-让TableView响应" class="headerlink" title="RxCocoa: 让TableView响应"></a>RxCocoa: 让TableView响应</h2><p>现在，你已经使用RxSwift让购物车能响应了，现在将使用RxCocoa让<code>UITableView</code>也能响应。</p>
<p>RxCocoa扩展了UI元素以支持响应式API。这让你可以设置<code>UITableView</code>等视图，而不需要直接重写<code>delegate</code>或<code>data source</code>的方法。</p>
<p>为了演示如何工作，可以删除代码中所有的<code>UITableViewDataSource</code>和<code>UITableViewDelegate</code>协议及所有它们的方法。然后，在<code>viewDidLoad()</code>中删除对<code>tableView.dataSource</code>和<code>tableView.delegate</code>的设置。</p>
<p>编译并运行程序，你可以看到原本让人快乐的小列表没有了，巧克力也没有了：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/no_chocolate_for_you.png" width="300" align="center"></p>
<p>一点都不好玩。现在来把巧克力找回来吧！</p>
<p>首先，为了获得一个响应式的<code>table view</code>，你需要一些让<code>table view</code>响应的东西。在<code>ChocolatesOfTheWorldViewController.swift</code>文件中，更新<code>europeanChocolates</code>属性，让其作为一个<code>Observable</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> europeanChocolates = <span class="type">Observable</span>.just(<span class="type">Chocolate</span>.ofEurope)</div></pre></td></tr></table></figure>
<p><code>just(_:)</code>方法表示不会对<code>Observable</code>对象的底层值做任何修改，但你仍然需要以<code>Observable</code>值的方式来访问它。</p>
<blockquote>
<p>有时，调用<code>just(_:)</code>可能是过度地使用响应式编程了 – 毕竟，如果一个值从不改变，为什么要使用响应式技术呢？在这个例子中，你将使用它来设置将要改变的单元格的响应，不过经常思考如何使用Rx总是件好事。因为虽然你有一个锤子，但不意味着每一个问题都是一个钉子。</p>
</blockquote>
<p>现在你已经让<code>europeanChocolates</code>成为一个<code>Observable</code>，然后添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellConfiguration</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  europeanChocolates</div><div class="line">    .bindTo(tableView</div><div class="line">      .rx <span class="comment">//2</span></div><div class="line">      .items(cellIdentifier: <span class="type">ChocolateCell</span>.<span class="type">Identifier</span>,</div><div class="line">             cellType: <span class="type">ChocolateCell</span>.<span class="keyword">self</span>)) &#123; <span class="comment">// 3</span></div><div class="line">        row, chocolate, cell <span class="keyword">in</span></div><div class="line">        cell.configureWithChocolate(chocolate: chocolate) <span class="comment">//4</span></div><div class="line">      &#125;</div><div class="line">      .addDisposableTo(disposeBag) <span class="comment">//5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释一下：</p>
<ol>
<li>调用<code>bindTo(_:)</code>将<code>europeanChocolates</code> <code>observable</code>关联到应该为<code>table view</code>每一行执行的代码；</li>
<li>调用<code>rx</code>，你可以访问任何类的RxCocoa扩展 – 在这里是UITableView；</li>
<li>调用Rx的<code>items(cellIdentifier:cellType:)</code>方法，传入单元格标识符及要使用的单元格类型。这让Rx框架可以调用出列方法(<code>dequeuing methods</code>)，如果你的<code>table view</code>仍然有原始的代理，这些方法也会被正常调用；</li>
<li>传入一个为每个单元格执行的闭包。闭包的参数包括行信息、行对应的<code>chocolate</code>及单元格对象，这样配置单元格就非常容易了；</li>
<li>获取到<code>bindTo(_:)</code>返回的<code>Disposable</code>，然后添加到<code>disposeBag</code>。</li>
</ol>
<p>通常由<code>tableView(_:numberOfRowsInSection:)</code>和<code>numberOfSections(in:)</code>生成的值，现在基于被观察的数据自动计算。<code>tableView(_:cellForRowAt:)</code>方法被闭包所取代。在<code>viewDidLoad()</code>方法中添加一行来调用新设置的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setupCellConfiguration()</div></pre></td></tr></table></figure>
<p>编译并运行程序，瞧，巧克力又回来了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/no_chocolate_for_you.png" width="300" align="center"></p>
<p>但是，当点击每一个巧克力时，他们并没有被添加到购物车。又是哪不对了？</p>
<p>也木有，之前只是删除了<code>tableView(_:didSelectRowAt:)</code>，这样就没办法识别单元格点击操作了。</p>
<p>为了解决这个问题，需要使用RxCocoa提供的另一个<code>UITableView</code>的扩展方法：<code>modelSelected(_:)</code>，它返回一个<code>Observable</code>，可以观察模型对象什么时候被选中了。</p>
<p>添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellTapHandling</span><span class="params">()</span></span> &#123;</div><div class="line">  tableView</div><div class="line">    .rx</div><div class="line">    .modelSelected(<span class="type">Chocolate</span>.<span class="keyword">self</span>) <span class="comment">//1</span></div><div class="line">    .subscribe(onNext: &#123; <span class="comment">//2</span></div><div class="line">      chocolate <span class="keyword">in</span></div><div class="line">      <span class="type">ShoppingCart</span>.sharedCart.chocolates.value.append(chocolate) <span class="comment">//3</span></div><div class="line"> </div><div class="line">      <span class="keyword">if</span> <span class="keyword">let</span> selectedRowIndexPath = <span class="keyword">self</span>.tableView.indexPathForSelectedRow &#123;</div><div class="line">        <span class="keyword">self</span>.tableView.deselectRow(at: selectedRowIndexPath, animated: <span class="literal">true</span>)</div><div class="line">      &#125; <span class="comment">//4</span></div><div class="line">    &#125;)</div><div class="line">    .addDisposableTo(disposeBag) <span class="comment">//5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来解释一下：</p>
<ol>
<li>调用<code>table view</code>的响应式方法<code>modelSelected(_:)</code>，传入<code>Chocolate</code>模型以获取项目的正确类型。这个方法返回一个<code>Observable</code>；</li>
<li>获取到<code>Observable</code>后，调用<code>subscribe(onNext:)</code>方法，传入一个尾随闭包，在模型被选中时会调用这个闭包；</li>
<li>在尾随闭包中，将选中的巧克力添加到购物车中；</li>
<li>同样在闭包中，确保当前被点击的单元格选中状态被取消；</li>
<li><code>subscribe(onNext:)</code>返回一个<code>Disposable</code>，添加这个<code>Disposable</code>到<code>disposeBag</code>中。</li>
</ol>
<p>最后，在<code>viewDidLoad()</code>中添加下面这行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setupCellTapHandling()</div></pre></td></tr></table></figure>
<p>编译并运行，可以看到熟悉的场景：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" width="300" align="center"></p>
<p>不过现在你可以往购物车添加巧克力了！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" width="300" align="center"></p>
<h2 id="RxSwift和Direct-Text-Input"><a href="#RxSwift和Direct-Text-Input" class="headerlink" title="RxSwift和Direct Text Input"></a>RxSwift和Direct Text Input</h2><p>RxSwift另一个功能是能够获取并响应用户的直接文本输入(<code>Direct Text Input</code>)。</p>
<p>为了尝试一下响应式处理文本输入，你将在信用卡输入表单中添加一些简单的验证和卡类型检测。</p>
<p>非响应式的信用卡处理是由一串<code>UITextFieldDelegate</code>方法来实现的，通常每个方法包含一串的<code>if/else</code>语句，用于区分哪个<code>text field</code>正在被编辑，应该执行什么操作和逻辑处理。</p>
<p>响应式编程将处理操作和逻辑操作直接连接到每个<code>text field</code>。</p>
<p>在<code>BillingInfoViewController.swift</code>，在类的顶部添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure>
<p>和前面一样，这里定义了一个<code>DisposeBag</code>以确保在类的实例被释放时，你的<code>Observables</code>能被正确处理。</p>
<p>对于信用卡号的输入，一个体验比较好的方式是给用户显示信用卡的类型。</p>
<p>为了实现这一操作，可以在<strong>//MARK: - Rx Setup</strong>下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MARK: - Rx Setup</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCardImageDisplay</span><span class="params">()</span></span> &#123;</div><div class="line">  cardType</div><div class="line">    .asObservable()</div><div class="line">    .subscribe(onNext: &#123;</div><div class="line">      cardType <span class="keyword">in</span></div><div class="line">      <span class="keyword">self</span>.creditCardImageView.image = cardType.image</div><div class="line">    &#125;)</div><div class="line">    .addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>稍后，你将依此根据卡类型的更改来更新卡图片。它为变量的值添加了一个<code>Observer</code>，并附加一个闭包在值改变时执行，同时确保<code>Observer</code>添加到<code>disposeBag</code>中以被正确处理。</p>
<p>现在到了最有趣的部分：文本变更处理。</p>
<p>由于用户可能会快速键入，因此你可能不希望每次按键都去验证。这样会导致昂贵的计算和UI卡顿。</p>
<p>一种更好的方式是限制验证的幅度，即只有一定的时间间隔后再去验证用户的输入，而不是每次改变时都去处理。这样，再快的打字速度也不会阻塞整个程序的运行。</p>
<p><code>Throttling</code>是RxSwift的一个特性。因为在一些东西改变时，通常有大量的逻辑操作。而使用<code>Throttling</code>特性，不会产生大量的逻辑操作，而是以一个小的合理的幅度去执行。</p>
<p>首先，在<code>BillingInfoViewController</code>中的其它属性声明下面添加以下内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> throttleInterval = <span class="number">0.1</span></div></pre></td></tr></table></figure>
<p>这里以秒为单位为抖动(<code>throttle</code>)幅度定义了一个常量。</p>
<p>然后添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupTextChangeHandling</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> creditCardValid = creditCardNumberTextField</div><div class="line">    .rx</div><div class="line">    .text <span class="comment">//1</span></div><div class="line">    .throttle(throttleInterval, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//2</span></div><div class="line">    .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(cardText: $<span class="number">0</span>) &#125; <span class="comment">//3</span></div><div class="line"> </div><div class="line">  creditCardValid</div><div class="line">    .subscribe(onNext: &#123; <span class="keyword">self</span>.creditCardNumberTextField.valid = $<span class="number">0</span> &#125;) <span class="comment">//4</span></div><div class="line">    .addDisposableTo(disposeBag) <span class="comment">//5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在设置<code>creditCardValid</code>时得到一个”<code>Generic parameter R could not be inferred</code>“编译错误，通常可以显式的声明它的类型来解决问题，如<code>let creditCardValid: Observable</code>。理论上，编译器能推导出它的类型，但有时候还是需要一些帮助。</p>
</blockquote>
<p>代码的描述如下：</p>
<ol>
<li><code>text</code>是另一个RxCocoa扩展(在使用之前必须先调用<code>rx</code>)，这一次是<code>UITextField</code>的扩展。它将<code>text field</code>的内容作为<code>Observable</code>值返回；</li>
<li>限制输入，以便设置的验证基于设置的时间间隔才运行。<code>scheduler</code>参数是一个更高级的概念，它绑定到一个线程。因为你需要在主线程上执行，所以使用<code>MainScheduler</code>；</li>
<li>将被限制的输入应用于<code>validate(cardText:)</code>来转换它，<code>validate(cardText:)</code>由当前类提供。如果输入的卡有效，则观察到的布尔值的最终值为true；</li>
<li>接受所创建的<code>Observable</code>值并订阅它，根据传入的值来更新<code>text field</code>的验证；</li>
<li>将生成的<code>Disposable</code>添加到<code>disposeBag</code>。</li>
</ol>
<p>将以下代码添加到<code>setupTextChangeHandling()</code>方法下面，以创建有效期和卡安全代码(CVV)的<code>Observable</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> expirationValid = expirationDateTextField</div><div class="line">  .rx</div><div class="line">  .text</div><div class="line">  .throttle(throttleInterval, scheduler: <span class="type">MainScheduler</span>.instance)</div><div class="line">  .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(expirationDateText: $<span class="number">0</span>) &#125;</div><div class="line"> </div><div class="line">expirationValid</div><div class="line">  .subscribe(onNext: &#123; <span class="keyword">self</span>.expirationDateTextField.valid = $<span class="number">0</span> &#125;)</div><div class="line">  .addDisposableTo(disposeBag)</div><div class="line"> </div><div class="line"><span class="keyword">let</span> cvvValid = cvvTextField</div><div class="line">  .rx</div><div class="line">  .text</div><div class="line">  .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(cvvText: $<span class="number">0</span>) &#125;</div><div class="line"> </div><div class="line">cvvValid</div><div class="line">  .subscribe(onNext: &#123; <span class="keyword">self</span>.cvvTextField.valid = $<span class="number">0</span> &#125;)</div><div class="line">  .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure>
<p>现在你已经为三个<code>text field</code>的有效性设置了<code>Observable</code>值，接下来添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> everythingValid = <span class="type">Observable</span></div><div class="line">  .combineLatest(creditCardValid, expirationValid, cvvValid) &#123;</div><div class="line">    $<span class="number">0</span> &amp;&amp; $<span class="number">1</span> &amp;&amp; $<span class="number">2</span> <span class="comment">//All must be true</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">everythingValid</div><div class="line">  .bindTo(purchaseButton.rx.enabled)</div><div class="line">  .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure>
<p>这里使用了<code>Observable</code>的<code>combineLatest(_:)</code>方法将前面创建的三个<code>Observable</code>组合成第四个变量，即<code>everythingValid</code>，其值是否为<code>true</code>取决于前面三个输入是否有效。</p>
<p>然后将<code>everythingValid</code>绑定到<code>UIButton</code>的响应扩展的<code>enabled</code>属性上，这样购买按钮的状态就由<code>everythingValid</code>的值来控制了。</p>
<p>如果所有的输入都有效，那么<code>everythingValid</code>的基础值就为<code>true</code>。如果不是，<code>rx.enabled</code>将会导致基础值被应用于购买按钮，该功能仅在信用卡详细信息有效时启用。</p>
<p>现在你已经创建了<code>setup</code>方法，在<code>viewDidLoad()</code>方法中添加以下代码来调用它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setupCardImageDisplay()</div><div class="line">setupTextChangeHandling()</div></pre></td></tr></table></figure>
<p>编译并运行程序。要进入信用卡输入页面，需要选择一个巧克力将其添加到购物车，然后点击购物车按钮以进入购物车界面。只要购物车中至少有一个巧克力，<code>checkout</code>按钮就是可用的：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/checkout.png" width="300" align="center"></p>
<p>点击<code>Checkout</code>按钮，将进入信用卡输入页面：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/cc_form.png" width="300" align="center"></p>
<p>在卡号<code>text field</code>中输入<code>4</code>–你将看到卡图片显示了<code>Visa</code>的图标：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-7.47.40-PM.png" width="300" align="center"></p>
<p>删除<code>4</code>，卡图片将恢复未知状态。输入<code>55</code>，图片将变成<code>MasterCard</code>：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-7.47.36-PM.png" width="300" align="center"></p>
<p>这个应用涵盖了美国的四种主要信用卡(Visa, MasterCard, American Express, Discover)。如果有有其中一种卡，你可以输入卡号来看看图片是否正确以及卡号是否有效。</p>
<blockquote>
<p>如果你没有这些信用卡，你可以使用Paypal用于测试其沙盒的测试卡卡号，这些应该可以通过程序的所有本地验证，即使卡号实际上是不可用的。</p>
</blockquote>
<p>一旦输入有效的信用卡卡号，同时有效期和cvv也是有效的，那么<code>Buy Chocolate!</code>按钮将被启用：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/enabled_checkout.png" width="300" align="center"></p>
<p>点击按钮查看购买的内容及如何付款的摘要：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/success.png" width="300" align="center"></p>
<p>恭喜你！感谢RxSwift和RxCocoa，你可以买到你的巧克力，想要多少要多少，等你的牙医让你离开为止。</p>
<h2 id="下一步做什么"><a href="#下一步做什么" class="headerlink" title="下一步做什么"></a>下一步做什么</h2><p>最终的代码可以在<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/Chocotastic-finished-s3-rxs-3b1.zip" target="_blank" rel="external">这里</a>找到。</p>
<p>如果你想挑战一下，可以尝试添加一些东西，使这个程序更具响应式：</p>
<ul>
<li>更改<code>CartViewController</code>，以使用响应式<code>table view</code>来显示购物车的内容；</li>
<li>允许用户直接从购物车添加或删除巧克力，并自动更新价格。</li>
</ul>
<p>现在你已经尝试了Rx编程，以下是一些资源，以帮助你继续你的旅程：</p>
<ol>
<li><a href="http://slack.rxswift.org/" target="_blank" rel="external">RxSwift Slack</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">RxSwift’s Getting Started guide</a></li>
<li><a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="external">Max Alexander’s talk on Rx at Realm</a></li>
</ol>
<p>最后，我们的<a href="https://www.raywenderlich.com/u/icanzilb" target="_blank" rel="external">Marin Todorov</a>有一个不错的博客，里面有他的<a href="http://rx-marin.com/" target="_blank" rel="external">rx_marin</a>响应式编程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/ios-techset-9/" itemprop="url">
                  iOS知识小集 第9期(2016.09.23)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-23T19:06:37+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>还有一个星期，一个星期……就是十一长假了，想想还是很激动的。可是我的iPhone 7还是没有着落，哎，想想还是很桑梓啊。什么时候能把这事给办了？</p>
<p>这期换个法吧，无规则有主题，发个关于Instruments的合集。Instruments是我们查找问题和调做强不可缺少的工具，也很强大。所有抽时间把文档撸了一遍，写了几条知识小集，不过还有些没发出来。这期先把之前发的整理整理吧，主要有以下5个问题：</p>
<ol>
<li>使用Instruments检测僵尸对象；</li>
<li>Xcode的Debug navigator中打开Instruments；</li>
<li>Instruments无线Profile；</li>
<li>Instruments访问多次运行的跟踪数据</li>
<li>Abandoned Memory和Generational Analysis</li>
</ol>
<h2 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h2><p>Instruments为我们提供了一个检测僵尸对象的工具：Zombies。使用这个工具时，将会自动开启Enable Zombie Objects模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%201.png?raw=true" alt=""></p>
<p>如下图所示，我们可以看到”Zombies”这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%202.png?raw=true" alt=""></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%203.png?raw=true" alt=""></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%204.png?raw=true" alt=""></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%205.png?raw=true" alt=""></p>
<p>实际上，我们用Allocations工具也可以检测僵尸对象，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Zombies%20profiling%206.png?raw=true" alt=""></p>
<p>我们在属性面板中勾选”Enable NSZombie detection”，其效果和单独使用Zombies工具是一样的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/EradicatingZombies.html" target="_blank" rel="external">Find Zombies</a></li>
</ol>
<h2 id="Xcode的Debug-navigator中打开Instruments"><a href="#Xcode的Debug-navigator中打开Instruments" class="headerlink" title="Xcode的Debug navigator中打开Instruments"></a>Xcode的Debug navigator中打开Instruments</h2><p>Xcode的Debug navigator中提供了几个计量器来帮助我们跟踪程序的性能，包括CPU、内存、电量等。如图1和2所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/debug%20navigator%20to%20instruments%201.png?raw=true" alt=""></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/debug%20navigator%20to%20instruments%202.png?raw=true" alt=""></p>
<p>在每个计量器的详情面板中的右上角，都提供了一个Profile in Instruments按钮，如图2所示(Energy Impact除外，其在面板详情中有几个按钮直接打开Instruments指定的模板，如下图所示)，这些按钮可以让我们直接跳转到Instruments中。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/debug%20navigator%20to%20instruments%203.png?raw=true" alt=""></p>
<p>在点击这些按钮时，会弹出一个提示框，提示“Transfer current debug session?”，下面三个按钮，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/debug%20navigator%20to%20instruments%204.png?raw=true" alt=""></p>
<p>Transfer会在程序当前的运行状态中直接切换到Instruments，然后继续跟踪程序的运行状态；而Restart则是关闭当前运行的程序，重新开始一次新的Profile。</p>
<p>不过，这两种情况都会关闭当前的性能分析(profiling)，启动Instruments，初始一个新的性能分析。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/tvos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Recording,Pausing,andStoppingTraces.html#//apple_ref/doc/uid/TP40004652-CH12-SW1" target="_blank" rel="external">Instruments User Guide</a></li>
</ol>
<h2 id="Instruments无线Profile"><a href="#Instruments无线Profile" class="headerlink" title="Instruments无线Profile"></a>Instruments无线Profile</h2><p>Instruments支持无线的Profile，即设备不需要通过Lighting线连接到Mac电脑，即可进行性能分析。这对于需要使用加速器或者外接配件的应用来说非常有用。如下图所示。</p>
<p><img src="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/instruments_targets_enablewireless_2x.png" alt=""></p>
<p>不过要使用此功能，需要满足两个条件：设备必须是注册过的开发设备；无线网络必须支持Bonjour和多路广播(multicast)。</p>
<p>当然，还需要做一些基本配置，可参考<a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/WorkingwithTargets.html#//apple_ref/doc/uid/TP40004652-CH10-SW1" target="_blank" rel="external">Instruments User Guide：Target Devices and Processes</a>。</p>
<p>上周五捣鼓了一会，木有成功，后来发现是网络不支持。</p>
<h2 id="Instruments访问多次运行的跟踪数据"><a href="#Instruments访问多次运行的跟踪数据" class="headerlink" title="Instruments访问多次运行的跟踪数据"></a>Instruments访问多次运行的跟踪数据</h2><p>Instruments在一次运行期间可以记录App的多次运行记录。以Allocations为例，开启Instruments后，每结束一次Allocations分析，这条分析就会被记录下来，下次再开启分析时，我们仍然可以看到前一次分析的信息，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Access%20Trace%20Data%20for%20Multiple%20Runs.png?raw=true" alt=""></p>
<p>通过这些记录，我们可以对比每次分析的差别。这样我们就可以边修改程序，边用Instruments来对其进行分析，并通过这种对比来观察修改的效果。</p>
<p>当然，关闭Instruments时，如果不保存信息，这些记录会被清理掉。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/NavigatingtheTimelinePane.html#//apple_ref/doc/uid/TP40004652-CH85-SW1" target="_blank" rel="external">Instruments User Guide：Navigate the Timeline Pane</a></li>
</ol>
<h2 id="Abandoned-Memory和Generational-Analysis"><a href="#Abandoned-Memory和Generational-Analysis" class="headerlink" title="Abandoned Memory和Generational Analysis"></a>Abandoned Memory和Generational Analysis</h2><p>说到内存问题，我们更多的会想到内存泄露和野指针，而实际上还有一类看似不是问题的内存问题：Abandoned Memory(被遗弃的内存)。这类内存可能由于某些原因被分配，但并非一直需要，只是可能在程序运行期的某个时间需要，如内存缓存的图片，还有一个比较普遍的东西–单例。</p>
<p>我们可能会为某个模块创建一个单例对象来维护这个模块所需要的数据，但在退出模块后，这个单例对象依然存在。与内存泄露不同，这些对象从技术上讲依然是有效的。但实际上可能在程序后续的运行中不会再被使用。</p>
<p>使用Instruments定位内存问题，内存泄露和野指针的定位相对来说容易些，内存泄露使用Leaks，野指针则可以使用僵尸对象。而Abandoned Memory则相对不那么明显。Abandoned Memory可以采用所谓的Generational Analysis方法来分析，即反复进入退出某一场景，查看内存的分配与释放情况，以定位哪些对象是属于Abandoned Memory的范畴。</p>
<p>在Allocations工具中，有专门的Generational Analysis设置，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Abandoned%20Memory%201.png?raw=true" alt=""></p>
<p>我们可以在程序运行时，在进入某个模块前标记一个Generation，这样会生成一个快照。然后进入、退出，再标记一个Generation，如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Abandoned%20Memory%202.png?raw=true" alt=""></p>
<p>在详情面板中我们可以看到两个Generation间内存的增长情况，其中就可能存在潜在的被遗弃的对象，如下图所示。定位到问题，即可做相应的优化。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Abandoned%20Memory%203.png?raw=true" alt=""></p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingAbandonedMemory.html#//apple_ref/doc/uid/TP40004652-CH80-SW1" target="_blank" rel="external">Find Abandoned Memory</a></li>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CommonMemoryProblems.html#//apple_ref/doc/uid/TP40004652-CH91-SW1" target="_blank" rel="external">About Memory Analysis</a></li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Instruments是一个强大的分析工具，其基于DTrace，为我们提供了丰富的功能。在实际开发中，采用正确的姿式来使用Instruments，可以帮我们提高程序的性能、稳定性等。相信大家都经常用三件套：Time Profile、Allocations、Leaks。当然，其它还有很多模板，也可以多去试试。</p>
<hr>
<p>欢迎关注我的微信公众号：iOS知识小集，扫扫左边站点概览里的二维码就OK了，还有微博：<a href="http://weibo.com/touristdiary" target="_blank" rel="external">@南峰子_老驴</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/ios-techset-8/" itemprop="url">
                  iOS知识小集 第8期(2016.09.20)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T22:38:43+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年的Apple发布会也开完了，没有什么太出彩的地方。不过广受非议的iPhone 7依然大卖。群里、微信里都是各种讨论外加各种炫，而我只能静静地看着，等着公司的测试机了。</p>
<p>每次都感叹时间过得快，总是有各种事情，这一晃又三个星期了，哎。这期整理了之前的5个问题，无规则无主题，大伙慢慢看：</p>
<ol>
<li>block未判空导致的EXC_BAD_ACCESS崩溃;</li>
<li>多Target开发;</li>
<li>dispatch_sync导致死锁;</li>
<li>makeObjectsPerformSelector:;</li>
<li>NSSetUncaughtExceptionHandler</li>
</ol>
<h2 id="block未判空导致的EXC-BAD-ACCESS崩溃"><a href="#block未判空导致的EXC-BAD-ACCESS崩溃" class="headerlink" title="block未判空导致的EXC_BAD_ACCESS崩溃"></a>block未判空导致的EXC_BAD_ACCESS崩溃</h2><p>我们在调用block时，如果这个block为nil，则程序会崩溃，报类似于EXC_BAD_ACCESS(code=1, address=0xc)异常[32位下的结果，如果是64位，则address=0x10]。如下图所示，这个异常表示程序在试图读取内存地址0xc的信息时出错。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/block.EXC_BAD_ACCESS.png?raw=true" alt=""></p>
<p>在定义一个block时，编译器会在栈上创建一个结构体，类似于图2的结构体。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Block_layout &#123;</div><div class="line">	<span class="keyword">void</span> *isa;</div><div class="line">	<span class="keyword">int</span> flags;</div><div class="line">	<span class="keyword">int</span> reserved;</div><div class="line">	<span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</div><div class="line">	<span class="keyword">struct</span> Block_descriptor *descriptor;</div><div class="line">	<span class="comment">/* Imported variables. */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>block就是指向这个结构体的指针。其中的invoke就是指向具体实现的函数指针。当block被调用时，程序最终会跳转到这个函数指针指向的代码区。而当block为nil时，程序就会试图去读取0xc地址的信息，而这个地址什么都不会有(duff address)，于是抛出一个segmentation fault。在32位系统下，之所以是0xc，是因为invoke前面的三个成员变量的大小正好是12。</p>
<p>所以我们在使用block时，应该首先去判断block是否为空。一种比较优雅的写法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!block ?: block()</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/4145164/why-do-nil-null-blocks-cause-bus-errors-when-run" target="_blank" rel="external">Why do nil / NULL blocks cause bus errors when run?</a></li>
</ol>
<h2 id="多Target开发"><a href="#多Target开发" class="headerlink" title="多Target开发"></a>多Target开发</h2><p>在Xcode中，一个target表示工程中的一个product，target用于组织product所需要的源文件、资源文件、配置信息等。</p>
<p>在一些情况下，我们可以为一个工程设置多个target，如：同时开发Lite版和正式版；开发版本和发布版本需要不同配置；单工程构建多个相似的App等等。如下图所示。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/target.mutiply.png?raw=true" alt=""></p>
<p>这么做的好处是在共用一份代码的情况下，可以为不同的target配置不同的资源、信息等，如不同的Info.plist, Build Setting, Build Phase配置等，最后得到不同的product。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Targets.html" target="_blank" rel="external">Xcode Target</a></li>
<li><a href="http://blog.devtang.com/2013/10/17/the-tech-detail-of-ape-client-1/" target="_blank" rel="external">猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App</a></li>
</ol>
<h2 id="dispatch-sync导致死锁"><a href="#dispatch-sync导致死锁" class="headerlink" title="dispatch_sync导致死锁"></a>dispatch_sync导致死锁</h2><p>dispatch_sync函数用于将一个block提交到队列中同步执行，直到block执行完后，这个函数才会返回。</p>
<p>这里有一个潜在的问题，如果我们在某个串行队列中调用dispatch_sync，并将其block提交到这个串行队列中执行，则会引发死锁。如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.apple.test"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">  </div><div class="line">  <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"B"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实还是很好理解，在com.apple.test这个串行队列中，我们执行一个task A，在这个task A中，我们又向队列提交了一个同步的task B。由于是串行队列，task A在task B之前，所以task B的执行依赖于task A的完成，而task B又包含在task A中，task A的完成依赖于task B的完成。这样就成了一个死锁。</p>
<p>所以，千万不要在主队列中这样调用dispatch_sync，否则会导致主线程卡死。</p>
<p>当然，如果在并行队列中这样使用是没有问题的，如下代码所示，可以正常打印出B,A。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">  </div><div class="line">  <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"B"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>又或是dispatch_sync的目标队列不是当前队列，如下代码所示，也可以正常打印出B,A。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.apple.test1"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.apple.test2"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</div><div class="line">  </div><div class="line">  <span class="built_in">dispatch_sync</span>(queue2, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"B"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们在使用dispatch_sync提交task时，可以看到大部分情况下task是在dispatch_sync所在的上下文线程中执行，而不管dispatch_sync指定的队列是什么【串行或并行】，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 串行队列</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);     <span class="comment">// &lt;NSThread: 0x100303310&gt;&#123;number = 1, name = main&#125;</span></div><div class="line">    </div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.apple.test"</span>, <span class="literal">NULL</span>);</div><div class="line">   </div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);     <span class="comment">// &lt;NSThread: 0x100303310&gt;&#123;number = 1, name = main&#125;</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 并行队列</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">       </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);     <span class="comment">// &lt;NSThread: 0x100505ea0&gt;&#123;number = 2, name = (null)&#125;</span></div><div class="line">  </div><div class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.apple.test"</span>, <span class="literal">NULL</span>);</div><div class="line">  </div><div class="line">  <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);    <span class="comment">// &lt;NSThread: 0x100505ea0&gt;&#123;number = 2, name = (null)&#125;</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>官方文档给我们的解释是这么做的目的是为了优化性能：</p>
<blockquote>
<p>As an optimization, this function invokes the block on the current thread when possible。</p>
</blockquote>
<p>我们需要了解的是队列和线程并不是一回事。我们将任务以block的形式提交到队列，然后由GCD来决定将队列中的block分发到系统管理的线程池中的某个线程中去执行。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/reference/dispatch/1452870-dispatch_sync" target="_blank" rel="external">dispatch_sync</a></li>
</ol>
<h2 id="makeObjectsPerformSelector"><a href="#makeObjectsPerformSelector" class="headerlink" title="makeObjectsPerformSelector:"></a>makeObjectsPerformSelector:</h2><p>遍历一个数组的方法有几种，for, forin, enumerateObjectsUsingBlock:方法。现在用得比较多的可能是enumerateObjectsUsingBlock:，它能很方便地让我们获取到数组中的元素及对应的索引，然后根据这些信息做一些操作，如下代码所示:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</div><div class="line">  </div><div class="line">  Test *t = [[Test alloc] init];</div><div class="line">  t.index = index;</div><div class="line">  [array addObject:t];</div><div class="line">&#125;</div><div class="line">   </div><div class="line">[array enumerateObjectsUsingBlock:^(Test *  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">  [obj test];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>不过，如果在循环中，只是想调用元素的某一个方法，则可以考虑使用makeObjectsPerformSelector:或者makeObjectsPerformSelector:withObject:，这两个方法会按元素的顺序向数组中的每个元素发送Selector指定的消息。如下代码所示:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</div><div class="line">  </div><div class="line">  Test *t = [[Test alloc] init];</div><div class="line">  t.index = index;</div><div class="line">  [array addObject:t];</div><div class="line">&#125;</div><div class="line">   </div><div class="line">[array makeObjectsPerformSelector:<span class="keyword">@selector</span>(test)];</div><div class="line">[array makeObjectsPerformSelector:<span class="keyword">@selector</span>(testWithNumber:) withObject:@<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p>当然，Selector不能是NULL，否则会抛NSInvalidArgumentException异常。大家如果熟悉runtime的话，应该知道消息机制是如何处理调用不存在方法的。</p>
<h2 id="NSSetUncaughtExceptionHandler"><a href="#NSSetUncaughtExceptionHandler" class="headerlink" title="NSSetUncaughtExceptionHandler"></a>NSSetUncaughtExceptionHandler</h2><p>Foundation里面提供了一个NSSetUncaughtExceptionHandler函数，可以设置一个顶层异常处理函数，让我们在程序发生异常并终止前，有最后的机会来捕获并输出异常信息，如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *symbols = [exception callStackSymbols];</div><div class="line">    <span class="built_in">NSString</span> *reason = [exception reason];</div><div class="line">    <span class="built_in">NSString</span> *name = [exception name];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"reason = %@"</span>, reason);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name = %@"</span>, name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"symbols = %@"</span>, symbols);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个函数的参数是一个函数指针，指向的函数其签名是：void NSUncaughtExceptionHandler(NSException *exception)。可以看到这个函数有参数是一个NSException对象，通过这个对象我们就可以获取到异常的信息。假定发生数组越界异常时，会有如下输出。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">36.719</span> Test111[<span class="number">5548</span>:<span class="number">199035</span>] reason = *** -[__NSSingleObjectArrayI objectAtIndex:]: index <span class="number">10</span> beyond bounds [<span class="number">0</span> .. <span class="number">0</span>]</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">36.720</span> Test111[<span class="number">5548</span>:<span class="number">199035</span>] name = <span class="built_in">NSRangeException</span></div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">36.720</span> Test111[<span class="number">5548</span>:<span class="number">199035</span>] symbols = (</div><div class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x0000000106cef34b</span> __exceptionPreprocess + <span class="number">171</span></div><div class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x000000010675021e</span> objc_exception_throw + <span class="number">48</span></div><div class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x0000000106d47bdf</span> -[__NSSingleObjectArrayI objectAtIndex:] + <span class="number">111</span></div><div class="line">	<span class="number">3</span>   Test111                             <span class="number">0x000000010617d87b</span> -[AppDelegate application:didFinishLaunchingWithOptions:] + <span class="number">235</span></div><div class="line">	<span class="number">4</span>   <span class="built_in">UIKit</span>                               <span class="number">0x000000010710968e</span> -[<span class="built_in">UIApplication</span> _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + <span class="number">290</span></div><div class="line">	<span class="number">5</span>   <span class="built_in">UIKit</span>                               <span class="number">0x000000010710b013</span> -[<span class="built_in">UIApplication</span> _callInitializationDelegatesForMainScene:transitionContext:] + <span class="number">4236</span></div><div class="line">	<span class="number">6</span>   <span class="built_in">UIKit</span>                               <span class="number">0x00000001071113b9</span> -[<span class="built_in">UIApplication</span> _runWithMainScene:transitionContext:completion:] + <span class="number">1731</span></div><div class="line">	<span class="number">7</span>   <span class="built_in">UIKit</span>                               <span class="number">0x000000010710e539</span> -[<span class="built_in">UIApplication</span> workspaceDidEndTransaction:] + <span class="number">188</span></div><div class="line">	<span class="number">8</span>   FrontBoardServices                  <span class="number">0x000000010a2ee76b</span> __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + <span class="number">24</span></div><div class="line">	<span class="number">9</span>   FrontBoardServices                  <span class="number">0x000000010a2ee5e4</span> -[FBSSerialQueue _performNext] + <span class="number">189</span></div><div class="line">	<span class="number">10</span>  FrontBoardServices                  <span class="number">0x000000010a2ee96d</span> -[FBSSerialQueue _performNextFromRunLoopSource] + <span class="number">45</span></div><div class="line">	<span class="number">11</span>  CoreFoundation                      <span class="number">0x0000000106c94311</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + <span class="number">17</span></div><div class="line">	<span class="number">12</span>  CoreFoundation                      <span class="number">0x0000000106c7959c</span> __CFRunLoopDoSources0 + <span class="number">556</span></div><div class="line">	<span class="number">13</span>  CoreFoundation                      <span class="number">0x0000000106c78a86</span> __CFRunLoopRun + <span class="number">918</span></div><div class="line">	<span class="number">14</span>  CoreFoundation                      <span class="number">0x0000000106c78494</span> <span class="built_in">CFRunLoopRunSpecific</span> + <span class="number">420</span></div><div class="line">	<span class="number">15</span>  <span class="built_in">UIKit</span>                               <span class="number">0x000000010710cdb6</span> -[<span class="built_in">UIApplication</span> _run] + <span class="number">434</span></div><div class="line">	<span class="number">16</span>  <span class="built_in">UIKit</span>                               <span class="number">0x0000000107112f34</span> <span class="built_in">UIApplicationMain</span> + <span class="number">159</span></div><div class="line">	<span class="number">17</span>  Test111                             <span class="number">0x000000010617db4f</span> main + <span class="number">111</span></div><div class="line">	<span class="number">18</span>  libdyld.dylib                       <span class="number">0x000000010928a68d</span> start + <span class="number">1</span></div><div class="line">	<span class="number">19</span>  ???                                 <span class="number">0x0000000000000001</span> <span class="number">0x0</span> + <span class="number">1</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>不过这个函数有效范围局限于异常，还有很多错误是无法处理的，如EXC_BAD_ACCESS内存访问错误，这类错误抛出的是Signal，需要专门做Signal处理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Crash始终是我们开发最大最头疼的问题，总会有各种各样的Crash情况出现。看着Fabric里面长长的Crash列表，总是很伤感的。我们的成长史也是一部和Bug战斗的斗争史，自己写的Bug，熬夜也要把它们搞完。继续战斗吧，Bug君。</p>
<hr>
<p>欢迎关注我的微信公众号：iOS知识小集，扫扫左边站点概览里的二维码就OK了。对了，还有微博：<a href="http://weibo.com/touristdiary" target="_blank" rel="external">@南峰子_老驴</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/ios-techset-7/" itemprop="url">
                  iOS知识小集 第7期(2016.08.31)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T09:02:14+08:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好久没写这个系列了，一看都快一年了，当时说好的呢？嗯，说来总是有各种借口，所以还是不说，直接开始新的一期。之前在微博上发了不少知识小集，到现在应该有50多条了，都是平时开发遇到的一些问题，或者看书，看文档，看博客，看WWDC的一些笔记，分享出来。所以在这偷个懒，做一个合集，每期把微博上的知识小集集中一下，可别吐槽。</p>
<p>本期主要收集以下几个小问题：</p>
<ol>
<li>UIImageView显示gif图片有两种方式</li>
<li>Objective-C中的BOOL类型</li>
<li>dispatch_once死锁</li>
<li>GNU 复合语句</li>
<li>URL转义</li>
</ol>
<h2 id="UIImageView显示gif图片有两种方式"><a href="#UIImageView显示gif图片有两种方式" class="headerlink" title="UIImageView显示gif图片有两种方式"></a>UIImageView显示gif图片有两种方式</h2><p>UIImageView显示gif图片有两种方式。当然前提都是先将gif中的每一帧取出来放到一个个UIImage对象中，将这些对象放到一个数组中，如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</div><div class="line">size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</div><div class="line">    </div><div class="line"><span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">   <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</div><div class="line">   [images addObject:[<span class="built_in">UIImage</span> imageWithCGImage:image scale:[<span class="built_in">UIScreen</span> mainScreen] orientation:<span class="built_in">UIImageOrientationUp</span>]];</div><div class="line">   <span class="built_in">CGImageRelease</span>(image);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="built_in">CFRelease</span>(source)</div></pre></td></tr></table></figure>
<p>一种方式是将这些UIImage对象通过UIImage的类方法<code>+animatedImageWithImages:duration:</code>组合成一个UIImage对象，然后赋值给UIImageView对象的image属性。</p>
<p>第二种方式是将UIImage对象的数组赋值给UIImageView对象的<code>animationImages</code>属性，然后调用UIImageView对象的<code>startAnimating</code>方法来启动动画。</p>
<p>当然，两种方式都需要计算<code>duration</code>。</p>
<h2 id="Objective-C中的BOOL类型"><a href="#Objective-C中的BOOL类型" class="headerlink" title="Objective-C中的BOOL类型"></a>Objective-C中的BOOL类型</h2><p>Objective-C中的BOOL类型在Watch和64位iOS上的原始类型为bool，而在其它情况下是<code>signed char</code>。我们用<code>@encode</code>去看看BOOL的类型串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@encode(BOOL)		// 64位iOS系统：&quot;B&quot;</div><div class="line">@encode(BOOL)		// 32位iOS系统，32/64位OS X：&quot;c&quot;</div></pre></td></tr></table></figure>
<p>所有这边有一个问题，下面这段代码中变量b的值在不同环境下，其结果可能是不一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL a = 100 &amp; 20;</div><div class="line">BOOL b = (a == YES);</div></pre></td></tr></table></figure>
<p>当BOOL为bool时，b的值为1；而当BOOL为<code>signed char</code>时，b的值为0。所以，如果我们判断一个BOOL值是否为真时，不应该通过<code>if(a == YES)</code>这种方式来判断，要么直接就<code>if (a)</code>，要么就<code>if (a != NO)</code>。</p>
<h2 id="dispatch-once死锁"><a href="#dispatch-once死锁" class="headerlink" title="dispatch_once死锁"></a>dispatch_once死锁</h2><p>在iOS开发中，我们经常会使用到单例，现在Objective-C中写单例的标配是使用<code>dispatch_once</code>。相信这个函数的意义大家都非常清楚了，就是希望<code>dispatch_once</code>参数中的block在全局只执行一次。这个基本上没什么问题。</p>
<p>不过，今天在工程中看到类似于下面这样的代码。在主线程中调用<code>test()</code>方法，会有什么结果呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> test() &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        test();</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    printf(<span class="string">"This is a test"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>死锁。是的，死锁，线程直接卡住了。为什么呢？</p>
<p>我们暂停程序，可以看到程序的调用栈，如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/dispatch_once%201.jpg?raw=true" alt="image"></p>
<p>发现程序是卡在<code>dispatch_once_f</code>中。研究一下<code>dispatch_once_f</code>的实现吧，如下代码所示，会发现一些有意思的东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> <span class="number">_</span>dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval =</div><div class="line">			(<span class="keyword">struct</span> <span class="number">_</span>dispatch_once_waiter_s**)val;</div><div class="line">	<span class="keyword">struct</span> <span class="number">_</span>dispatch_once_waiter_s dow = &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</div><div class="line">	<span class="keyword">struct</span> <span class="number">_</span>dispatch_once_waiter_s *tail, *tmp;</div><div class="line">	<span class="keyword">_dispatch_thread_semaphore_t</span> sema;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, <span class="literal">NULL</span>, &amp;dow)) &#123;</div><div class="line">		dispatch_atomic_acquire_barrier();</div><div class="line">		<span class="number">_</span>dispatch_client_callout(ctxt, func);</div><div class="line"></div><div class="line">		dispatch_atomic_maximally_synchronizing_barrier();</div><div class="line">		<span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span></div><div class="line">		tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</div><div class="line">		tail = &amp;dow;</div><div class="line">		<span class="keyword">while</span> (tail != tmp) &#123;</div><div class="line">			<span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</div><div class="line">				<span class="number">_</span>dispatch_hardware_pause();</div><div class="line">			&#125;</div><div class="line">			sema = tmp-&gt;dow_sema;</div><div class="line">			tmp = (<span class="keyword">struct</span> <span class="number">_</span>dispatch_once_waiter_s*)tmp-&gt;dow_next;</div><div class="line">			<span class="number">_</span>dispatch_thread_semaphore_signal(sema);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		dow.dow_sema = <span class="number">_</span>dispatch_get_thread_semaphore();</div><div class="line">		<span class="keyword">for</span> (;;) &#123;</div><div class="line">			tmp = *vval;</div><div class="line">			<span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			dispatch_atomic_store_barrier();</div><div class="line">			<span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</div><div class="line">				dow.dow_next = tmp;</div><div class="line">				<span class="number">_</span>dispatch_thread_semaphore_wait(dow.dow_sema);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="number">_</span>dispatch_put_thread_semaphore(dow.dow_sema);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单描述一下吧。<code>onceToken</code>在第一次执行block之前，其值将由NULL变为指向第一个调用者的指针(<code>&amp;dow</code>)。如果在<code>block</code>完成之前，有其它的调用者进来，则会把这些调用者放到一个<code>waiter</code>链表中(走else分支)，直到<code>block</code>执行完成。<code>waiter</code>链中的每个调用者都会等待一个信号量(<code>dow.dow_sema</code>)。在block执行完成后，除了将<code>onceToken</code>置为<code>DISPATCH_ONCE_DONE</code>外，还会去遍历<code>waiter</code>链中的所有<code>waiter</code>，抛出相应的信号量，以告知<code>waiter</code>们调用结束。</p>
<p>因此上面的死锁问题就好理解了。递归调用<code>test()</code>时，第二次调用作为一个<code>waiter</code>，在等待block完成，而block的完成依赖于<code>test()</code>的执行完成，这就成了一个死锁。</p>
<p>所以应该避免在<code>dispatch_once</code>做递归调用，不管是直接的还是间接的。</p>
<p>再说回单例，个人看法是单例是个好东西，但应该在适当的场景使用。不能因为简便就滥用。抛开内存问题不说，使用不当的话，单例类迟早会变成一个垃圾场。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/19176219/why-am-i-getting-deadlock-with-dispatch-once" target="_blank" rel="external">Why am I getting deadlock with dispatch_once?</a></li>
<li><a href="https://satanwoo.github.io/2016/04/11/dispatch-once/" target="_blank" rel="external">滥用单例之dispatch_once死锁</a></li>
<li><a href="https://github.com/nickhutchinson/libdispatch/blob/d7c78607cd2d971da86a8e3ac8b8ff0fb97ef6b8/src/once.c" target="_blank" rel="external">libdispatch</a></li>
</ol>
<h2 id="GNU-复合语句"><a href="#GNU-复合语句" class="headerlink" title="GNU 复合语句"></a>GNU 复合语句</h2><p>我们在看一些第三方的代码时，可能会看到类似于下面的代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.view addSubview:(&#123;</div><div class="line">   <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:(<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, <span class="number">100.0</span>f, <span class="number">100.0</span>f&#125;];</div><div class="line">   view.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">   view.layer.masksToBounds = <span class="literal">YES</span>;</div><div class="line">   view.layer.cornerRadius = <span class="number">4.0</span>f;</div><div class="line">   view;</div><div class="line">&#125;)];</div></pre></td></tr></table></figure>
<p><code>addSubview</code>的参数放在一个”({})”代码块中，而view的创建及属性设置都是在”({})”完成，代码块最后一句即我们要添加的子view。</p>
<p>这种写法沿用了<code>GNU C</code>的一个特性，即复合语句(<code>compound statement</code>)。即在”({})”代码块中，我们可以放置多个语句，这些语句可以是循环、分支、变量声明、函数调用等。而复合语句的最后一句是一个表达式，其作为整个复合语句的最终值。</p>
<p>在写Objective-C代码时，使用复合语句能让我们的代码变得更优雅，特别是创建并添加一堆子view时，能让我们的代码看上去更整洁。建议经常使用。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs" target="_blank" rel="external"> Statements and Declarations in Expressions</a></li>
</ol>
<h2 id="URL转义"><a href="#URL转义" class="headerlink" title="URL转义"></a>URL转义</h2><p>在使用<code>+URLWithString:</code>或<code>-initWithString:</code>来创建一个URL对象时，提供的参数字符串必须符合RFC 2396标准<a href="https://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">Uniform Resource Identifiers (URI): Generic Syntax</a>。而这两个方法又是根据RFC 1738 <a href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="external">Uniform Resource Locators (URL)</a>和1808 <a href="https://www.ietf.org/rfc/rfc1808.txt" target="_blank" rel="external">Relative Uniform Resource Locators</a>两个标准来解析字符串的。故弄玄虚一下。当然我们不需要去了解所有的细节，简单了解一下就行，可以参考一下阮大侠的这篇<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="external">关于URL编码</a>。</p>
<p>这里要说明的就是：对于我们而言，如果用带有中文的字符串(如”<a href="https://www.baidu.com?q=北京" target="_blank" rel="external">https://www.baidu.com?q=北京</a>“)去创建一个URL对象的话，返回的是一个nil。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/url%20encode%201.jpg?raw=true" alt="image"></p>
<p>我们所需要做的就是对不符合标准的字符串进行转义操作。<code>NSString</code>类提供了两个方法来做这种转义操作，一个是<code>-stringByAddingPercentEscapesUsingEncoding:</code>，不过这个方法在iOS 9.0已被废弃；现在更提倡的是用<code>-stringByAddingPercentEncodingWithAllowedCharacters:</code>方法，这个方法是iOS 7.0后添加的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>知识是一点一点积累的，每天一两点，一段时间后，收获也会很大。知识小集的初衷就是这样。</p>
<p>当然，另一方面也需要系统性地去学习整理一些知识，才能把零零碎碎的东西串起来。</p>
<hr>
<p>欢迎关注我的微信公众号：iOS知识小集，扫扫左边<strong>站点概览</strong>里的二维码就OK了。对了，还有微博：<a href="http://weibo.com/touristdiary" target="_blank" rel="external">@南峰子_老驴</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/javascriptcore-tutorial-for-ios-getting-started/" itemprop="url">
                  JavaScriptCore Tutorial for iOS: Getting Started
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T16:58:06+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由József Vesza发表于raywenderlich，原文地址是<a href="https://www.raywenderlich.com/124075/javascriptcore-tutorial" target="_blank" rel="external">https://www.raywenderlich.com/124075/javascriptcore-tutorial</a></p>
</blockquote>
<p>自从2014年Swift发布以来，其受欢迎程度直线上升：从TIOBE的数据来看，在2016年二月份，它的排名已经上升到第16位。不过，同时我们可以看到排名第9位的是Javascript，这门语言与Swift有许多不同之处：Swift在编译时安全性上做了很多努力，而Javascript是弱类型且动态的。</p>
<p>Swift与Javascript有很多不一样的地方，不过有一件事却将他们紧紧绑在一起：你可以使用他们来创建一个轻量级的iOS应用。</p>
<p>在这篇JavaScriptCore的教程中，你将构建一个用于显示类似web页面的iOS应用，并重用web页面现存的Javascript代码。特别是你将了解以下几点：</p>
<ul>
<li>JavaScriptCore框架的组件</li>
<li>如何在iOS代码中调用Javascript方法</li>
<li>如何在Javascript代码中访问本地代码</li>
</ul>
<blockquote>
<p>注：你不需要有JavaScript的经验。如果这篇JavaScriptCore教程已经激起你学习这门语言的兴趣，那么<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">Mozilla Developer Network</a>对于初学者来说是一个非常棒的资源 - 或者你也可以选择看<a href="http://blog.wix.engineering/wp-content/uploads/2015/04/mIuuwgx-1024x576.jpg" target="_blank" rel="external">这里</a>介绍的两本书。</p>
</blockquote>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>下载这篇教程的<a href="http://www.raywenderlich.com/wp-content/uploads/2016/02/Showtime-Starter.zip" target="_blank" rel="external">初始工程</a>并解压。你可以看到下面的目录结构：</p>
<ul>
<li>Web：包含将被转换为iOS应用的web页面的HTML和CSS文件。</li>
<li>Native：iOS工程。文章中所有的修改都是在这里。</li>
<li>js：包含用于工程的Javascript代码。</li>
</ul>
<p>App名叫Showtime，用于搜索iTunes上的付费电影。为了查看它的效果，可以用浏览器打开Web/index.html页面，输入你要的价格，然后按下<code>return</code>按钮。</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/01/5.jpg" alt="image"></p>
<p>如果想在iOS上测试Showtime，则可以打开Native/Showtime中的工程。编译并运行App来看看效果：</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/02/Simulator-Screen-Shot-20-Feb-2016-21.25.58-1.png" alt="image"></p>
<p>正如你所看到的，手机中的App还未准备就绪，不过我们慢慢来补充它。工程已经包含了一些代码；我们会一步一步来完善。这个App的目的是提供一个类似web页面的体验：它将把搜索结果显示在一个Collection View中。</p>
<h2 id="JavaScriptCore是什么？"><a href="#JavaScriptCore是什么？" class="headerlink" title="JavaScriptCore是什么？"></a>JavaScriptCore是什么？</h2><p>JavaScriptCore框架提供了访问WebKit的Javascript引擎的机制。最初这个框架只有一些支持Mac系统的C API，但到了iOS 7和OS X 10.9后，它提供了一个更加友好的Objective-C封装。这个框架为Swift/Objective-C和Javascript代码提供了更强大的互通性。</p>
<blockquote>
<p>注：React Native演示了JavaScriptCore强大功能。如果你想了解如何使用Javascript构建本地应用，你可以看看本站的<a href="http://www.raywenderlich.com/99473/introducing-react-native-building-apps-javascript" target="_blank" rel="external">Introducing React Native tutorial</a>一文。</p>
</blockquote>
<p>在这一节中，你将近距离于窥探一下JavaScriptCore的API。JavaScriptCore包含几个主要的组件：JSVirtualMachine、JSContext和JSValue。下面描述它们是如何整合在一起的。</p>
<h3 id="JSVirtualMachine"><a href="#JSVirtualMachine" class="headerlink" title="JSVirtualMachine"></a>JSVirtualMachine</h3><p>JavaScript代码是在由JSVirtualMachine类表示的一个虚拟机上执行的。通常情况下你不需要直接与这个类交互，但有一种情况例外：并发执行JavaScript代码。在一个独立的JSVirtualMachine中，是不可能同一时间执行多个线程的。为了支持并行，你必须使用多个虚拟机。</p>
<p>每一个JSVirtualMachine实例都有自己的堆和自己的垃圾回收器，这意味着你不能在虚拟机之间传递对象。一个虚拟机的垃圾收集器不知道如何去处理另一个堆上的值。</p>
<h3 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h3><p>一个JSContext对象表示JavaScript代码的执行环境。它对应于一个单一的全局对象；它的web开发环境等同于一个窗口对象。不同于一个虚拟机，你可以在多个上下文之间传递对象(因为它们位于同一虚拟机)。</p>
<h3 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h3><p>JSValue是我们需要处理的主要数据类型：它可以表示任何可能的Javascript值。一个JSValue被绑定到其存活的JSContext对象中。任何来源于上下文对象的值都是JSValue类型。</p>
<p>下图显示了这几个对象是如何一起工作的：</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2016/02/javascriptcore.png" alt="image"></p>
<p>现在你对JavaScriptCore框架有了一个更好的了解了，就让我们来写一些代码吧。</p>
<h2 id="调用Javascript方法"><a href="#调用Javascript方法" class="headerlink" title="调用Javascript方法"></a>调用Javascript方法</h2><p>回到Xcode，在project navigator中展开Data group，并打开MovieService.swift。这个类将获取并处理来源于iTunes的电影结果。不过现在它几乎是空的；接下来就由你来提供这些方法的具体实现。</p>
<p>MovieService的工作流程如下：</p>
<ul>
<li><code>loadMoviesWithLimit(_:onComplete:)</code>将获取电影数据。</li>
<li><code>parseResponse(_:withLimit:)</code>将使用共享的JavaScript代码来处理响应数据。</li>
</ul>
<p>第一步是获取电影列表。如果你熟悉JavaScript开发，你会知道一般是使用XMLHttpRequest对象来访问网络。这个对象并不是语言本身的一部分，所以你不能将它用于一个iOS App的上下文中。相反，你应该使用本地网络代码。</p>
<p>在MovieService类中，找到<code>loadMoviesWithLimit(_:onComplete:)</code>方法并按以下代码来修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadMoviesWithLimit</span><span class="params">(limit: Double, onComplete complete: [Movie] -&gt; <span class="params">()</span></span></span>) &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: movieUrl) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Invalid url format: <span class="subst">\(movieUrl)</span>"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data,</div><div class="line">        jsonString = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>) <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"Error while parsing the response data."</span>)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> movies = <span class="keyword">self</span>.parseResponse(jsonString, withLimit:limit)</div><div class="line">    complete(movies)</div><div class="line"> </div><div class="line">  &#125;.resume()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码片断使用默认的NSURLSession单例来获取电影列表。在你将响应数据传递给JavaScript代码之前，你需要提供一个执行上下文给响应数据。首先，在MovieService.swift文件顶部，在<code>import UIKit</code>下方添加下面这行代码来导入JavaScriptCore：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> JavaScriptCore</div></pre></td></tr></table></figure>
<p>然后在MovieService中定义如下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> context: <span class="type">JSContext</span>? = &#123;</div><div class="line">  <span class="keyword">let</span> context = <span class="type">JSContext</span>()</div><div class="line"> </div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">      commonJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"common"</span>, ofType: <span class="string">"js"</span>) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Unable to read resource files."</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> common = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: commonJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    context.evaluateScript(common)</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Error while processing script file: <span class="subst">\(error)</span>"</span>)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> context</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>这段代码将上下文定义为一个懒加载的JSContext属性：</p>
<ol>
<li>首先，你从应用的bundle中加载common.js文件，这个文件中包含你要访问的JavaScript代码。</li>
<li>在加载文件后，上下文对象将调用<code>context.evaluateScript()</code>，并将文件内容作为其参数，以此来执行js代码。</li>
</ol>
<p>现在可以调用Javascript方法了。仍然是在MovieService.swift文件中，找到<code>parseResponse(_:withLimit:)</code>方法，添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResponse</span><span class="params">(response: String, withLimit limit: Double)</span></span> -&gt; [<span class="type">Movie</span>] &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> context = context <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"JSContext not found."</span>)</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">let</span> parseFunction = context.objectForKeyedSubscript(<span class="string">"parseJson"</span>)</div><div class="line">  <span class="keyword">let</span> parsed = parseFunction.callWithArguments([response]).toArray()</div><div class="line"> </div><div class="line">  <span class="comment">// 3</span></div><div class="line">  <span class="keyword">let</span> filterFunction = context.objectForKeyedSubscript(<span class="string">"filterByLimit"</span>)</div><div class="line">  <span class="keyword">let</span> filtered = filterFunction.callWithArguments([parsed, limit]).toArray()</div><div class="line"> </div><div class="line">  <span class="comment">// 4</span></div><div class="line">  <span class="keyword">return</span> []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一步一步来看看这个流程：</p>
<ol>
<li>首先，确保上下文对象被正确的初始化。如果在设置的时候有任何错误(如：common.js文件不在bundle中)，则返回空数组。</li>
<li>在上下文对象中查询<code>parseJSON()</code>方法。正如上面所提到的，查询的结果将被封装在一个JSValue对象中。接着，使用<code>callWithArguments(_:)</code>来调用方法，并将一个数组作为参数。最后，将返回的JavaScript值转换为一个数组。</li>
<li><code>filterByLimit()</code>返回匹配给定价格限制的电影列表。</li>
<li>现在你已经获取到了电影列表，但仍然忘了一点：<code>filtered</code>常量持有一个JSValue数组，你需要将其映射为本地Movie类型。</li>
</ol>
<blockquote>
<p>注：你可以发现<code>objectForKeyedSubscript()</code>方法的使用有点怪怪的。不幸的是，Swift只能用这种原始的下标方法，而不能将其转换成合适的下标方法。而Objective-C可以使用方括号的下标语法。</p>
</blockquote>
<h2 id="暴露本地代码"><a href="#暴露本地代码" class="headerlink" title="暴露本地代码"></a>暴露本地代码</h2><p>在JavaScript运行时运行本地代码的一种方式是使用block；它们会被自动桥接到JavaScript方法。这里有个小问题：这个方法只适用于Objective-C的block，而不适用于Swift的闭包。为了暴露一个闭包，你必须执行两个任务：</p>
<ul>
<li>使用<code>@convention(block)</code>特性来修饰一个闭包，以将它桥接到一个Objective-C block。</li>
<li>在你可以将一个block映射到JavaScript方法调用前，你需要将其转换为一个AnyObject对象。</li>
</ul>
<p>切换到Movie.swift文件，并添加以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">let</span> movieBuilder: <span class="meta">@convention</span>(block) [[<span class="type">String</span> : <span class="type">String</span>]] -&gt; [<span class="type">Movie</span>] = &#123; object <span class="keyword">in</span></div><div class="line">  <span class="keyword">return</span> object.<span class="built_in">map</span> &#123; dict <span class="keyword">in</span></div><div class="line"> </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">        title = dict[<span class="string">"title"</span>],</div><div class="line">        price = dict[<span class="string">"price"</span>],</div><div class="line">        imageUrl = dict[<span class="string">"imageUrl"</span>] <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"unable to parse Movie objects."</span>)</div><div class="line">      <span class="built_in">fatalError</span>()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>(title: title, price: price, imageUrl: imageUrl)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个闭包维护一个JavaScript对象数组(元素为字典类型)，然后用它们构造Movie实例。</p>
<p>切换回MovieService.swift文件。在<code>parseResponse(_:withLimit:)</code>方法中，使用以下代码来替换的返回语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="keyword">let</span> builderBlock = <span class="built_in">unsafeBitCast</span>(<span class="type">Movie</span>.movieBuilder, <span class="type">AnyObject</span>.<span class="keyword">self</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 2</span></div><div class="line">context.setObject(builderBlock, forKeyedSubscript: <span class="string">"movieBuilder"</span>)</div><div class="line"><span class="keyword">let</span> builder = context.evaluateScript(<span class="string">"movieBuilder"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrappedFiltered = filtered,</div><div class="line">  <span class="keyword">let</span> movies = builder.callWithArguments([unwrappedFiltered]).toArray() <span class="keyword">as</span>? [<span class="type">Movie</span>] <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">print</span>(<span class="string">"Error while processing movies."</span>)</div><div class="line">  <span class="keyword">return</span> []</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> movies</div></pre></td></tr></table></figure>
<ol>
<li>你使用Swift的<code>unsafeBitCast(_:_:)</code>方法来将block转换成AnyObject。</li>
<li>在上下文中调用<code>setObject(_:forKeyedSubscript:)</code>，将block加载到JavaScript运行时。然后使用<code>evaluateScript()</code>方法获取JavaScript中block的一个引用。</li>
<li>最后一步是使用<code>callWithArguments(_:)</code>从JavaScript中调用你的block，这个方法传入一个JSValue对象的数组作为参数。返回值可以被转换成Movie对象的数组。</li>
</ol>
<p>最后来看看效果！编译并运行。在搜索框中输入一个价格，然后你可以看到将显示一些结果：</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2016/02/Simulator-Screen-Shot-19-Feb-2016-21.51.48-1-281x500.png" alt="image"></p>
<p>仅仅几行代码，你就构建了一个本地应用，并使用JavaScript来解析和过滤结果。</p>
<h2 id="使用JSExport协议"><a href="#使用JSExport协议" class="headerlink" title="使用JSExport协议"></a>使用JSExport协议</h2><p>在JavaScript使用自定义对象的另一种方式是JSExport协议。你必须创建一个继承自JSExport的协议，并声明想要暴露给Javascript的属性和方法。</p>
<p>对于你暴露的每一个本地类，JavaScriptCore都会在适当的JSContext实例中创建一个原型。JavaScriptCore框架这样做是基于这样一个选择基础：默认情况下，你的类的方法或属性自己并不会暴露给JavaScript。相反，你必须选择暴露谁。JSExport的规则如下：</p>
<ul>
<li>对于被暴露的实例方法，JavaScriptCore创建一个对应的JavaScript函数作为原型对象的属性。</li>
<li>类的属性将作为原型的访问器属性。</li>
<li>对于类方法，JavaScriptCore将在构造器对象中创建一个JavaScript方法。</li>
</ul>
<p>为了看看在实践中如何处理，我们切换到Movie.swift中，并在类声明前面定义如下一个新的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> JavaScriptCore</div><div class="line"> </div><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MovieJSExports</span>: <span class="title">JSExport</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> price: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> imageUrl: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">movieWithTitle</span><span class="params">(title: String, price: String, imageUrl: String)</span></span> -&gt; <span class="type">Movie</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，你指定所有想要暴露的属性并定义一个类方法来在Javascript中构造Movie对象。后者是必须的，因为JavaScriptCore不桥接初始化方法。</p>
<p>现在来修改Movie以实现JSExport协议。使用以下代码来替换整个类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">NSObject</span>, <span class="title">MovieJSExports</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> title: <span class="type">String</span></div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> price: <span class="type">String</span></div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> imageUrl: <span class="type">String</span></div><div class="line"> </div><div class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>, price: <span class="type">String</span>, imageUrl: <span class="type">String</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.title = title</div><div class="line">    <span class="keyword">self</span>.price = price</div><div class="line">    <span class="keyword">self</span>.imageUrl = imageUrl</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">movieWithTitle</span>(<span class="title">title</span>: <span class="title">String</span>, <span class="title">price</span>: <span class="title">String</span>, <span class="title">imageUrl</span>: <span class="title">String</span>) -&gt; <span class="title">Movie</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>(title: title, price: price, imageUrl: imageUrl)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类方法只是简单地调用适当的初始化方法。</p>
<p>现在你的类已准备好用于JavaScript了。为了了解你可以怎么转换当前的实现，从Resources group中打开additions.js。它已经包含了以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapToNative = function(movies) &#123;</div><div class="line">  <span class="keyword">return</span> movies.<span class="built_in">map</span>(function (movie) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>.movieWithTitlePriceImageUrl(movie.title, movie.price, movie.imageUrl);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的方法从输入数组中获取每一个元素，并使用它来构造一个Movie实例。唯一值得指出的是方法签名是如何改变的：因为JavaScript没有命名参数，所以使用驼峰命名法将额外的参数附加到方法名后面。</p>
<p>打开MovieService.swift，使用以下代码替换懒加载上下文属性的闭包实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> context: <span class="type">JSContext</span>? = &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> context = <span class="type">JSContext</span>()</div><div class="line"> </div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">      commonJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"common"</span>, ofType: <span class="string">"js"</span>),</div><div class="line">      additionsJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"additions"</span>, ofType: <span class="string">"js"</span>) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Unable to read resource files."</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> common = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: commonJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    <span class="keyword">let</span> additions = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: additionsJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line"> </div><div class="line">    context.setObject(<span class="type">Movie</span>.<span class="keyword">self</span>, forKeyedSubscript: <span class="string">"Movie"</span>)</div><div class="line">    context.evaluateScript(common)</div><div class="line">    context.evaluateScript(additions)</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Error while processing script file: <span class="subst">\(error)</span>"</span>)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> context</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>没有太大的改变。加载additions.js的内容到上下文。使用JSContext的<code>setObject(_:forKeyedSubscript:)</code>方法，你同样可以让Movie原型在上下文中可用。</p>
<p>还剩下最后一件事：在MovieService.swift中，使用以下代码来替换<code>parseResponse(_:withLimit:)</code>的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResponse</span><span class="params">(response: String, withLimit limit: Double)</span></span> -&gt; [<span class="type">Movie</span>] &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> context = context <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"JSContext not found."</span>)</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> parseFunction = context.objectForKeyedSubscript(<span class="string">"parseJson"</span>)</div><div class="line">  <span class="keyword">let</span> parsed = parseFunction.callWithArguments([response]).toArray()</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> filterFunction = context.objectForKeyedSubscript(<span class="string">"filterByLimit"</span>)</div><div class="line">  <span class="keyword">let</span> filtered = filterFunction.callWithArguments([parsed, limit]).toArray()</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> mapFunction = context.objectForKeyedSubscript(<span class="string">"mapToNative"</span>)</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrappedFiltered = filtered,</div><div class="line">    movies = mapFunction.callWithArguments([unwrappedFiltered]).toArray() <span class="keyword">as</span>? [<span class="type">Movie</span>] <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> movies</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码现在使用Javascript运行时的<code>mapToNative()</code>来创建Movie数组。如果现在编译并运行，你可以看到app仍然按预期的来运行：</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2016/01/4.jpg" alt="image"></p>
<p>恭喜你！不仅创建了一个浏览电影的很棒的App，同时也学会了通过重用完全由不同的语言实现的代码来创建它。</p>
<h2 id="下一步去哪里？"><a href="#下一步去哪里？" class="headerlink" title="下一步去哪里？"></a>下一步去哪里？</h2><p>你可以在<a href="https://developer.apple.com/videos/play/wwdc2013-615/" target="_blank" rel="external">这里</a>下载这篇教程完整的代码。</p>
<p>如果你想学习更多关于JavaScriptCore知识，可以看看WWDC 2013的<a href="https://developer.apple.com/videos/play/wwdc2013-615/" target="_blank" rel="external">Session 615</a></p>
<p>我希望你喜欢这篇JavaScriptCore教程。如果有任何问题或评论，可以参考到下面的讨论中来！</p>
<hr>
<p>欢迎关注我的微信公众号：iOS知识小集，扫扫左边<strong>站点概览</strong>里的二维码就OK了。对了，还有微博：<a href="http://weibo.com/touristdiary" target="_blank" rel="external">@南峰子_老驴</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/20/perfect-smooth-scrolling-in-uitableviews/" itemprop="url">
                  Perfect smooth scrolling in UITableViews
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-20T21:42:15+08:00" content="2015-12-20">
              2015-12-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文由<a href="https://medium.com/@plasm" target="_blank" rel="external">Alexander Orlov</a>发表于medium，地址为<a href="https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.so9tpnlk1" target="_blank" rel="external">https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.so9tpnlk1</a></p>
<p>这篇文章是前两周<a href="http://weibo.com/u/1438670852?from=usercardnew&amp;is_all=1" target="_blank" rel="external">@叶孤城</a> 叶大在微信群里面的分享，一直到这两天才翻出来研究。很多实用的东西，不过由于水平有限，有些地方没能翻译好，还请大家指正。</p>
</blockquote>
<p>我已经在iOS这个最好的移动平台上有几年的开发经验了。在这期间，我已以接触过很多的iOS应用和iOS工程师。</p>
<p>我们的世界很多好的开发者，但有时我发现他们中的一些人并不是很清楚如何充分利用这个最受欢迎的移动设备的整体潜力，来开发真正平滑的应用。</p>
<p>现在，我将尝试从我的视角，来说明一下为了让<code>UITableView</code>更快更平滑，工程师应该做哪些优化。</p>
<hr>
<p>文章越往后，难度和深度也会不断增加，所以我将以一些你熟悉的东西来开始。文章后面将会讨论iOS绘画系统和UIKit更深层次的一些东西。</p>
<h2 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h2><p>我相信大多数阅读这篇文章的人都知道这些方法，但一些人，即便是使用过这些方法，也没有以正确的姿式来使用它们。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>首先是重用<code>cell/header/footer</code>的单个实例，即便是我们需要显示多个。这是优化<code>UIScrollView</code>(<code>UITableView</code>的父类)最明显的方式，<code>UIScrollView</code>是由苹果的工程师提供的。为了正确的使用它，你应该只有<code>cell/header/footer</code>类，一次性初始化它们，并返回给<code>UITableView</code>。</p>
<p>在苹果的开发文档里面已经描述了重用<code>cell</code>的流程，在这就没有必须再重复了。</p>
<p>但重要的事情是：在<code>UITableView</code>的<code>dataSource</code>中实现的<code>tableView:cellForRowAtIndexPath:</code>方法，需要为每个<code>cell</code>调用一次，它应该快速执行。所以你需要尽可能快地返回重用<code>cell</code>实例。</p>
<blockquote>
<p>不要在这里去执行数据绑定，因为目前在屏幕上还没有<code>cell</code>。为了执行数据绑定，可以在<code>UITableView</code>的<code>delegate</code>方法<code>tableView:willDisplayCell:forRowAtIndexPath:</code>中进行。这个方法在显示<code>cell</code>之前会被调用。</p>
</blockquote>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>第二点也不难理解，但是有一件事需要解释一下。</p>
<p>这个方法对于<code>cell</code>定高的<code>UITableView</code>来说没有意义，但如果由于某些原因需要动态高度的<code>cell</code>的话，这个方法可以很容易地让滑动更流畅。</p>
<p>正如我们所知，<code>UITableView</code>是<code>UIScrollView</code>的子类，而<code>UIScrollView</code>的作用是让用户可以与比屏幕实际尺寸更大的区域交互。任何<code>UIScrollView</code>的实例都使用诸如<code>contentSize</code>、<code>contentOffset</code>和其它许多属性来将正确的区域显示给用户。</p>
<p>但是<code>UITableView</code>的问题在哪？正如所解释的一样，<code>UITableView</code>不会同时维护所有<code>cell</code>的实例。相反，它只需要维护显示给用户的那些<code>cell</code>。</p>
<p>那么，<code>UITableView</code>是如何知道它的<code>contentSize</code>呢？它是通过计算所以<code>cell</code>的高度之和来计算<code>contentSize</code>的值。</p>
<p><code>UITableView</code>的<code>delegate</code>方法<code>tableView:heightForRowAtIndexPath:</code>会为每个<code>cell</code>调用一次，所以你应该非常快地返回高度值。</p>
<p>很多人会犯一个错误，他们会在布局初始化<code>cell</code>实例并绑定数据后去获取它们的高度。如果你想优化滑动的性能，就不应该以这种方式来计算<code>cell</code>的高度，因为这事难以置信的低效，iOS设备标准的<code>60 FPS</code>将会降低到<code>15-20 FPS</code>，滑动会变得很慢。</p>
<p>如果我们没有一个<code>cell</code>的实例，那如何去计算它的高度呢？这里有一段示例代码，它使用类方法，并基于传入的宽度及显示的数据来计算高度值:</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%201.jpg?raw=true" alt="image"></p>
<p>可以用以下方式来使用上面这个方法返回高度值给<code>UITableView</code>:</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%202.jpg?raw=true" alt="image"></p>
<p>你在实现这一切的时候能获得了多少乐趣呢？大多数人会说没有。我没有保证过这事很容易。当然，我们可以构建我们自己的类来手动布局和计算高度，但有时候我们没有足够的时间来做这件事。你可以在<a href="https://telegram.org/apps" target="_blank" rel="external">Telegram</a>的iOS应用代码中找到这种实现的例子。</p>
<p>从iOS 8开始，我们可以在<code>UITableView</code>的<code>delegate</code>中使用自动高度计算，而不需要实现上面提到的方法。为了实现这一功能，你可能会使用<code>AutoLayout</code>，并将<code>rowHeight</code>变量设置为<code>UITableViewAutomaticDimension</code>。可以在<a href="http://stackoverflow.com/a/18746930" target="_blank" rel="external">StackOverflow</a>中找到更多详细的信息。</p>
<p>尽管可以使用这些方法，但我强烈建议不要使用它们。另外，我也不建议使用复杂的数学计算来获取<code>cell</code>的高度，如果可能，只使用加、减、乘、除就可以。</p>
<p>但如果是<code>AutoLayout</code>呢？它真的跟我所说的一样慢么？你可能会很惊讶，但这是事实。如果你想让你的App在所有设备上都能平滑的滚动，你就会发现这种方法难以置信的慢。你使用的子视图越多，<code>AutoLayout</code>的效率越低。</p>
<p><code>AutoLayout</code>相对低效的原因是隐藏在底层的命名为”<code>Cassowary</code>“的约束求解系统。如果布局中子视图越多，那么需要求解的约束也越多，进而返回<code>cell</code>给<code>UITableView</code>所花的时间也越多。</p>
<p>哪一个更快呢：使用少量的值来执行基本的数学计算，还是找一个求解大量线性等式或不等式的系统么？现在想像一下，用户想要快速地滑动，每个<code>cell</code>的自动布局也执行着疯狂的计算。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>使用内建方法优化<code>UITableView</code>的正确方法是：</p>
<ul>
<li>重用<code>cell</code>实例：对于特殊类型的<code>cell</code>，你应该只有一个实例，而没有更多。</li>
<li>不要在<code>cellForRowAtIndexPath:</code>方法中绑定数据，因为在此时<code>cell</code>还没有显示。可以使用<code>UITableView</code>的<code>delegate</code>中的<code>tableView:willDisplayCell:forRowAtIndexPath:</code>方法。</li>
<li>快速计算<code>cell</code>高度。对于工程师来说这是常规工作，但你将会为优化复杂<code>cell</code>的平滑滑动所付出的耐心而获取回报。</li>
</ul>
<h2 id="我们需要更深一步"><a href="#我们需要更深一步" class="headerlink" title="我们需要更深一步"></a>我们需要更深一步</h2><p>当然，上面提到的这些点不足以实现真正的平滑滚动，特别是当你需要实现一些复杂的<code>cell</code>(如有大量的渐变、视图、交互元素、一些修饰元素等等)时，这变得尤其明显。</p>
<p>这种情况下，<code>UITableView</code>很容易变得缓慢，即便是做了上面所有的事情。<code>UITableViewCell</code>中的视图越多，滑动时FPS越低。但在使用了手动布局和优化了高度计算后，问题就不在布局了，而在渲染了。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>让我们把关注点放在<code>UIView</code>的<code>opaque</code>属性上。文档中说它用于辅助绘图系统定义<code>UIView</code>是否透明。如果不透明，则绘图系统在渲染视图时可以做一些优化，以提高性能。</p>
<p>我们需要性能，或者不是？用户可能快速地滑动table，如使用<code>scrollsToTop</code>特性，但他们可能没有最新的<code>iPhone</code>，所以<code>cell</code>必须快速地被渲染。比通常的视图更快。</p>
<p>渲染最慢的操作之一是混合(<code>blending</code>)。混合操作由GPU来执行，因为这个硬件就是用来做混合操作的（当然不只是混合）。</p>
<p>你可能已经猜到，提高性能的方法是减少混合操作的次数。但在此之前，我们需要找到它。让我们来试试。</p>
<p>在iOS模拟器上运行App，在模拟器的菜单中选择’<code>Debug</code>‘，然后选中’<code>Color Blended Layers</code>‘。然后iOS模拟器就会将全部区域显示为两种颜色：绿色和红色。</p>
<p>绿色区域没有混合，但红色区域表示有混合操作。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%203.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%204.jpg?raw=true" alt="image"></p>
<p>正如你所看到的一样，在<code>cell</code>中至少有两处执行了混合操作，但你可能看不出差别来（这个混合操作是不必要的）。</p>
<p>每种情况都应该仔细研究，不同的情况需要使用不同的方法来避免混合。在我这里，我需要做的只是设置<code>backgroundColor</code>来实现非透明。</p>
<p>但有时候可能更复杂。看看这个：我们有一个渐变，但是没有混合。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%205.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%206.jpg?raw=true" alt="image"></p>
<p>如果想要使用<code>CAGradientLayer</code>来实现这个效果，你将会很失望：在iPhone 6中FPS将会降到<code>25-30</code>，快速滑动变得不可能。</p>
<p>这确实发生了，因为我们混合了两个不同层的内容：<code>UILabel</code>的<code>CATextLayer</code>和我们的<code>CAGradientLayer</code>。</p>
<p>如果能正确地利用了<code>CPU</code>和<code>GPU</code>资源，它们将会均匀地负载，FPS保持在<code>60</code>帧。看起来就像下面这样：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%207.jpg?raw=true" alt="image"></p>
<p>当设备需要执行很多混合操作时，问题就出现了：<code>GPU</code>是满载的，但<code>CPU</code>却保持低负载，而显得没有太大用处。</p>
<p>大多数工程师在2010年夏季末时都面临这个问题，当时发布了iPhone 4。Apple发布了革命性的<code>Retina</code>显示屏和…非常普通的<code>GPU</code>。然而，通常情况下它仍然有足够的能力，但上面描述的问题却变得越来越频繁。</p>
<p>你可以在当前运行iOS 7系统的iPhone 4上看到这一现象–所有的应用都变得很慢，即使是最简单的应用。不过，应用这篇文章中的介绍的方法，即使是在这种情况下，你的应用也能达到<code>60 FPS</code>，尽管会有些困难。</p>
<p>所以，需要怎么做呢？事实上，解决方案是：使用<code>CPU</code>来渲染！这将不会加载GPU，这样就无法执行混合操作。例如，在执行动画的<code>CALayer</code>上。</p>
<p>我们可以在<code>UIView</code>的<code>drawRect:</code>方法中使用<code>CoreGraphics</code>操作来执行<code>CPU</code>渲染，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%208.jpg?raw=true" alt="image"></p>
<p>这段代码nice么？我会告诉你并非如此。甚至通过这种方式，你会撤销在一些<code>UIView</code>上(在任何情况下，它们都是不必要的)的所有缓存优化操作。但是，这种方法禁用了一些混合操作，卸载<code>GPU</code>，从而使<code>UITableView</code>的更顺畅。</p>
<p>但是记住：这提高了渲染性能，不是因为<code>CPU</code>比<code>GPU</code>更快！它可以让我们通过为让<code>CPU</code>来执行某些渲染任务，从而卸载<code>GPU</code>，因为在很多情况下，<code>CPU</code>可能不是100%负载的。</p>
<p>优化混合操作的关键点是在平衡<code>CPU</code>和<code>GPU</code>的负载。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>优化<code>UITableView</code>中绘制数据操作的小结：</p>
<ul>
<li>减少iOS执行无用混合的区域：不要使用透明背景，使用iOS模拟器或者<code>Instruments</code>来确认这一点；如果可以，尽量使用没有混合的渐变。</li>
<li>优化代码，以平衡<code>CPU</code>和<code>GPU</code>的负载。你需要清楚地知道哪部分渲染需要使用<code>GPU</code>，哪部分可以使用<code>CPU</code>，以此保持平衡。</li>
<li>为特殊的<code>cell</code>类型编写特殊的代码。</li>
</ul>
<h2 id="像素获取"><a href="#像素获取" class="headerlink" title="像素获取"></a>像素获取</h2><p>你知道像素看起来是什么样的么？我的意思是，屏幕上的物理像素是什么样的？我肯定你知道，但我还是想让你看一下：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%209.jpeg?raw=true" alt="image"></p>
<p>不同的屏幕有不同的制作工艺，但有一件事是一样的。事实上，每个物理像素由三个颜色的子像素组成：红、绿、蓝。</p>
<p>基于这一事实，像素不是原子单位，虽然对于应用来说它是。或者仍然不是？</p>
<p>直到带有<code>Retina</code>屏的iPhone 4发布前，物理像素都可以用整型点坐标来描述。自从有了<code>Retina</code>屏后，在<code>Cocoa Touch</code>环境下，我们就可以用屏幕点来取代像素了，同时屏幕点可以是浮点值。</p>
<p>在完美的世界中(我们尝试构建的)，屏幕点总是被处理成物理像素的整型坐标。但在现实生活中它可能是浮点值，例如，线段可能起始于<code>x</code>为<code>0.25</code>的地方。这时候，iOS将执行子像素渲染。</p>
<p>这一技术在应用于特定类型的内容(如文本)时很有意义。但当我们绘制平滑直线时则没有必要。</p>
<p>如果所有的平滑线段都使用子像素渲染技术来渲染，那你会让iOS执行一些不必要的任务，从而降低FPS。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>什么情况下会出现这种不必要的子像素抗锯齿操作呢？最常发生的情况是通过代码计算而变成浮点值的视图坐标，或者是一些不正确的图片资源，这些图片的大小不是对齐到屏幕的物理像素上的（例如，你有一张在<code>Retina</code>显示屏上的大小为<code>60*61</code>的图片，而不是<code>60*60</code>的）。</p>
<p>在前面我们讲到，要解决问题，首先需要找到问题在哪。在iOS模拟器上运行程序，在”<code>Debug</code>“菜单中选中”<code>Color Misaligned Image</code>“。</p>
<p>这一次有两种高亮区域：品红色区域会执行子像素渲染，而黄色区域是图片大小没有对齐的情况。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2010.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2011.jpg?raw=true" alt="image"></p>
<p>那如何在代码中找到对应的位置呢？我总是使用手动布局，并且部分会自定义绘制，所以通常找到这些地方没有任何问题。如果你使用<code>Interface Builder</code>，那我对此深表同情。</p>
<p>通常，为了解决这个问题，你只要简单地使用<code>ceilf</code>, <code>floorf</code>和<code>CGRectIntegral</code>方法来对坐标做四舍五入处理。就是这样！</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>通过上面的讨论，我想建议你以下几点：</p>
<ul>
<li>对所有像素相关的数据做四舍五入处理，包括点坐标，<code>UIView</code>的高度和宽度。</li>
<li>跟踪你的图像资源：图片必须是像素完美的，否则在<code>Retina</code>屏幕上渲染时，它会做不必要的抗锯齿处理。</li>
<li>定期复查你的代码，因为这种情况可以会经常出现。</li>
</ul>
<h2 id="异步UI"><a href="#异步UI" class="headerlink" title="异步UI"></a>异步UI</h2><p>可能这看起来有点奇怪，但这是一种非常有效的方法。如果你知道如何做，那么可以让<code>UITableView</code>滑动得更平滑。</p>
<p>现在我们来讨论一下你应该做什么，然后再讨论下你是否可能这么做。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>每个中等以上规模的应用都可能会使用带有媒体内容的<code>cell</code>：文本、图片、动画，甚至还有视频。</p>
<p>而所有这些都可能带有装饰元素：圆角头像、还’#’号的文本、用户名等。</p>
<p>我们已经多次提及尽可能快地返回<code>cell</code>的需求，而在这里有一些麻烦：<code>clipsToBounds</code>很慢，图片需要从网络加载，需要在字符串中定位#号，和许多其它的问题。</p>
<p>优化的目标是很明确的：如果在主线程中执行这些操作，则会让你不能很快地返回<code>cell</code>。</p>
<p>在后台加载图片，在相同的地方处理圆角，然后将处理后的图片指定给<code>UIImageView</code>。</p>
<p>立刻显示文本，但在后台定位<code>#</code>号，然后使用属性字符串来刷新显示。</p>
<p>在你的<code>cell</code>中，需要具体情况具体分析，但主要的思想是在后台执行大的操作。这可能不止是网络代码，你需要使用<code>Instruments</code>来找到它们。</p>
<p>记住：需要尽快返回<code>cell</code>。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>有时候，上面的所有技术可能都帮不上忙。如<code>GPU</code>仍然不能使用(iPhone4+iOS7)时，<code>cell</code>中有很多内容时，需要<code>CALayer</code>的支持以实现动画时(因为在<code>drawRect:</code>中实现起来真的很麻烦)。</p>
<p>在这种情况下，我们需要在后台渲染所有其它东西。此外它能在用户快速滑动<code>UITableView</code>时有效地提高<code>FPS</code>。</p>
<p>我们来看看<code>Facebook</code>的应用。为了检测这些，你可能需要往下滑足够的高度，然后点击状态栏。列表会往上滑动，因此你可以清楚地看到此时没有渲染<code>cell</code>。如果想要更精确，则不能及时获得。</p>
<p>这很简单，所以你可以自己试试。这时，你需要设置<code>CALayer</code>的<code>drawsAsynchronously</code>属性为YES。</p>
<p>但是我们可以检查这些行为的必要性。在iOS模拟器上运行程序，然后选择“<code>Debug</code>”菜单中的”<code>Color Offscreen-Rendered</code>“。现在所有在后台渲染的区域都被高亮为黄色。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2012.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2013.jpg?raw=true" alt="image"></p>
<p>如果你为某些层开启了这一模式，但是它没有高亮显示，那么它就不够慢。</p>
<p>为了在<code>CALyaer</code>层找到瓶颈并进一步减少它，你可以使用<code>Instruments</code>里面的<code>Time Profiler</code>。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>这里是异步化UI的实现清单：</p>
<ul>
<li>找到让你的<code>cell</code>无法快速返回的瓶颈。</li>
<li>将操作移到后台线程，并在主线程刷新显示的内容。</li>
<li>最后一招是设置你的<code>CALayer</code>为异步显示模式(即使只是简单的文本或图片)–这将帮你提高FPS。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我尝试解释了iOS绘图系统(没有使用<code>OpenGL</code>，因为它的情况更少)的主要思路。当然有些看起来很模糊，但事实上这只是一些方向，你应该朝着这些方向来检查你的代码以找出影响滚动性能的所有问题。</p>
<p>具体情况具体分析，但原则是不变的。</p>
<p>获取完美平滑滚动的关键是非常特殊的代码，它能让你竭尽iOS的能力来让你的应用更加平滑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/13/cocoa-uikit-uicontrol/" itemprop="url">
                  UIKit: UIControl
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-13T11:16:26+08:00" content="2015-12-13">
              2015-12-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在开发应用的时候，经常会用到各种各样的控件，诸如按钮(<code>UIButton</code>)、滑块(<code>UISlider</code>)、分页控件(<code>UIPageControl</code>)等。这些控件用来与用户进行交互，响应用户的操作。我们查看这些类的继承体系，可以看到它们都是继承于<code>UIControl</code>类。<code>UIControl</code>是控件类的基类，它是一个抽象基类，我们不能直接使用<code>UIControl</code>类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。</p>
<p>本文将通过一个自定义的<code>UIControl</code>子类来看看<code>UIControl</code>的基本使用方法。不过在开始之前，让我们先来了解一下<code>Target-Action</code>机制。</p>
<h2 id="Target-Action机制"><a href="#Target-Action机制" class="headerlink" title="Target-Action机制"></a>Target-Action机制</h2><p><code>Target-action</code>是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapButton:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>也就是说，当按钮的点击事件发生时，会将消息发送到<code>target</code>(此处即为self对象)，并由<code>target</code>对象的<code>tapButton:</code>方法来处理相应的事件。其基本过程可以用下图来描述：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/Art/target_action.jpg" alt="image"></p>
<blockquote>
<p>注：图片来源于官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a></p>
</blockquote>
<p>即当事件发生时，事件会被发送到控件对象中，然后再由这个控件对象去触发<code>target</code>对象上的<code>action</code>行为，来最终处理事件。因此，<code>Target-Action</code>机制由两部分组成：即目标对象和行为<code>Selector</code>。目标对象指定最终处理事件的对象，而行为<code>Selector</code>则是处理事件的方法。</p>
<p>有关<code>Target-Action</code>机制的具体描述，大家可以参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a>。我们将会在下面讨论一些<code>Target-action</code>更深入的东西。</p>
<h2 id="实例：一个带Label的图片控件"><a href="#实例：一个带Label的图片控件" class="headerlink" title="实例：一个带Label的图片控件"></a>实例：一个带Label的图片控件</h2><p>回到我们的正题来，我们将实现一个带Label的图片控件。通常情况下，我们会基于以下两个原因来实现一个自定义的控件：</p>
<ul>
<li>对于特定的事件，我们需要观察或修改分发到<code>target</code>对象的行为消息。</li>
<li>提供自定义的跟踪行为。</li>
</ul>
<p>本例将会简单地结合这两者。先来看看效果：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example.png?raw=true" alt="image"></p>
<p>这个控件很简单，以图片为背景，然后在下方显示一个Label。</p>
<p>先创建<code>UIControl</code>的一个子类，我们需要传入一个字符串和一个UIImage对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageControl</span> : <span class="title">UIControl</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame title:(<span class="built_in">NSString</span> *)title image:(<span class="built_in">UIImage</span> *)image;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>基础的布局我们在此不讨论。我们先来看看<code>UIControl</code>为我们提供了哪些自定义跟踪行为的方法。</p>
<h3 id="跟踪触摸事件"><a href="#跟踪触摸事件" class="headerlink" title="跟踪触摸事件"></a>跟踪触摸事件</h3><p>如果是想提供自定义的跟踪行为，则可以重写以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)beginTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="built_in">BOOL</span>)continueTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)endTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)cancelTrackingWithEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。看起来是不是很熟悉？这跟<code>UIResponse</code>提供的四个事件跟踪方法是不是挺像的？我们来看看<code>UIResponse</code>的四个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>我们可以看到，上面两组方法的参数基本相同，只不过<code>UIControl</code>的是针对单点触摸，而<code>UIResponse</code>可能是多点触摸。另外，返回值也是大同小异。由于<code>UIControl</code>本身是视图，所以它实际上也继承了<code>UIResponse</code>的这四个方法。如果测试一下，我们会发现在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。</p>
<p>为了判断当前对象是否正在追踪触摸操作，<code>UIControl</code>定义了一个<code>tracking</code>属性。该值如果为YES，则表明正在追踪。这对于我们是更加方便了，不需要自己再去额外定义一个变量来做处理。</p>
<p>在测试中，我们可以发现当我们的触摸点沿着屏幕移出控件区域名，还是会继续追踪触摸操作，<code>cancelTrackingWithEvent:</code>消息并未被发送。为了判断当前触摸点是否在控件区域类，可以使用<code>touchInside</code>属性，这是个只读属性。不过实测的结果是，在控件区域周边一定范围内，该值还是会被标记为YES，即用于判定<code>touchInside</code>为YES的区域会比控件区域要大。</p>
<h3 id="观察或修改分发到target对象的行为消息"><a href="#观察或修改分发到target对象的行为消息" class="headerlink" title="观察或修改分发到target对象的行为消息"></a>观察或修改分发到target对象的行为消息</h3><p>对于一个给定的事件，<code>UIControl</code>会调用<code>sendAction:to:forEvent:</code>来将行为消息转发到<code>UIApplication</code>对象，再由<code>UIApplication</code>对象调用其<code>sendAction:to:fromSender:forEvent:</code>方法来将消息分发到指定的<code>target</code>上，而如果我们没有指定<code>target</code>，则会将事件分发到响应链上第一个想处理消息的对象上。而如果子类想监控或修改这种行为的话，则可以重写这个方法。</p>
<p>在我们的实例中，做了个小小的处理，将外部添加的<code>Target-Action</code>放在控件内部来处理事件，因此，我们的代码实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ImageControl.m</span></div><div class="line">- (<span class="keyword">void</span>)sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">	<span class="comment">// 将事件传递到对象本身来处理</span></div><div class="line">    [<span class="keyword">super</span> sendAction:<span class="keyword">@selector</span>(handleAction:) to:<span class="keyword">self</span> forEvent:event];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleAction:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle Action"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ViewController.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line"></div><div class="line">    ImageControl *control = [[ImageControl alloc] initWithFrame:(<span class="built_in">CGRect</span>)&#123;<span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">200.0</span>f, <span class="number">300.0</span>f&#125; title:<span class="string">@"This is a demo"</span> image:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"demo"</span>]];</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    [control addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapImageControl:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)tapImageControl:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sender = %@"</span>, sender);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们重写了<code>sendAction:to:forEvent:</code>方法，所以最后处理事件的<code>Selector</code>是<code>ImageControl</code>的<code>handleAction:</code>方法，而不是ViewController的<code>tapImageControl:</code>方法。</p>
<p>另外，<code>sendAction:to:forEvent:</code>实际上也被<code>UIControl</code>的另一个方法所调用，即<code>sendActionsForControlEvents:</code>。这个方法的作用是发送与指定类型相关的所有行为消息。我们可以在任意位置(包括控件内部和外部)调用控件的这个方法来发送参数<code>controlEvents</code>指定的消息。在我们的示例中，在ViewController.m中作了如下测试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    [control addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapImageControl:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"></div><div class="line">    [control sendActionsForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在未点击控件的情况下，触发了<code>UIControlEventTouchUpInside</code>事件，并打印了<code>handle Action</code>日志。</p>
<h2 id="Target-Action的管理"><a href="#Target-Action的管理" class="headerlink" title="Target-Action的管理"></a>Target-Action的管理</h2><p>为一个控件对象添加、删除<code>Target-Action</code>的操作我们都已经很熟悉了，主要使用的是以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加</span></div><div class="line">- (<span class="keyword">void</span>)addTarget:(<span class="keyword">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeTarget:(<span class="keyword">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents</div></pre></td></tr></table></figure>
<p>如果想获取控件对象所有相关的target对象，则可以调用<code>allTargets</code>方法，该方法返回一个集合。集合中可能包含<code>NSNull</code>对象，表示至少有一个nil目标对象。</p>
<p>而如果想获取某个target对象及事件相关的所有action，则可以调用<code>actionsForTarget:forControlEvent:</code>方法。</p>
<p>不过，这些都是<code>UIControl</code>开放出来的接口。我们还是想要探究一下，<code>UIControl</code>是如何去管理<code>Target-Action</code>的呢？</p>
<p>实际上，我们在程序某个合适的位置打个断点来观察<code>UIControl</code>的内部结构，可以看到这样的结果：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/UIControl%20Example%202.png" alt="image"></p>
<p>因此，<code>UIControl</code>内部实际上是有一个可变数组(<code>_targetActions</code>)来保存<code>Target-Action</code>，数组中的每个元素是一个<code>UIControlTargetAction</code>对象。<code>UIControlTargetAction</code>类是一个私有类，我们可以在<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControlTargetAction.h" target="_blank" rel="external">iOS-Runtime-Header</a>中找到它的头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIControlTargetAction</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    SEL _action;</div><div class="line">    <span class="built_in">BOOL</span> _cancelled;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _eventMask;</div><div class="line">    <span class="keyword">id</span> _target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cancelled;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>).cxx_destruct;</div><div class="line">- (<span class="built_in">BOOL</span>)cancelled;</div><div class="line">- (<span class="keyword">void</span>)setCancelled:(<span class="built_in">BOOL</span>)arg1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到<code>UIControlTargetAction</code>对象维护了一个<code>Target-Action</code>所必须的三要素，即<code>target</code>，<code>action</code>及对应的事件<code>eventMask</code>。</p>
<p>如果仔细想想，会发现一个有意思的问题。我们来看看实例中ViewController(target)与ImageControl实例(control)的引用关系，如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%203.png?raw=true" alt="image"></p>
<p>嗯，循环引用。</p>
<p>既然这样，就必须想办法打破这种循环引用。那么在这5个环节中，哪个地方最适合做这件事呢？仔细思考一样，1、2、4肯定是不行的，3也不太合适，那就只有5了。在上面的<code>UIControlTargetAction</code>头文件中，并没有办法看出<code>_target</code>是以<code>weak</code>方式声明的，那有证据么？</p>
<p>我们在工程中打个<code>Symbolic</code>断点，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%205.png?raw=true" alt="image"></p>
<p>运行程序，程序会进入<code>[UIControl addTarget:action:forControlEvents:]</code>方法的汇编代码页，在这里，我们可以找到一些蛛丝马迹。如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%204.png?raw=true" alt="image"></p>
<p>可以看到，对于<code>_target</code>成员变量，在<code>UIControlTargetAction</code>的初始化方法中调用了<code>objc_storeWeak</code>，即这个成员变量对外部传进来的<code>target</code>对象是以<code>weak</code>的方式引用的。</p>
<p>其实在<code>UIControl</code>的文档中，<code>addTarget:action:forControlEvents:</code>方法的说明还有这么一句：</p>
<blockquote>
<p>When you call this method, target is not retained.</p>
</blockquote>
<p>另外，如果我们以同一组target-action和event多次调用<code>addTarget:action:forControlEvents:</code>方法，在<code>_targetActions</code>中并不会重复添加<code>UIControlTargetAction</code>对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>控件是我们在开发中常用的视图工具，能很好的表达用户的意图。我们可以使用UIKit提供的控件，也可以自定义控件。当然，<code>UIControl</code>除了上述的一些方法，还有一些属性和方法，以及一些常量，大家可以参考文档。</p>
<p>示例工程的代码已上传到github，可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIView/2.%20UIControlExample" target="_blank" rel="external">这里</a>下载。另外，推荐一下<a href="https://github.com/samvermette/SVSegmentedControl" target="_blank" rel="external">SVSegmentedControl</a>这个控件，大家可以研究下它的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class" target="_blank" rel="external">UIControl Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/UIKitUICatalog/UIControl.html#//apple_ref/doc/uid/TP40012857-UIControl" target="_blank" rel="external">UIKit User Interface Catalog - About Controls</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a></li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControlTargetAction.h" target="_blank" rel="external">iOS-Runtime-Header: UIControlTargetAction</a></li>
<li><a href="https://github.com/samvermette/SVSegmentedControl" target="_blank" rel="external">SVSegmentedControl</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/22/cocoa-uikit-uiimage/" itemprop="url">
                  UIKit: UIImage
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-22T09:20:56+08:00" content="2015-11-22">
              2015-11-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>UIImage</code>对象是iOS中用来显示图像数据的高级接口。我们可以从文件，<code>NSData</code>，<code>Quartz</code>图片对象中创建<code>UIImage</code>对象。可以说这个类是我们接触频率非常高的一个类。</p>
<h2 id="UIImage的不可变性"><a href="#UIImage的不可变性" class="headerlink" title="UIImage的不可变性"></a>UIImage的不可变性</h2><p><code>UIImage</code>对象是不可变的，所以一旦创建后，我们就不能再改变它的属性。这也就意味着，我们只能在初始化方法中提供属性值或依赖于图片自身的属性值。同样，由于其不可变，所以在任何线程中都可以安全地使用它。</p>
<p>如果我们想修改<code>UIImage</code>对象的一些属性，则可以使用便捷方法和自定义的参数值来创建图像的一份拷贝。</p>
<p>另外，由于<code>UIImage</code>对象是不可变的，所以它没有提供访问底层图片数据的方法。不过我们可以使用<code>UIImagePNGRepresentation</code>或<code>UIImageJPEGRepresentation</code>方法来获取包含PNG或JPG格式的数据的<code>NSData</code>对象。如下代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"swift"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> imageData:<span class="type">NSData</span>? = <span class="type">UIImageJPEGRepresentation</span>(image!, <span class="number">1.0</span>)</div></pre></td></tr></table></figure>
<h2 id="创建UIImage对象"><a href="#创建UIImage对象" class="headerlink" title="创建UIImage对象"></a>创建UIImage对象</h2><p>对于一个UIImage对象来说，它的数据源主要有以下几种：</p>
<ol>
<li>文件：我们可以使用<code>init(contentsOfFile:)</code>方法来从指定文件中创建对象。</li>
<li>纯图片数据(<code>NSData</code>)：如果在内存中有图片的原始数据(表示为<code>NSData</code>对象)，则可以使用<code>init(data:)</code>来创建。需要注意的是这个方法会对象图片数据做缓存。</li>
<li><code>CGImage</code>对象：如果我们有一个<code>CGImage</code>对象，则可以使用<code>init(CGImage:)</code>或<code>init(CGImage:scale:orientation:)</code>创建<code>UIImage</code>对象。</li>
<li><code>CIImage</code>对象：如果我们有一个<code>CIImage</code>对象，则可以使用<code>init(CIImage:)</code>或<code>init(CIImage:scale:orientation:)</code>创建<code>UIImage</code>对象。</li>
</ol>
<p>需要注意的是，如果是从文件或者纯图片数据中创建<code>UIImage</code>对象，则要求对应的图片格式是系统支持的图片类型。</p>
<p>对于<code>Objective-C</code>来说，<code>UIImage</code>对象也提供了这些初始化方法对应的便捷类方法来创建对象。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在实际的应用中，特别是图片类应用中，我们可能需要使用大量的图片。我们都知道，图片通常都是非常占内存的。如果同一时间加载大量的图片，就可能占用大量的系统内存。</p>
<p>为此，Apple采用了一种比较巧妙的策略。在低内存的情况下，系统会强制清除<code>UIImage</code>对象所指向的图片数据，以释放部分内存。注意，这种清除行为影响到的只是图片数据，而不会影响到<code>UIImage</code>对象本身。当我们需要绘制那些图片数据已经被清除的<code>UIImage</code>对象时，对象会自动从源文件中重新加载数据。当然，这是以时间换空间的一种策略，会导致一定的性能损耗。</p>
<p>说到这里，我们不得不提一下<code>init(named:)</code>方法了。可以说我们平时创建<code>UIImage</code>对象用得最多的应该就是这个方法。这个方法主要是使用<code>bundle</code>中的文件创建图片的快捷方式。关于这个方法，有几点需要注意：</p>
<ol>
<li><strong>缓存</strong>：这个方法会首先去系统缓存中查找是否有图片名对应的图片。如果有就返回缓存中的图片；如果没有，则该方法从磁盘或者<code>asset catalog</code>中加载图片并返回，同时将图片缓存到系统中。缓存的图片只有在收到内存警告时才会释放。因此，如果图片的使用频率比较低，则可以考虑使用<code>imageWithContentsOfFile:</code>方法来加载图片，这样可以减少内存资源的消耗。当然，这需要权衡考虑，毕竟读写磁盘也是有性能消耗的，而且现在的高端机内存已经不小了。</li>
<li><strong>多分辨率图片处理</strong>：在iOS 4.0后，该方法会根据屏幕的分辨率来查找对应尺寸的图片。即我们使用时，只需要写图片名，而不需要指定是1x, 2x还是3x图，该方法会自己判断。</li>
<li><strong>png图片后缀</strong>：在iOS 4.0以后，如果图片是png格式的，则图片文件名不需要附带扩展名。</li>
<li><strong>线程安全性</strong>：该方法在iOS 9.0之前并不是线程安全的，在二级线程中调用可能会导致崩溃。在iOS 9.0之后，Apple作了优化处理，将其改为线程安全的方法。为了避免不必要的麻烦，尽量在主线程中调用这个方法。</li>
</ol>
<h2 id="图片拉伸"><a href="#图片拉伸" class="headerlink" title="图片拉伸"></a>图片拉伸</h2><p>当我们的图片比所要填充的区域小时，会导致图片变形。如以下图片，原始大小为100*30，将其放到一个300*50的<code>UIImageView</code>中时，整个图片被拉伸。</p>
<p><strong>原始图片</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage.png?raw=true" alt="image"></p>
<p><strong>拉伸后的图片</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage_Deform.png?raw=true" alt="image"></p>
<p>这时我们就需要做特殊的处理。</p>
<p><code>Android</code>的同学应该都知道.9图，这种图片可以只拉伸中间的部分，而保持四个角不变形。在iOS中也支持这种操作。在早期的iOS版本中，<code>UIImage</code>提供了如下方法来执行此操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stretchableImageWithLeftCapWidth</span><span class="params">(<span class="number">_</span> leftCapWidth: Int, topCapHeight topCapHeight: Int)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法通过<code>leftCapWidth</code>和<code>topCapHeight</code>两个参数来定义四个角的大小。不过这个方法在iOS 5中就被<code>Deprecated</code>了，对应的两个属性<code>leftCapWidth</code>和<code>topCapHeight</code>也是相同的命运。所以现在不建议使用它们。另外，对于如何解释<code>leftCapWidth</code>和<code>topCapHeight</code>，大家可以参考一下<a href="http://weibo.com/exceptions" target="_blank" rel="external">@M了个J</a>的<a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a>。</p>
<p>在iOS 5中，我们可以使用以下方法来执行相同的操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizableImageWithCapInsets</span><span class="params">(<span class="number">_</span> capInsets: UIEdgeInsets)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法通过一个<code>UIEdgeInsets</code>来指定上下左右不变形的宽度或高度。它会返回一个新的图像。而如果图像被拉伸，则会以平铺的方式来处理中间的拉伸区域。</p>
<p>我们对上面的图片做如下处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> resizedButtonImageView = <span class="type">UIImageView</span>(image: normalButtonImage?.resizableImageWithCapInsets(<span class="type">UIEdgeInsets</span>(top: <span class="number">15</span>, <span class="keyword">left</span>: <span class="number">15</span>, bottom: <span class="number">15</span>, <span class="keyword">right</span>: <span class="number">15</span>)))</div><div class="line">resizedButtonImageView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">300</span>, <span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>其得到的结果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage_Resized.png?raw=true" alt="image"></p>
<p>在iOS 6，<code>Apple</code>又为我们提供了一个新的方法，相较于上面这个方法，只是多一个<code>resizingMode</code>参数，允许我们指定拉伸模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizableImageWithCapInsets</span><span class="params">(<span class="number">_</span> capInsets: UIEdgeInsets, resizingMode resizingMode: UIImageResizingMode)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法的拉伸模式分两种：平铺(<code>Tile</code>)和拉伸(<code>Stretch</code>)。如果是平铺模式，则跟前一个方法是一样的效果。</p>
<h2 id="动效图片对象"><a href="#动效图片对象" class="headerlink" title="动效图片对象"></a>动效图片对象</h2><p>如果我们有一组大小和缩放因子相同的图片，就可以将这些图片加载到同一个<code>UIImage</code>对象中，形成一个动态的<code>UIImage</code>对象。为此，<code>UIImage</code>提供了以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div></pre></td></tr></table></figure>
<p>这个方法会加载以name为基准文件名的一系列文件。如，假设我们的<code>name</code>参数值为”swift”，则这个方法会加载诸如”swift0”, “swift1”,…, “swift1024”这样的一系列的文件。</p>
<p>这里有两个问题需要注意：</p>
<ol>
<li>文件的序号必须是从0开始的连续数字，如果不从0开始，则在<code>Playground</code>中是会报错的。而如果中间序号有断，而中断后的图片是不会被加载的。</li>
<li>所有文件的大小和缩放因子应该是相同的，否则显示时会有不可预期的结果，这种结果主要表现为播放的顺序可能是杂乱的。</li>
</ol>
<p>如果我们有一组基准文件名不同的文件，但其大小和缩放因子相同，则可能使用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedImageWithImages</span>(<span class="title">_</span> <span class="title">images</span>: [<span class="title">UIImage</span>], <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div></pre></td></tr></table></figure>
<p>传入一个<code>UIImage</code>数组来拼装一个动效<code>UIImage</code>对象。</p>
<p>另外，<code>UIImage</code>也提供了<code>resizable</code>版本的动效方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedResizableImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">capInsets</span> <span class="title">capInsets</span>: <span class="title">UIEdgeInsets</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div><div class="line"></div><div class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">animatedResizableImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">capInsets</span> <span class="title">capInsets</span>: <span class="title">UIEdgeInsets</span>, <span class="title">resizingMode</span> <span class="title">resizingMode</span>: <span class="title">UIImageResizingMode</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</div></pre></td></tr></table></figure>
<p>第一个方法的<code>UIImageResizingMode</code>默认是<code>UIImageResizingModeTile</code>，所以如果想对图片做拉伸处理，可以使用第二个的方法，并传入<code>UIImageResizingModeStretch</code>。</p>
<h2 id="图片大小的限制"><a href="#图片大小的限制" class="headerlink" title="图片大小的限制"></a>图片大小的限制</h2><p><code>UIImage</code>对象使用的图片大小尽量小于1024*1024。因为这么大的图片消耗的内存过大，在将其作为<code>OpenGL</code>中的贴图或者是绘制到<code>view/layer</code>中时，可以会出现问题。如果仅仅是代码层面的操作的话，则没有这个限制。比如，将一个大于1024*1024的图片绘制到位图图形上下文中以重新设定其大小。事实上，我们需要通过这种操作来改变图片大小，以将其绘制到视图中。</p>
<h2 id="支持的图片格式"><a href="#支持的图片格式" class="headerlink" title="支持的图片格式"></a>支持的图片格式</h2><p><code>UIImage</code>支持的图片格式在<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIImage_Class" target="_blank" rel="external">UIImage Class Reference</a>中列出来了，大家可以直接参考。</p>
<p>需要注意的一点是<code>RGB-565</code>格式的BMP文件在加载时会被转换成<code>ARGB-1555</code>格式。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>本文的示例代码已上传到github，可点击<a href="https://github.com/southpeak/Swift/tree/master/UIKit/UIImage.playground" target="_blank" rel="external">这里</a>查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIImage_Class" target="_blank" rel="external">UIImage Class Reference</a></li>
<li><a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a></li>
<li><a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/" target="_blank" rel="external">iOS 处理图片的一些小 Tip</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/05/secret-of-swift-performance-part-2/" itemprop="url">
                  Secret of Swift Performance Part 2 - Look under the hood
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-05T22:56:20+08:00" content="2015-11-05">
              2015-11-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Kostiantyn Koval</code>发表于<code>Medium</code>，地址为<a href="https://medium.com/swift-programming/secret-of-swift-performance-fcc5d2a437a8" target="_blank" rel="external">Secret of Swift Performance ：Part 2 - Look under the hood</a>。</p>
<p>当想要分析一个<code>App</code>的性能时，<code>Instruments</code>和<code>Measure</code>绝对是我们最好的朋友。我希望每个人都了解<code>Instruments</code>并至少使用过一次。<code>Instruments</code>提供了许多非常有用的工具，来告诉我们：“我们的<code>App</code>使用了多少内存”，“<code>App</code>有多快”，“有没有内存泄漏”等等。</p>
<p>但作为一个软件攻城狮，我们同样需要知道“为什么…？”，“为什么它发生了？”</p>
<p>在我使用<code>Swift</code>时，我曾经看到一些我当时无法理解但很有意思的东西。“为什么这段代码运行这么快？”为了回答这个问题，我必须查看编译出来的汇编代码。这其实并不难，而且非常有用。接下来就来看看是如何做的。</p>
<h2 id="编译Swift代码"><a href="#编译Swift代码" class="headerlink" title="编译Swift代码"></a>编译Swift代码</h2><p>我们只是想编译并分析部分代码，而不是整个工程。为此我们需要做几件事：</p>
<ul>
<li>创建一个新的<code>Swift</code>文件。</li>
<li>创建一个简单的测试函数<code>func test() { ... // 具体代码 }</code>。</li>
<li>将需要编译和分析的代码拷贝到函数体中。</li>
<li>调用函数。</li>
</ul>
<p>这里我们做的是定义一个测试函数，函数体是我们想要检查和分析的代码。当然，我们需要在顶层调用这个函数。</p>
<p>现在我们需要编译这个文件。可以借助于<code>xcrun</code>(Xcode工具)和<code>swiftc</code>(Swift编译器命令行工具)。</p>
<ul>
<li>打开终端并通过<code>cd</code>命令切换到<code>Swift</code>文件所在的目录。</li>
<li>运行命令”<code>xcrun swiftc -Onone inputFile.swift -o resultFileName</code>“。如<strong>xcrun swiftc -Onone Assembly.swift -o result</strong>。</li>
</ul>
<p>这个命令将会编译我们的<code>Swift</code>文件。</p>
<p>我们可以使用<code>xcrun swiftc -help</code>命令来查看<code>xcrun swiftc</code>命令的帮助文档。当前我们最感兴趣的是一些优化选项：</p>
<ul>
<li><strong>-O</strong>：编译时优化</li>
<li><strong>-Onone</strong>：编译时不做任何优化</li>
<li><strong>-Ounchecked</strong>：编译时优化并移除运行时安全检查</li>
</ul>
<p>使用<strong>-O</strong>选项很重要。它就跟编译<code>App</code>时使用<code>Release</code>模式一样。通常用来分析要上传到<code>AppStore</code>上的代码。</p>
<p>作为测试，我们使用<strong>-Onone</strong>模式，因为它生成的汇编代码非常类似于我们的源代码。也可以分别生成两种模式下的代码来做比较。这样我们可以学习下<code>Swift</code>编译器是如何做优化的。</p>
<p>运行：<strong>xcrun swiftc -Onone Assembly.swift -o none</strong></p>
<p>会生成一个可执行文件，可以双击运行它。</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*LLrYPKt2oVbzU5CcOrixdQ.png" alt="image"></p>
<p>当编译一个<code>Swift</code>文件时，<code>Swift</code>编译器做了以下几件事：</p>
<ul>
<li>创建一个带有<strong>int main(int arg0, int arg1)</strong>函数的控制台应用。这是应用的起点。</li>
<li>创建<strong>_top_level_code</strong>函数。该函数的函数体是<code>Swift</code>文件的顶层可执行代码。在我们的示例中就是调用了<code>test()</code>函数。</li>
</ul>
<h2 id="获取汇编代码"><a href="#获取汇编代码" class="headerlink" title="获取汇编代码"></a>获取汇编代码</h2><p>有许多办法来获取汇编代码。我建议使用<code>Hopper</code>。可以在<a href="http://www.hopperapp.com/download.html" target="_blank" rel="external">这里</a>下载并使用<code>Demo</code>模式。使用<code>Hopper</code>最棒的是它可以显示汇编的伪代码，使用起来比较方便。</p>
<p>让我们来获取汇编代码：</p>
<ul>
<li>打开<code>Hopper</code> &gt; <code>File</code> &gt; <code>Read Executable to Disassemble</code>，选择可执行文件，点击OK</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/600/1*CcC_vQGU8CWz1qkshLNDWQ.png" alt="image"></p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*oEF3HyJj3t0pKWUwMyft7w.png" alt="image"></p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*Zv5uaktNpsTZ9f5KE7xqeg.png" alt="image"></p>
<h2 id="Hopper概述"><a href="#Hopper概述" class="headerlink" title="Hopper概述"></a>Hopper概述</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*DiIcK4QP2UQ2glHxwgW4rQ.png" alt="image"></p>
<p><code>Hopper</code>的界面类似于<code>Xcode</code>，左侧是导航面板，中间是编辑面板，右侧是帮助和<code>Inspector</code>面板。</p>
<p><strong>左侧面板</strong>—在这里可以找到所有函数，串标记和字符串，可以点击它们导航到对应的汇编代码。</p>
<p><strong>编辑区</strong>— 显示汇编代码，它类似于<code>Xcode</code>的<code>Swift</code>或其它。我们可以使用箭头来导航。</p>
<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>首先我们需要找到应用入口，在我们的示例中是<code>_main</code>函数。在左侧导航面板中选择它。下面是<code>_main</code>函数的汇编代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*uzIzPacXGRgXGa_tVi9wlw.png" alt="image"></p>
<p>汇编代码很难分析，不过<code>Hopper</code>可以生成伪代码。使用快捷键”<code>Alt+Enter</code>“或者”<code>Window</code> &gt; <code>Show Pseudo Code of Procedure</code>“。现在可以看到<code>_main</code>函数的伪代码了。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*Sm4MRfqUCjjf3DCB3udDLA.png" alt="image"></p>
<p>这样好多了!!</p>
<p>前4行是提取<code>_main</code>函数的参数，我们对此不感兴趣。然后调用了<strong>_top_level_code()</strong>，正如前面提到的，这应该就是我们的代码。让我们来看看。关闭伪代码视图，选择<strong>_top_level_code</strong>函数并显示其伪代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*ev3n_N8Ai6NCN6tJeFLCVg.png" alt="image"></p>
<p>它只调用了<strong>__TF4none4testFT_T_()_</strong>函数。</p>
<p><code>Swift</code>生成的函数有特定的命名规范。即模块名+函数名+字符数+参数类型+其它东西。<a href="https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html" target="_blank" rel="external">Mike Ash</a>详细介绍了这一规范。</p>
<p>这里可以看到的是<strong>none</strong>(文件名)， <strong>test</strong>(函数名)。基于这一点，我们可以说它就是<code>test()</code>函数。让我们来检查一下。查找<code>__TF4none4testFT_T_</code>并显示其伪代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*e5LfhINe2u_73NBzP8aNNQ.png" alt="image"></p>
<p>它有3个变量，是16进制格式的，转换一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var_8 = <span class="number">10</span>,</div><div class="line">var_10 = <span class="number">10</span>,</div><div class="line">var_18 = <span class="number">20</span></div></pre></td></tr></table></figure>
<p>这和我们的源代码非常相似，但源代码有一个相加操作，<code>Swift</code>在编译期直接计算出结果了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> y = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">c</span> = x + y</div></pre></td></tr></table></figure>
<p>现在你已经知道了：编译<code>Swift</code>代码，反汇编及分析汇编代码。深入后，你可以学习并发现许多有趣的东西。作为比较，我们现在使用<strong>-O</strong>模式来编译下代码，以看看<code>Swift</code>编译器是如何优化代码的。</p>
<p>运行<strong>xcrun swiftc -O Assembly.swift -o optimized</strong>命令。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*zZTA8GKacYtlFL5QgPaHtg.png" alt="image"></p>
<p>正如你所见的，在主函数中没有调用任何函数。没有<strong>_top_level_code</strong>。没有调用<code>test()</code>函数。</p>
<p><code>Swift</code>编译器检测到<code>test</code>函数的结果没有被使用，所以将其忽略。而<strong>_top_level_code</strong>也只调用了一个<code>test()</code>函数，所以也被忽略了。结果是我们获得了一个空的主函数。</p>
<p>这篇文章描述了如何使用工具来分析代码。我发现了许多用这些工具优化<code>Swift</code>的方法，这些方法非常有意思。我将在第三部分中与你们分享，敬请期待……</p>
<p><em>注：强烈建议手动操作一下，看看自己得到的结果是什么。</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/05/secret-of-swift-performance-part-1/" itemprop="url">
                  Secret of Swift Performance Part 1 - Measure
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-05T22:54:01+08:00" content="2015-11-05">
              2015-11-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Kostiantyn Koval</code>发表于<code>Medium</code>，地址为<a href="https://medium.com/swift-programming/secret-of-swift-performance-a8ee86060843" target="_blank" rel="external">Secret of Swift Performance ：Part 1 — Measure</a></p>
<p><code>Swift</code>性能方面的讨论已经很多了。如：它真的比<code>C</code>快么？它怎样才能更快？ 去<code>Google</code>一下吧。</p>
<p>但是作为一个<code>App</code>开发者，我们需要知道如何以更简单的方式让我们的<code>App</code>更快。那加速<code>App</code>的银弹又是什么呢？</p>
<h2 id="找出性能瓶颈"><a href="#找出性能瓶颈" class="headerlink" title="找出性能瓶颈"></a>找出性能瓶颈</h2><p>找出<code>App</code>的性能瓶颈是很重要的。按照<code>80/20</code>的原则来说，“大约<code>20%</code>的代码占用了<code>80%</code>的运行速度”，这意味着我们需要找出这<code>20%</code>的代码并优化它，而不用关心剩余的<code>80%</code>。</p>
<p>我写了个简单的带有一个闭包参数的测试函数，它的主要功能是测试闭包代码的运行速度。让我们来分析一下这段代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(title: String!, call: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    call()</div><div class="line">    <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = title &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(title)</span>: "</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Time - <span class="subst">\(endTime - startTime)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个测试函数的参数有两个：辅助分析的可选名称(<code>title</code>)和类型为<code>()-&gt;()</code>的闭包函数。相当简单吧。它在调用<code>call()</code>的前后分别获取了当前时间，并打印出<code>call()</code>执行所花费的时间。</p>
<p>让我们来试一下吧。我有一个函数，它的职责是迭代一个数组，并加载图片。我想看看它需要花费多少时间。我们简单地包装一下这个代码块以方便测试函数调用。在这里我们使用了尾随闭包语义，看上去非常棒。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomeWork</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    measure(<span class="string">"Array"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> ar = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10000</span> &#123;</div><div class="line">            ar.append(<span class="string">"New elem <span class="subst">\(i)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    measure(<span class="string">"Image"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://lorempixel.com/1920/1920/"</span>)</div><div class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data:<span class="type">NSData</span>(contentsOfURL:url!)!)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>: <span class="type">Time</span> — <span class="number">0.0845723639995413</span></div><div class="line"><span class="type">Image</span>: <span class="type">Time</span> — <span class="number">1.77442857499955</span></div></pre></td></tr></table></figure>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*zCF2DX5VqNOmxgg8qs7z2w.png" alt="image"></p>
<p>现在你知道了哪块代码占用了更多时间，然后就需要去优化它或者将其移到二级线程中处理。</p>
<h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>应该总是在<code>Release</code>模式且<code>Optimization Level</code>设置为<code>[-Os]</code>或<code>[-Ofast]</code>的情况下去测试运行速度。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Ea6yWoxe99jG_-kSAVd8eA.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
