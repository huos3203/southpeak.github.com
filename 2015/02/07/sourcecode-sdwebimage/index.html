<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="源码来源：https://github.com/rs/SDWebImage
版本: 3.7
SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：

提供UIImageView的一个分类，以支持网络图片的加载与缓存管理
一个异步的图片加载器
一个异步的内存+磁盘图片缓存
支持GIF图片
支持WebP图片
后台图片">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage实现分析">
<meta property="og:url" content="http://southpeak.github.io/2015/02/07/sourcecode-sdwebimage/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta property="og:description" content="源码来源：https://github.com/rs/SDWebImage
版本: 3.7
SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：

提供UIImageView的一个分类，以支持网络图片的加载与缓存管理
一个异步的图片加载器
一个异步的内存+磁盘图片缓存
支持GIF图片
支持WebP图片
后台图片">
<meta property="og:updated_time" content="2016-08-28T03:33:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage实现分析">
<meta name="twitter:description" content="源码来源：https://github.com/rs/SDWebImage
版本: 3.7
SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：

提供UIImageView的一个分类，以支持网络图片的加载与缓存管理
一个异步的图片加载器
一个异步的内存+磁盘图片缓存
支持GIF图片
支持WebP图片
后台图片">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/2015/02/07/sourcecode-sdwebimage/"/>

  <title> SDWebImage实现分析 | 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SDWebImage实现分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T23:30:45+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>源码来源：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></p>
<p>版本: 3.7</p>
<p><code>SDWebImage</code>是一个开源的第三方库，它提供了<code>UIImageView</code>的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>
<ol>
<li>提供<code>UIImageView</code>的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持<code>GIF</code>图片</li>
<li>支持<code>WebP</code>图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个<code>URL</code>的图片不被下载多次</li>
<li>确保虚假的<code>URL</code>不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
</ol>
<p>从<code>github</code>上对<code>SDWebImage</code>使用情况就可以看出，<code>SDWebImage</code>在图片下载及缓存的处理方面还是很被认可的。在本文中，我们主要从源码的角度来分析一下<code>SDWebImage</code>的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对<code>GIF</code>图片及<code>WebP</code>图片的支持操作。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在<code>SDWebImage</code>中，图片的下载是由<code>SDWebImageDownloader</code>类来完成的。它是一个异步下载器，并对图像加载做了优化处理。下面我们就来看看它的具体实现。</p>
<h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同的操作。下载选项由枚举<code>SDWebImageDownloaderOptions</code>定义，具体如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache</span></div><div class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block</span></div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">	<span class="comment">// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消</span></div><div class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL证书。主要用于测试目的。</span></div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 将图片下载放到高优先级队列中</span></div><div class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、<code>cookie</code>处理以认证几个方面。</p>
<h3 id="下载顺序"><a href="#下载顺序" class="headerlink" title="下载顺序"></a>下载顺序</h3><p><code>SDWebImage</code>的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序</span></div><div class="line">    SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">    </div><div class="line">    <span class="comment">// 以栈的方式，按照后进先出的顺序下载。</span></div><div class="line">    SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h3><p><code>SDWebImageDownloader</code>下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个<code>NSOperationQueue</code>操作队列中来完成的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</div></pre></td></tr></table></figure>
<p>默认情况下，队列最大并发数是6。如果需要的话，我们可以通过<code>SDWebImageDownloader</code>类的<code>maxConcurrentDownloads</code>属性来修改。</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        ...</div><div class="line">        _barrierQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderBarrierQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以<code>block</code>形式来呈现，为此在<code>SDWebImageDownloader.h</code>中定义了几个<code>block</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下载进度</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderProgressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize);</div><div class="line"><span class="comment">// 下载完成</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderCompletedBlock)(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished);</div><div class="line"><span class="comment">// Header过滤</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> *(^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSDictionary</span> *headers);</div></pre></td></tr></table></figure>
<p>图片下载的这些回调信息存储在<code>SDWebImageDownloader</code>类的<code>URLCallbacks</code>属性中，该属性是一个字典，<code>key</code>是图片的<code>URL</code>地址，<code>value</code>则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作<code>URLCallbacks</code>属性。为了保证<code>URLCallbacks</code>操作(添加、删除)的线程安全性，<code>SDWebImageDownloader</code>将这些操作作为一个个任务放到<code>barrierQueue</code>队列中，并设置屏障来确保同一时间只有一个线程操作<code>URLCallbacks</code>属性，我们以添加操作为例，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    	    </div><div class="line">   	<span class="comment">// 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 处理同一URL的同步下载请求的单个下载</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">        [callbacksForURL addObject:callbacks];</div><div class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</div><div class="line">        </div><div class="line">        ...</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个下载管理器对于下载请求的管理都是放在<code>downloadImageWithURL:options:progress:completed:</code>方法里面来处理的，该方法调用了上面所提到的addProgressCallback:andCompletedBlock:forURL:createCallback:方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入<code>downloadQueue</code>操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 创建请求对象，并根据options参数设置其属性</span></div><div class="line">        <span class="comment">// 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 创建SDWebImageDownloaderOperation操作对象，并进行配置</span></div><div class="line">        <span class="comment">// 配置信息包括是否需要认证、优先级</span></div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</div><div class="line">                                                         	 <span class="comment">// 3. 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用</span></div><div class="line">                                                             ...</div><div class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                 <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                                                        	 <span class="comment">// 4. 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，</span></div><div class="line">                                                        	 <span class="comment">// 如果finished为YES，则将该url对应的回调信息从URLCallbacks中删除</span></div><div class="line">                                                            ...</div><div class="line">                                                            <span class="keyword">if</span> (finished) &#123;</div><div class="line">                                                                [sself removeCallbacksForURL:url];</div><div class="line">                                                            &#125;</div><div class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                        	<span class="comment">// 5. 取消操作将该url对应的回调信息从URLCallbacks中删除</span></div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            [sself removeCallbacksForURL:url];</div><div class="line">                                                        &#125;];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 6. 将操作加入到操作队列downloadQueue中</span></div><div class="line">		<span class="comment">// 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</span></div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，每个下载操作的超时时间可以通过<code>downloadTimeout</code>属性来设置，默认值为15秒。</p>
<h3 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h3><p>每个图片的下载都是一个<code>Operation</code>操作。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>
<p><code>SDWebImage</code>定义了一个协议，即<code>SDWebImageOperation</code>作为图片下载操作的基础协议。它只声明了一个<code>cancel</code>方法，用于取消操作。协议的具体声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>SDWebImage</code>自定义了一个<code>Operation</code>类，即<strong><code>SDWebImageDownloaderOperation</code></strong>，它继承自<code>NSOperation</code>，并采用了<code>SDWebImageOperation</code>协议。除了继承而来的方法，该类只向外暴露了一个方法，即上面所用到的初始化方法<code>initWithRequest:options:progress:completed:cancelled:</code>。</p>
<p>对于图片的下载，<code>SDWebImageDownloaderOperation</code>完全依赖于URL加载系统中的<code>NSURLConnection</code>类(并未使用7.0以后的<code>NSURLSession</code>类)。我们先来分析一下<code>SDWebImageDownloaderOperation</code>类中对于图片实际数据的下载处理，即<code>NSURLConnection</code>各代理方法的实现。</p>
<p>首先，<code>SDWebImageDownloaderOperation</code>在分类中采用了<code>NSURLConnectionDataDelegate</code>协议，并实现了该协议的以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- connection:didReceiveResponse:</div><div class="line">- connection:didReceiveData:</div><div class="line">- connectionDidFinishLoading:</div><div class="line">- connection:didFailWithError:</div><div class="line">- connection:willCacheResponse:</div><div class="line">- connectionShouldUseCredentialStorage:</div><div class="line">- connection:willSendRequestForAuthenticationChallenge:</div></pre></td></tr></table></figure>
<p>我们在此不逐一分析每个方法的实现，就重点分析一下<code>-connection:didReceiveData:</code>方法。该方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个<code>CGImageSourceRef</code>对象以做处理。在首次获取到数据时(<code>width+height==0</code>)会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用<code>CGImageSourceRef</code>对象创建一个图片对象，经过缩放、解压缩操作后生成一个<code>UIImage</code>对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>
<p><em>注：缩放操作可以查看<code>SDWebImageCompat</code>文件中的<code>SDScaledImageForKey</code>函数；解压缩操作可以查看<code>SDWebImageDecoder</code>文件<code>+decodedImageWithImage</code>方法</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="comment">// 1. 附加数据</span></div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 获取已下载数据总大小</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据</span></div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值</span></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                ...</div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line">                </div><div class="line">                <span class="comment">// 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span></div><div class="line">                <span class="comment">//    的方向会不对，所以在这边我们先保存这个信息并在后面使用。</span></div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 6. 图片还未下载完成</span></div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            </div><div class="line"><span class="meta">#ifdef TARGET_OS_IPHONE</span></div><div class="line">            <span class="comment">// 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">            </div><div class="line">            <span class="comment">// 9. 对图片进行缩放、解码操作</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">                        <span class="keyword">self</span>.completedBlock(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们前面说过<code>SDWebImageDownloaderOperation</code>类是继承自<code>NSOperation</code>类。它没有简单的实现<code>main</code>方法，而是采用更加灵活的<code>start</code>方法，以便自己管理下载的状态。</p>
<p>在<code>start</code>方法中，创建了我们下载所使用的<code>NSURLConnection</code>对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含<code>SDWebImageDownloaderContinueInBackground</code>选项。<code>start</code>方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    	<span class="comment">// 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">        <span class="comment">// 1. 如果设置了在后台执行，则进行后台执行</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                ...</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</div><div class="line">        <span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.connection start];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 在主线程抛出下载开始通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 启动run loop</span></div><div class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</div><div class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRunLoopRun</span>();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 4. 如果未完成，则取消连接</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) &#123;</div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span>.connection didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span>.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        ... </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，在下载完成或下载失败后，需要停止当前线程的<code>run loop</code>，清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考<code>-connectionDidFinishLoading:</code>与<code>-connection:didFailWithError:</code>的实现。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下载的核心其实就是利用<code>NSURLConnection</code>对象来加载数据。每个图片的下载都由一个<code>Operation</code>操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的另一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>
<p><code>SDWebImage</code>提供了对图片缓存的支持，而该功能是由<code>SDImageCache</code>类来完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>
<h3 id="内存缓存及磁盘缓存"><a href="#内存缓存及磁盘缓存" class="headerlink" title="内存缓存及磁盘缓存"></a>内存缓存及磁盘缓存</h3><p>内存缓存的处理是使用<code>NSCache</code>对象来实现的。<code>NSCache</code>是一个类似于集合的容器。它存储<code>key-value</code>对，这一点类似于<code>NSDictionary</code>类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p>
<p>磁盘缓存的处理则是使用<code>NSFileManager</code>对象来实现的。图片存储的位置是位于<code>Cache</code>文件夹。另外，<code>SDImageCache</code>还定义了一个串行队列，来异步存储图片。</p>
<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSCache</span> *memCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *diskCachePath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *customPaths;</div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithNamespace:(<span class="built_in">NSString</span> *)ns &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// Init the memory cache</span></div><div class="line">        _memCache = [[<span class="built_in">NSCache</span> alloc] init];</div><div class="line">        _memCache.name = fullNamespace;</div><div class="line">        </div><div class="line">        <span class="comment">// Init the disk cache</span></div><div class="line">        <span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</div><div class="line">        _diskCachePath = [paths[<span class="number">0</span>] stringByAppendingPathComponent:fullNamespace];</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">            _fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SDImageCache</code>提供了大量方法来缓存、获取、移除及清空图片。而对于每个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个<code>key</code>值来索引它。在内存中，我们将其作为<code>NSCache</code>的<code>key</code>值，而在磁盘中，我们用这个<code>key</code>作为图片的文件名。对于一个远程服务器下载的图片，其<code>url</code>是作为这个<code>key</code>的最佳选择了。我们在后面会看到这个<code>key</code>值的重要性。</p>
<h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个<code>task</code>放到串行队列中处理。在iOS中，会先检测图片是<code>PNG</code>还是<code>JPEG</code>，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做<code>MD5</code>摘要后的串)。缓存操作的基础方法是-<code>storeImage:recalculateFromImage:imageData:forKey:toDisk</code>，它的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 内存缓存，将其存入NSCache中，同时传入图片的消耗值</span></div><div class="line">    [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (toDisk) &#123;</div><div class="line">        <span class="comment">// 2. 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中</span></div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            <span class="built_in">NSData</span> *data = imageData;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</div><div class="line"><span class="meta">#if TARGET_OS_IPHONE</span></div><div class="line">                </div><div class="line">                <span class="comment">// 3. 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10</span></div><div class="line">                <span class="comment">// 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span></div><div class="line">                <span class="built_in">BOOL</span> imageIsPng = <span class="literal">YES</span>;</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</div><div class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (imageIsPng) &#123;</div><div class="line">                    data = <span class="built_in">UIImagePNGRepresentation</span>(image);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</div><div class="line">                &#125;</div><div class="line"><span class="meta">#else</span></div><div class="line">                data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image.representations usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</div><div class="line"><span class="meta">#endif</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 4. 创建缓存文件并存储图片</span></div><div class="line">            <span class="keyword">if</span> (data) &#123;</div><div class="line">                <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                [_fileManager createFileAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询图片"><a href="#查询图片" class="headerlink" title="查询图片"></a>查询图片</h3><p>如果我们想在内存或磁盘中查询是否有<code>key</code>指定的图片，则可以分别使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>而如果只是想查看本地是否在key指定的图片，则不管是在内存还是在磁盘上，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromDiskCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage) &#123;</div><div class="line">                <span class="built_in">CGFloat</span> cost = diskImage.size.height * diskImage.size.width * diskImage.scale * diskImage.scale;</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h3><p>图片的移除操作则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key withCompletion:(SDWebImageNoParamsBlock)completion;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>我们可以选择同时移除内存及磁盘上的图片。</p>
<h3 id="清理图片"><a href="#清理图片" class="headerlink" title="清理图片"></a>清理图片</h3><p>磁盘缓存图片的清理操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，清空操作有以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)clearDisk;</div><div class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>而部分清理则是根据我们设定的一些参数值来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过<code>maxCacheAge</code>属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过<code>maxCacheSize</code>属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在-<code>cleanDiskWithCompletionBlock:</code>方法中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</div><div class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 该枚举器预先获取缓存文件的有用的属性</span></div><div class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</div><div class="line">        </div><div class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.maxCacheAge];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// 3. 跳过文件夹</span></div><div class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 4. 移除早于有效期的老文件</span></div><div class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 5. 存储文件的引用并计算所有文件的总大小，以备后用</span></div><div class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</div><div class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.maxCacheSize) &#123;</div><div class="line">            <span class="comment">// 7. 以设置的最大缓存大小的一半作为清理目标</span></div><div class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.maxCacheSize / <span class="number">2</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// 8. 按照最后修改时间来排序剩下的缓存文件</span></div><div class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></div><div class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</div><div class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</div><div class="line">                                                            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">// 9. 删除文件，直到缓存总大小降到我们期望的大小</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</div><div class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</div><div class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        	        	        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，<code>SDImageCache</code>类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个<code>key</code>指定的图片。另外，<code>SDImageCache</code>类提供了一个单例方法的实现，所以我们可以将其当作单例对象来处理。</p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><p>在实际的运用中，我们并不直接使用<code>SDWebImageDownloader</code>类及<code>SDImageCache</code>类来执行图片的下载及缓存。为了方便用户的使用，<code>SDWebImage</code>提供了<code>SDWebImageManager</code>对象来管理图片的下载与缓存。而且我们经常用到的诸如<code>UIImageView+WebCache</code>等控件的分类都是基于<code>SDWebImageManager</code>对象的。该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的代码中我们还可以看到有一个<code>delegate</code>属性，其是一个<code>id\&lt;SDWebImageManagerDelegate\&gt;</code>对象。<code>SDWebImageManagerDelegate</code>声明了两个可选实现的方法，如下所示：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 控制当图片在缓存中没有找到时，应该下载哪个图片</span></div><div class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line"></div><div class="line"><span class="comment">// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换</span></div><div class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</div></pre></td></tr></table></figure>
<p>这两个代理方法会在<code>SDWebImageManager</code>的<code>-downloadImageWithURL:options:progress:completed:</code>方法中调用，而这个方法是<code>SDWebImageManager</code>类的核心所在。我们来看看它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">    <span class="comment">// 前面省略n行。主要作了如下处理：</span></div><div class="line">    <span class="comment">// 1. 判断url的合法性</span></div><div class="line">    <span class="comment">// 2. 创建SDWebImageCombinedOperation对象</span></div><div class="line">    <span class="comment">// 3. 查看url是否是之前下载失败过的</span></div><div class="line">    <span class="comment">// 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调</span></div><div class="line">    </div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line"></div><div class="line">			<span class="comment">// 下载</span></div><div class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="keyword">if</span> (weakOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 操作被取消，则不做任务事情</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                	<span class="comment">// 如果出错，则调用完成回调，并将url放入下载挫败url数组中</span></div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">	                    <span class="comment">// 在全局队列中并行处理图片的缓存</span></div><div class="line">	                    <span class="comment">// 首先对图片做个转换操作，该操作是代理对象实现的</span></div><div class="line">	                    <span class="comment">// 然后对图片做缓存处理</span></div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                            </div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            ...</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 下载完成并缓存后，将操作从队列中移除</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                        [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">// 设置取消回调</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [subOperation cancel];</div><div class="line">                </div><div class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                    [<span class="keyword">self</span>.runningOperations removeObject:weakOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项来缓存图片。上面这个下载方法中的操作选项参数是由枚举<code>SDWebImageOptions</code>来定义的，这个操作中的一些选项是与<code>SDWebImageDownloaderOptions</code>中的选项对应的。我们来看看这个<code>SDWebImageOptions</code>选项都有哪些：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记禁用磁盘缓存</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。</span></div><div class="line">    <span class="comment">// 默认情况下，图像在下载完成后一次性显示</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。</span></div><div class="line">    <span class="comment">// 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。</span></div><div class="line">    <span class="comment">// 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次</span></div><div class="line">    <span class="comment">// 然后再用最终图片调用一次</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成</span></div><div class="line">    <span class="comment">// 如果后台任务超时，则操作被取消</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL认证</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，</span></div><div class="line">    <span class="comment">// 以便图片能立即下载而不是等到当前队列被加载</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。</span></div><div class="line">    <span class="comment">// 使用这个票房则不任何情况下都进行转换。</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>大家在看<code>-downloadImageWithURL:options:progress:completed:</code>，可以看到两个<code>SDWebImageOptions</code>与<code>SDWebImageDownloaderOptions</code>中的选项是如何对应起来的，在此不多做解释。</p>
<h2 id="视图扩展"><a href="#视图扩展" class="headerlink" title="视图扩展"></a>视图扩展</h2><p>我在使用<code>SDWebImage</code>的时候，使用得最多的是<code>UIImageView+WebCache</code>中的针对<code>UIImageView</code>的扩展方法，这些扩展方法将<code>UIImageView</code>与<code>WebCache</code>集成在一起，来让<code>UIImageView</code>对象拥有异步下载和缓存远程图片的能力。其中最核心的方法是<code>-sd_setImageWithURL:placeholderImage:options:progress:completed:</code>，其使用<code>SDWebImageManager</code>单例对象下载并缓存图片，完成后将图片赋值给<code>UIImageView</code>对象的<code>image</code>属性，以使图片显示出来，其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line">        __<span class="keyword">weak</span> <span class="built_in">UIImageView</span> *wself = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 使用SDWebImageManager单例对象来下载图片</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">                </div><div class="line">                <span class="comment">// 图片下载完后显示图片</span></div><div class="line">                <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了扩展<code>UIImageView</code>之外，<code>SDWebImage</code>还扩展了<code>UIView</code>、<code>UIButton</code>、<code>MKAnnotationView</code>等视图类，大家可以参考源码。</p>
<p>当然，如果不想使用这些扩展，则可以直接使用<code>SDWebImageManager</code>来下载图片，这也是很OK的。</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p><code>SDWebImage</code>的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>
<ol>
<li><code>dispatch_barrier_sync</code>函数：该方法用于对操作设置屏幕，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</li>
<li><code>NSMutableURLRequest</code>：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</li>
<li><code>NSOperation</code>及<code>NSOperationQueue</code>：操作队列是<code>Objective-C</code>中一种高级的并发处理方法，现在它是基于<code>GCD</code>来实现的。相对于<code>GCD</code>来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对<code>SDWebImage</code>中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</li>
<li><code>NSURLConnection</code>：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即<code>NSURLSession</code>类。</li>
<li>开启一个后台任务。</li>
<li><code>NSCache</code>类：一个类似于集合的容器。它存储<code>key-value</code>对，这一点类似于<code>NSDictionary</code>类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</li>
<li>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
<li>对图片的解压缩操作：这一操作可以查看<code>SDWebImageDecoder.m</code>中<code>+decodedImageWithImage</code>方法的实现。</li>
<li>对<code>GIF</code>图片的处理</li>
<li>对<code>WebP</code>图片的处理</li>
</ol>
<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage工程</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="http://objccn.io/issue-2-2/" target="_blank" rel="external">常见的后台实践</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/" target="_blank" rel="external">NSCache Class Reference</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/01/31/cocoa-foundation-nsobject-protocol/" rel="next" title="Foundation: NSObject Protocol">
                <i class="fa fa-chevron-left"></i> Foundation: NSObject Protocol
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/02/11/cocoa-foundation-nscache/" rel="prev" title="Foundation: NSCache">
                Foundation: NSCache <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#下载"><span class="nav-number">1.</span> <span class="nav-text">下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载选项"><span class="nav-number">1.1.</span> <span class="nav-text">下载选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载顺序"><span class="nav-number">1.2.</span> <span class="nav-text">下载顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载管理器"><span class="nav-number">1.3.</span> <span class="nav-text">下载管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载操作"><span class="nav-number">1.4.</span> <span class="nav-text">下载操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存"><span class="nav-number">2.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存缓存及磁盘缓存"><span class="nav-number">2.1.</span> <span class="nav-text">内存缓存及磁盘缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储图片"><span class="nav-number">2.2.</span> <span class="nav-text">存储图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询图片"><span class="nav-number">2.3.</span> <span class="nav-text">查询图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除图片"><span class="nav-number">2.4.</span> <span class="nav-text">移除图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理图片"><span class="nav-number">2.5.</span> <span class="nav-text">清理图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">2.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageManager"><span class="nav-number">3.</span> <span class="nav-text">SDWebImageManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图扩展"><span class="nav-number">4.</span> <span class="nav-text">视图扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技术点"><span class="nav-number">5.</span> <span class="nav-text">技术点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
