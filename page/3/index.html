<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/3/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/3/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/10/ios-techset-1/" itemprop="url">
                  iOS知识小集 第1期(2015.05.10)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-10T22:06:42+08:00" content="2015-05-10">
              2015-05-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想做这样一个小册子，来记录自己平时开发、阅读博客、看书、代码分析和与人交流中遇到的各种问题。之前有过这样的尝试，但都是无疾而终。不过，每天接触的东西多，有些东西不记下来，忘得也是很快，第二次遇到同样的问题时，还得再查一遍。好记性不如烂笔头，所以又决定重拾此事，时不时回头看看，温故而知新。</p>
<p>这里面的每个问题，不会太长。或是读书笔记，或是摘抄，亦或是验证，每个问题的篇幅争取在六七百字的样子。笔记和摘抄的出处会详细标明。问题的个数不限，凑齐<code>3000</code>字左右就发一篇。争取每月至少发两篇吧，权当是对自己学习的一个整理。</p>
<p>本期主要记录了以下几个问题：</p>
<ol>
<li><code>NSString</code>属性什么时候用<code>copy</code>，什么时候用<code>strong?</code></li>
<li><code>Foundation</code>中的断言处理</li>
<li><code>IBOutletCollection</code></li>
<li><code>NSRecursiveLock</code>递归锁的使用</li>
<li><code>NSHashTable</code></li>
</ol>
<h2 id="NSString属性什么时候用copy，什么时候用strong"><a href="#NSString属性什么时候用copy，什么时候用strong" class="headerlink" title="NSString属性什么时候用copy，什么时候用strong?"></a>NSString属性什么时候用copy，什么时候用strong?</h2><p>我们在声明一个<code>NSString</code>属性时，对于其内存相关特性，通常有两种选择(基于<code>ARC</code>环境)：<code>strong</code>与<code>copy</code>。那这两者有什么区别呢？什么时候该用<code>strong</code>，什么时候该用<code>copy</code>呢？让我们先来看个例子。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface TestStringClass ()</div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy) NSString *copyedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码声明了两个字符串属性，其中一个内存特性是<code>strong</code>，一个是<code>copy</code>。下面我们来看看它们的区别。</p>
<p>首先，我们用一个不可变字符串来为这两个属性赋值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line"></div><div class="line">    NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, %p&quot;, strongString, &amp;strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, %p&quot;, copyedString, &amp;copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7fe441592e20, 0x7fff57519a48</div><div class="line">strong string: 0x7fe441592e20, 0x7fe44159e1f8</div><div class="line">copy string: 0x7fe441592e20, 0x7fe44159e200</div></pre></td></tr></table></figure>
<p>我们要以看到，这种情况下，不管是<code>strong</code>还是<code>copy</code>属性的对象，其指向的地址都是同一个，即为<code>string</code>指向的地址。如果我们换作<code>MRC</code>环境，打印<code>string</code>的引用计数的话，会看到其引用计数值是<code>3</code>，即<code>strong</code>操作和<code>copy</code>操作都使原字符串对象的引用计数值加了<code>1</code>。</p>
<p>接下来，我们把<code>string</code>由不可变改为可变对象，看看会是什么结果。即将下面这一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7ff5f2e33c90, 0x7fff59937a48</div><div class="line">strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8</div><div class="line">copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</div></pre></td></tr></table></figure>
<p>可以发现，此时<code>copy</code>属性字符串已不再指向<code>string</code>字符串对象，而是深拷贝了<code>string</code>字符串，并让<code>_copyedString</code>对象指向这个字符串。在<code>MRC</code>环境下，打印两者的引用计数，可以看到<code>string</code>对象的引用计数是<code>2</code>，而<code>_copyedString</code>对象的引用计数是<code>1</code>。</p>
<p>此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以<code>_strongString</code>的值也会跟随着改变(需要注意的是，此时<code>_strongString</code>的类型实际上是<code>NSMutableString</code>，而不是<code>NSString</code>)；而<code>_copyedString</code>是指向另一个对象的，所以并不会改变。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>由于<code>NSMutableString</code>是<code>NSString</code>的子类，所以一个<code>NSString</code>指针可以指向<code>NSMutableString</code>对象，让我们的<code>strongString</code>指针指向一个可变字符串是OK的。</p>
<p>而上面的例子可以看出，当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是<code>strong</code>还是<code>copy</code>属性的对象，都是指向源对象，<code>copy</code>操作只是做了次<strong>浅拷贝</strong>。</p>
<p>当源字符串是<code>NSMutableString</code>时，<code>strong</code>属性只是增加了源字符串的引用计数，而<code>copy</code>属性则是对源字符串做了次<strong>深拷贝</strong>，产生一个新的对象，且<code>copy</code>属性对象指向这个新的对象。另外需要注意的是，这个<code>copy</code>属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>
<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，<code>strong</code>是单纯的增加对象的引用计数，而<code>copy</code>操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>
<p>所以，在声明<code>NSString</code>属性时，到底是选择<code>strong</code>还是<code>copy</code>，可以根据实际情况来定。不过，一般我们将对象声明为<code>NSString</code>时，都不希望它改变，所以大多数情况下，我们建议用<code>copy</code>，以免因可变字符串的修改导致的一些非预期问题。</p>
<p>关于字符串的内存管理，还有些有意思的东西，可以参考<a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/2521468/nsstring-copy-not-copying" target="_blank" rel="external">NSString copy not copying?</a></li>
<li><a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a></li>
<li><a href="http://blog.csdn.net/itianyi/article/details/9018567" target="_blank" rel="external">NSString什么时候用copy，什么时候用strong</a></li>
</ol>
<h2 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h2><p>经常在看一些第三方库的代码时，或者自己在写一些基础类时，都会用到断言。所以在此总结一下<code>Objective-C</code>中关于断言的一些问题。</p>
<p><code>Foundation</code>中定义了两组断言相关的宏，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ol>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ol>
<p>当断言失败时，通常是会抛出一个如下所示的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。<strong>每个线程都有自己的NSAssertionHandler对象</strong>。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line"></div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line"></div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure>
<p>另外，还定义了一个常量字符串，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p>关于断言，还需要注意的一点是在<code>Xcode 4.2</code>以后，在<code>release</code>版本中断言是默认关闭的，这是由宏<code>NS_BLOCK_ASSERTIONS</code>来处理的。也就是说，当编译<code>release</code>版本时，所有的断言调用都是无效的。</p>
<p>我们可以自定义一个继承自<code>NSAssertionHandler</code>的断言处理类，来实现一些我们自己的需求。如<code>Mattt Thompson</code>的<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>实例一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface LoggingAssertionHandler : NSAssertionHandler</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LoggingAssertionHandler</div><div class="line"></div><div class="line">- (void)handleFailureInMethod:(SEL)selector</div><div class="line">                       object:(id)object</div><div class="line">                         file:(NSString *)fileName</div><div class="line">                   lineNumber:(NSInteger)line</div><div class="line">                  description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%i&quot;, NSStringFromSelector(selector), object, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName</div><div class="line">                           file:(NSString *)fileName</div><div class="line">                     lineNumber:(NSInteger)line</div><div class="line">                    description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%i&quot;, functionName, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面说过，每个线程都有自己的断言处理器。我们可以通过为线程的<code>threadDictionary</code>字典中的<code>NSAssertionHandlerKey</code>指定一个新值，来改变线程的断言处理器。</p>
<p>如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而什么时候应该使用断言呢？通常我们期望程序按照我们的预期去运行时，如调用的参数为空时流程就无法继续下去时，可以使用断言。但另一方面，我们也需要考虑，在这加断言确实是需要的么？我们是否可以通过更多的容错处理来使程序正常运行呢？</p>
<p><code>Matt Thompson</code>在<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>中的倒数第二段说得挺有意思，在此摘抄一下：</p>
<blockquote>
<p>But if we look deeper into NSAssertionHandler—and indeed, into our own hearts, there are lessons to be learned about our capacity for kindness and compassion; about our ability to forgive others, and to recover from our own missteps. We can’t be right all of the time. We all make mistakes. By accepting limitations in ourselves and others, only then are we able to grow as individuals.</p>
</blockquote>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertion​Handler</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAssertionHandler_Class/" target="_blank" rel="external">NSAssertionHandler Class Reference</a></li>
</ol>
<h2 id="IBOutletCollection"><a href="#IBOutletCollection" class="headerlink" title="IBOutletCollection"></a>IBOutletCollection</h2><p>在<code>IB</code>与相关文件做连接时，我们经常会用到两个关键字：<code>IBOutlet</code>和<code>IBAction</code>。经常用<code>xib</code>或<code>storyboard</code>的童鞋应该用这两上关键字非常熟悉了。不过<code>UIKit</code>还提供了另一个伪关键字<strong>IBOutletCollection</strong>，我们使用这个关键字，可以将界面上一组相同的控件连接到同一个数组中。</p>
<p>我们先来看看这个伪关键字的定义，可以从<code>UIKit.framework</code>的头文件<code>UINibDeclarations.h</code>找到如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#ifndef IBOutletCollection</div><div class="line">#define IBOutletCollection(ClassName)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>另外，在<code>Clang</code>源码中，有更安全的定义方式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define IBOutletCollection(ClassName) attribute((iboutletcollection(ClassName)))</div></pre></td></tr></table></figure>
<p>从上面的定义可以看到，与<code>IBOutlet</code>不同的是，<code>IBOutletCollection</code>带有一个参数，该参数是一个类名。</p>
<p>通常情况下，我们使用一个<code>IBOutletCollection</code>属性时，属性必须是<code>strong</code>的，且类型是<code>NSArray</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSArray *scrollViews;</div></pre></td></tr></table></figure>
<p>假定我们的<code>xib</code>文件中有三个横向的<code>scrollView</code>，我们便可以将这三个<code>scrollView</code>都连接至<code>scrollViews</code>属性，然后在我们的代码中便可以做一些统一处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)setupScrollViewImages</div><div class="line">&#123;</div><div class="line">    for (UIScrollView *scrollView in self.scrollViews) &#123;</div><div class="line">        [self.imagesData enumerateObjectsUsingBlock:^(NSString *imageName, NSUInteger idx, BOOL *stop) &#123;</div><div class="line"></div><div class="line">            UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(CGRectGetWidth(scrollView.frame) * idx, 0, CGRectGetWidth(scrollView.frame), CGRectGetHeight(scrollView.frame))];</div><div class="line">            imageView.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            imageView.image = [UIImage imageNamed:imageName];</div><div class="line">            [scrollView addSubview:imageView];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码会影响到三个<code>scrollView</code>。这样做的好处是我们不需要手动通过<code>addObject:</code>方法将<code>scrollView</code>添加到<code>scrollViews</code>中。</p>
<p>不过在使用<code>IBOutletCollection</code>时，需要注意两点：</p>
<ol>
<li><code>IBOutletCollection</code>集合中对象的顺序是不确定的。我们通过调试方法可以看到集合中对象的顺序跟我们连接的顺序是一样的。但是这个顺序可能会因为不同版本的<code>Xcode</code>而有所不同。所以我们不应该试图在代码中去假定这种顺序。</li>
<li>不管<code>IBOutletCollection(ClassName)</code>中的控件是什么，属性的类型始终是<code>NSArray</code>。实际上，我们可以声明是任何类型，如<code>NSSet</code>，<code>NSMutableArray</code>，甚至可以是<code>UIColor</code>，但不管我们在此设置的是什么类，<code>IBOutletCollection</code>属性总是指向一个<code>NSArray</code>数组。</li>
</ol>
<p>关于第二点，我们以上面的<code>scrollViews</code>为例，作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSSet *scrollViews;</div></pre></td></tr></table></figure>
<p>实际上我们在控制台打印这个<code>scrollViews</code>时，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po self.scrollViews</div><div class="line">&lt;__NSArrayI 0x1740573d0&gt;(</div><div class="line">&lt;UIScrollView: 0x12d60d770; frame = (0 0; 320 162); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740574f0&gt;; layer = &lt;CALayer: 0x174229480&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60dee0; frame = (0 0; 320 161); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x174057790&gt;; layer = &lt;CALayer: 0x1742297c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60e650; frame = (0 0; 320 163); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740579a0&gt;; layer = &lt;CALayer: 0x1742298e0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看到，它指向的是一个<code>NSArray</code>数组。</p>
<p>另外，<code>IBOutletCollection</code>实际上在<code>iOS 4</code>版本中就有了。不过，现在的<code>Objective-C</code>已经支持<code>object literals</code>了，所以定义数组可以直接用<code>@[]</code>，方便了许多。而且<code>object literals</code>方式可以添加不在<code>xib</code>中的用代码定义的视图，所以显得更加灵活。当然，两种方式选择哪一种，就看我们自己的实际需要和喜好了。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/ibaction-iboutlet-iboutletcollection/" target="_blank" rel="external">IBAction / IBOutlet / IBOutlet​Collection</a></li>
<li><a href="http://www.opensource.apple.com/source/clang/clang-318.0.45/src/tools/clang/test/Index/IBOutletCollection.m" target="_blank" rel="external">IBOutletCollection.m</a></li>
</ol>
<h2 id="NSRecursiveLock递归锁的使用"><a href="#NSRecursiveLock递归锁的使用" class="headerlink" title="NSRecursiveLock递归锁的使用"></a>NSRecursiveLock递归锁的使用</h2><p><code>NSRecursiveLock</code>实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在我们的线程中，<code>RecursiveMethod</code>是递归调用的。所以每次进入这个<code>block</code>时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">* -[NSLock lock]: deadlock (&lt;NSLock: 0x1700ceee0&gt; &apos;(null)&apos;)	* Break on _NSLockError() to debug.</div></pre></td></tr></table></figure>
<p>在这种情况下，我们就可以使用<code>NSRecursiveLock</code>。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被<code>lock</code>的次数。每次成功的<code>lock</code>都必须平衡调用<code>unlock</code>操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>
<p>所以，对上面的代码进行一下改造，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div></pre></td></tr></table></figure>
<p>这样，程序就能正常运行了，其输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p><code>NSRecursiveLock</code>除了实现<code>NSLocking</code>协议的方法外，还提供了两个方法，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在给定的时间之前去尝试请求一个锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit</div><div class="line"></div><div class="line">// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功</div><div class="line">- (BOOL)tryLock</div></pre></td></tr></table></figure>
<p>这两个方法都可以用于在多线程的情况下，去尝试请求一个递归锁，然后根据返回的布尔值，来做相应的处理。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    sleep(2);</div><div class="line">    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];</div><div class="line">    if (flag) &#123;</div><div class="line">        NSLog(@&quot;lock before date&quot;);</div><div class="line"></div><div class="line">        [lock unlock];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;fail to lock before date&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在前面的代码中，我们又添加了一段代码，增加一个线程来获取递归锁。我们在第二个线程中尝试去获取递归锁，当然这种情况下是会失败的，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">fail to lock before date</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p>另外，<code>NSRecursiveLock</code>还声明了一个<code>name</code>属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(copy) NSString *name</div></pre></td></tr></table></figure>
<p>我们可以使用这个字符串来标识一个锁。<code>Cocoa</code>也会使用这个<code>name</code>作为错误描述信息的一部分。</p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRecursiveLock_Class/" target="_blank" rel="external">NSRecursiveLock Class Reference</a></li>
<li><a href="http://www.tanhao.me/pieces/643.html/" target="_blank" rel="external">Objective-C中不同方式实现锁(二)</a></li>
</ol>
<h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><p>在看<code>KVOController</code>的代码时，又看到了<code>NSHashTable</code>这个类，所以就此整理一下。</p>
<p><code>NSHashTable</code>效仿了<code>NSSet(NSMutableSet)</code>，但提供了比<code>NSSet</code>更多的操作选项，尤其是在对弱引用关系的支持上，<code>NSHashTable</code>在对象/内存处理时更加的灵活。相较于<code>NSSet</code>，<code>NSHashTable</code>具有以下特性：</p>
<ol>
<li><code>NSSet(NSMutableSet)</code>持有其元素的强引用，同时这些元素是使用<code>hash</code>值及<code>isEqual:</code>方法来做<code>hash</code>检测及判断是否相等的。</li>
<li><code>NSHashTable</code>是可变的，它没有不可变版本。</li>
<li>它可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。而这一点在<code>NSSet</code>是做不到的。</li>
<li>它的成员可以在添加时被拷贝。</li>
<li>它的成员可以使用指针来标识是否相等及做<code>hash</code>检测。</li>
<li>它可以包含任意指针，其成员没有限制为对象。我们可以配置一个<code>NSHashTable</code>实例来操作任意的指针，而不仅仅是对象。</li>
</ol>
<p>初始化<code>NSHashTable</code>时，我们可以设置一个初始选项，这个选项确定了这个<code>NSHashTable</code>对象后面所有的行为。这个选项是由<code>NSHashTableOptions</code>枚举来定义的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">    // 默认行为，强引用集合中的对象，等同于NSSet</div><div class="line">    NSHashTableStrongMemory             = 0,</div><div class="line">    </div><div class="line">    // 在将对象添加到集合之前，会拷贝对象</div><div class="line">    NSHashTableCopyIn                   = NSPointerFunctionsCopyIn,</div><div class="line"></div><div class="line">    // 使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；</div><div class="line">    // 同时使用description方法来做描述字符串</div><div class="line">    NSHashTableObjectPointerPersonality = NSPointerFunctionsObjectPointerPersonality,</div><div class="line"></div><div class="line">    // 弱引用集合中的对象，且在对象被释放后，会被正确的移除。</div><div class="line">    NSHashTableWeakMemory               = NSPointerFunctionsWeakMemory </div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef NSUInteger NSHashTableOptions;</div></pre></td></tr></table></figure>
<p>当然，我们还可以使用<code>NSPointerFunctions</code>来初始化，但只有使用<code>NSHashTableOptions</code>定义的这些值，才能确保<code>NSHashTable</code>的各个<code>API</code>可以正确的工作–包括拷贝、归档及快速枚举。</p>
<p>个人认为<code>NSHashTable</code>吸引人的地方在于可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。我们来写个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 具体调用如下</div><div class="line">@implementation TestHashAndMapTableClass &#123;</div><div class="line">    NSMutableDictionary *_dic;</div><div class="line">    NSSet               *_set;</div><div class="line">    NSHashTable         *_hashTable;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line"></div><div class="line">    if (self) &#123;</div><div class="line">        [self testWeakMemory];</div><div class="line">        NSLog(@&quot;hash table [init]: %@&quot;, _hashTable);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testWeakMemory &#123;</div><div class="line">    if (!_hashTable) &#123;</div><div class="line">        _hashTable = [NSHashTable weakObjectsHashTable];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSObject *obj = [[NSObject alloc] init];</div><div class="line">    [_hashTable addObject:obj];</div><div class="line">    NSLog(@&quot;hash table [testWeakMemory] : %@&quot;, _hashTable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hash table [testWeakMemory] : NSHashTable &#123;</div><div class="line">[6] &lt;NSObject: 0x7fa2b1562670&gt;</div><div class="line">&#125;</div><div class="line">hash table [init]: NSHashTable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在离开<code>testWeakMemory</code>方法，<code>obj</code>对象被释放，同时对象在集合中的引用也被安全的删除。</p>
<p>这样看来，<code>NSHashTable</code>似乎比<code>NSSet(NSMutableSet)</code>要好啊。那是不是我们就应用都使用<code>NSHashTable</code>呢？<code>Peter Steinberger</code>在<a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a>给了我们一组数据，显示在添加对象的操作中，<code>NSHashTable</code>所有的时间差不多是<code>NSMutableSet</code>的<code>2</code>倍，而在其它操作中，性能大体相近。所以，如果我们只需要<code>NSSet</code>的特性，就尽量用<code>NSSet</code>。</p>
<p>另外，<code>Mattt Thompson</code>在<a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a>的结尾也写了段挺有意思的话，在此直接摘抄过来：</p>
<blockquote>
<p>As always, it’s important to remember that programming is not about being clever: always approach a problem from the highest viable level of abstraction. NSSet and NSDictionary are great classes. For 99% of problems, they are undoubtedly the correct tool for the job. If, however, your problem has any of the particular memory management constraints described above, then NSHashTable &amp; NSMapTable may be worth a look.</p>
</blockquote>
<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSHashTable_class/" target="_blank" rel="external">NSHashTable Class Reference</a></li>
<li><a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHash​Table &amp; NSMap​Table</a></li>
<li><a href="http://billwang1990.github.io/blog/2014/03/31/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a></li>
<li><a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理"><a href="#一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理" class="headerlink" title="(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理"></a>(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理</h3><p>最近在静态库中写了一个<code>XXViewController</code>类，然后在主工程的<code>xib</code>中，将<code>xib</code>的类指定为<code>XXViewController</code>，程序运行时，报了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unknown class XXViewController in Interface Builder file.</div></pre></td></tr></table></figure>
<p>之前也遇到这个问题，但已记得不太清楚，所以又开始在<code>stackoverflow</code>上找答案。</p>
<p>其实这个问题与<code>Interface Builder</code>无关，最直接的原因还是相关的<code>symbol</code>没有从静态库中加载进来。这种问题的处理就是在<code>Target</code>的<code>&quot;Build Setting&quot;</code>-&gt;<code>&quot;Other Link Flags&quot;</code>中加上<code>&quot;-all_load -ObjC&quot;</code>这两个标识位，这样就OK了。</p>
<h3 id="二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理"><a href="#二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理" class="headerlink" title="(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理"></a>(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理</h3><p>我们的某个业务有这么一个需求，进入一个列表后需要立马又<code>push</code>一个<code>web</code>页面，做一些活动的推广。在<code>iOS 8</code>上，我们的实现是一切OK的；但到了<code>iOS 7</code>上，就发现这个<code>web</code>页面<code>push</code>不出来了，同时控制台给了一条警告消息，即如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unbalanced calls to begin/end appearance transitions for ...</div></pre></td></tr></table></figure>
<p>在这种情况下，点击导航栏中的返回按钮时，直接显示一个黑屏。</p>
<p>我们到<code>stackoverflow</code>上查了一下，有这么一段提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">occurs when you try and display a new viewcontroller before the current view controller is finished displaying.</div></pre></td></tr></table></figure>
<p>意思是说在当前视图控制器完成显示之前，又试图去显示一个新的视图控制器。</p>
<p>于是我们去排查代码，果然发现，在<code>viewDidLoad</code>里面去做了次网络请求操作，且请求返回后就去<code>push</code>这个<code>web</code>活动推广页。此时，当前的视图控制器可能并未显示完成(即未完成<code>push</code>操作)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Basically you are trying to push two view controllers onto the stack at almost the same time.</div></pre></td></tr></table></figure>
<p>当几乎同时将两个视图控制器<code>push</code>到当前的导航控制器栈中时，或者同时<code>pop</code>两个不同的视图控制器，就会出现不确定的结果。所以我们应该确保同一时间，对同一个导航控制器栈只有一个操作，即便当前的视图控制器正在动画过程中，也不应该再去<code>push</code>或<code>pop</code>一个新的视图控制器。</p>
<p>所以最后我们把<code>web</code>活动的数据请求放到了<code>viewDidAppear</code>里面，并做了些处理，这样问题就解决了。</p>
<h4 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/9088465/unbalanced-calls-to-begin-end-appearance-transitions-for-detailviewcontroller" target="_blank" rel="external">“Unbalanced calls to begin/end appearance transitions for DetailViewController” when pushing more than one detail view controller</a></li>
<li><a href="http://stackoverflow.com/questions/8563473/unbalanced-calls-to-begin-end-appearance-transitions-for-uitabbarcontroller" target="_blank" rel="external">Unbalanced calls to begin/end appearance transitions for UITabBarController</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/23/cocoa-foundation-nskeyvalueobserving/" itemprop="url">
                  Foundation: NSKeyValueObserving(KVO)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-23T17:31:16+08:00" content="2015-04-23">
              2015-04-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>NSKeyValueObserving</code>非正式协议定义了一种机制，它允许对象去监听其它对象的某个属性的修改。</p>
<p>我们可以监听一个对象的属性，包括简单属性，一对一的关系，和一对多的关系。一对多关系的监听者会被告知集合变更的类型，以及哪些对象参与了变化。</p>
<p><code>NSObject</code>提供了一个<code>NSKeyValueObserving</code>协议的默认实现，它为所有对象提供了一种自动发送修改通知的能力。我们可以通过禁用自动发送通知并使用这个协议提供的方法来手动实现通知的发送，以便更精确地去处理通知。</p>
<p>在这里，我们将通过具体的实例来看看<code>NSKeyValueObserving</code>提供了哪些方法。我们的基础代码如代码清单1所示：</p>
<p><strong>代码清单1：示例基础代码</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - PersonObject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonObject</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"keyPath = %@, change = %@, context = %s"</span>, keyPath, change, (<span class="keyword">char</span> *)context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - BankObject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankObject</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> accountBalance;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *bankCodeEn;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *departments;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这段代码中，我们定义一两个类，一个是<code>PersonObject</code>类，这个类的对象在下面将充当观察者的角色。另一个是<code>BankObject</code>类，我们在这个类中定义了三个属性，作为被监听的属性。由于<code>NSObject</code>类已经实现了<code>NSKeyValueObserving</code>协议，所以我们不需要再显式地去让我们的类实现这个协议。</p>
<p>接下来，我们便来看看<code>NSKeyValueObserving</code>协议有哪些功能。</p>
<h2 id="注册-移除观察者"><a href="#注册-移除观察者" class="headerlink" title="注册/移除观察者"></a>注册/移除观察者</h2><p>要让一个对象监听另一个对象的属性的变化，首先需要将这个对象注册为相关属性的观察者，我们可以使用以下方法来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这个方法带有四个参数，描述如下：</p>
<ol>
<li><code>anObserver</code>：观察者对象，这个对象必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，以响应属性的修改通知。</li>
<li><code>keyPath</code>：被监听的属性。这个值不能为nil。</li>
<li><code>options</code>：监听选项，这个值可以是<code>NSKeyValueObservingOptions</code>选项的组合。关于监听选项，我们会在下面介绍。</li>
<li><code>context</code>：任意的额外数据，我们可以将这些数据作为上下文数据，它会传递给观察者对象的<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个参数的意义在于用于区分同一对象监听同一属性(从属于同一对象)的多个不同的监听。我们将在下面看到。</li>
</ol>
<p>监听选项是由枚举<code>NSKeyValueObservingOptions</code>定义的，是传入<code>-addObserver:forKeyPath:options:context:</code>方法中以确定哪些值将被传到-<code>observeValueForKeyPath:ofObject:change:context:</code>方法中。这个枚举的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">	<span class="comment">// 提供属性的新值</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 提供属性的旧值</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 如果指定，则在添加观察者的时候立即发送一个通知给观察者，</span></div><div class="line">   	<span class="comment">// 并且是在注册观察者方法返回之前</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，</span></div><div class="line">   	<span class="comment">// 这与-willChangeValueForKey:被触发的时间是相对应的。</span></div><div class="line">   	<span class="comment">// 这样，在每次修改属性时，实际上是会发送两条通知。</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span> </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSKeyValueObservingOptions</span>;</div></pre></td></tr></table></figure>
<p>需要注意的是，当设定了<code>NSKeyValueObservingOptionPrior</code>选项时，第一条通知不会包含<code>NSKeyValueChangeNewKey</code>。当观察者自身的KVO需要为自己的某个属性调用<code>-willChange...</code>方法，而这个属性的值又依赖于被观察对象的属性时，我们可以使用这个选项。</p>
<p>另外，在添加观察者时还有两点需要注意的是：</p>
<ol>
<li>调用这个方法时，两个对象(即观察者对象及属性所属的对象)都不会被<code>retain</code>。</li>
<li>可以多次调用这个方法，将同一个对象注册为同一属性的观察者(所有参数可以完全相同)。这时，即便在所有参数一致的情况下，新注册的观察者并不会替换原来观察者，而是会并存。这样，当属性被修改时，两次监听都会响应。</li>
</ol>
<p>对于第2点，我们在代码清单2中来验证一下：</p>
<p><strong>代码清单2：验证多次使用相同参数来添加观察者的实际效果</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="string">"person instance"</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="string">"person instance 2"</span>];</div><div class="line"></div><div class="line">bankInstance.accountBalance = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>(注，以上代码为在MRC环境下调用，确保<code>personInstance</code>和<code>bankInstance</code>不会被释放。)</p>
<p>这段代码的输出如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">&#125;, context = person instance <span class="number">2</span></div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">&#125;, context = person instance</div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">    old = <span class="number">0</span>;</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">    old = <span class="number">0</span>;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到KVO为每次注册都调用了一次监听处理操作。所以多次调用同样的注册操作会产生多个观察者。另外，多个观察者之间的<code>observeValueForKeyPath:ofObject:change:context:</code>方法调用顺序是按照先进后出的顺序来的(所有的监听信息都是放在一个数组中的，我们将在下面了解到)。</p>
<p>一个良好的实践是在观察者不再需要监听属性变化时，必须调用<code>removeObserver:forKeyPath:</code>或<code>removeObserver:forKeyPath:context:</code>方法来移除观察者，这两个方法的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            </div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">               context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这两个方法会根据传入的参数(主要是<code>keyPath</code>和<code>context</code>)来移除观察者。如果<code>observer</code>没有监听<code>keyPath</code>属性，则调用这两个方法会抛出异常。大家可以试一下，程序会果断的崩溃。并报类似于以下的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer &lt;PersonObject 0x7ff541534e20&gt; for the key path "accountBalance" from &lt;BankObject 0x7ff541528430&gt; because it is not registered as an observer.'</div></pre></td></tr></table></figure>
<p>所以，我们必须确保先注册了观察者，才能调用移除方法。</p>
<p>那如果我们忘记调用移除观察者方法，会怎么样呢？我们来制造一个场景，看看会是什么结果。还是使用上面的代码，只不过这次我们在ARC下来测试：</p>
<p><strong>代码清单3：未移除观察者的影响</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testKVO &#123;</div><div class="line">    </div><div class="line">    PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line">    BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line">    </div><div class="line">    [bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line">    </div><div class="line">    bankInstance.accountBalance = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = 1;</div><div class="line">    new = 20;</div><div class="line">    old = 0;</div><div class="line">&#125;, context = (null)</div><div class="line">*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x7fc88047e7e0 of class BankObject was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x7fc880770fa0&gt; (</div><div class="line">&lt;NSKeyValueObservance 0x7fc880771850: Observer: 0x7fc8804737a0, Key path: accountBalance, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x7fc88076edd0&gt;</div><div class="line">)'</div><div class="line">......</div></pre></td></tr></table></figure>
<p>程序在调用一次KVO后，很爽快地崩溃了。给我们的解释是<code>bankInstance</code>被释放了，但KVO中仍然还有关于它的注册信息。实际上，我们上面说过，在添加观察者的时候，观察者对象与被观察属性所属的对象都不会被<code>retain</code>，然而在这些对象被释放后，相关的监听信息却还存在，KVO做的处理是直接让程序崩溃。</p>
<h2 id="处理属性修改通知"><a href="#处理属性修改通知" class="headerlink" title="处理属性修改通知"></a>处理属性修改通知</h2><p>当被监听的属性修改时，KVO会发出一个通知以告知所有监听这个属性的观察者对象。而观察者对象必须实现</p>
<p><code>-observeValueForKeyPath:ofObject:change:context:</code>方法，来对属性修改通知做相应的处理。这个方法的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这个方法有四个参数，描述如下：</p>
<ol>
<li><code>keyPath</code>：即被观察的属性，与参数<code>object</code>相关。</li>
<li><code>object</code>：<code>keyPath</code>所属的对象。</li>
<li><code>change</code>：这是一个字典，它包含了属性被修改的一些信息。这个字典中包含的值会根据我们在添加观察者时设置的<code>options</code>参数的不同而有所不同。</li>
<li><code>context</code>：这个值即是添加观察者时提供的上下文信息。</li>
</ol>
<p>在我们的示例中，这个方法的实现是打印一些基本的信息。如代码清单1所示。</p>
<p>对于第三个参数，我们通常称之为<strong>变化字典(Change Dictionary)</strong>，它记录了被监听属性的变化情况。我们可以通过以下key来获取我们想要的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeKindKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class="line"><span class="comment">// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。</span></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，</span></div><div class="line"><span class="comment">// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或</span></div><div class="line"><span class="comment">// 用于替换其它对象的对象。</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNewKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class="line"><span class="comment">// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。</span></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，</span></div><div class="line"><span class="comment">// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或</span></div><div class="line"><span class="comment">// 被替换的对象。</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeOldKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval</span></div><div class="line"><span class="comment">// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，</span></div><div class="line"><span class="comment">// 包含了被插入、移除或替换的对象的索引</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeIndexesKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，</span></div><div class="line"><span class="comment">// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey</span></div><div class="line"><span class="comment">// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>;</div></pre></td></tr></table></figure>
<p>其中，<code>NSKeyValueChangeKindKey</code>的值取自于<code>NSKeyValueChange</code>，它的值是由以下枚举定义的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// 设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeSetting</span> = <span class="number">1</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象被插入到一对多关系的属性。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeInsertion</span> = <span class="number">2</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象被从一对多关系的属性中移除。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeRemoval</span> = <span class="number">3</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象在一对多的关系的属性中被替换</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeReplacement</span> = <span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSKeyValueChange</span>;</div></pre></td></tr></table></figure>
<h2 id="通知观察者属性的变化"><a href="#通知观察者属性的变化" class="headerlink" title="通知观察者属性的变化"></a>通知观察者属性的变化</h2><p>通知观察者的方式有自动与手动两种方式。</p>
<p>默认情况下是自动发送通知，在这种模式下，当我们修改属性的值时，KVO会自动调用以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这两个方法的任务是告诉接收者给定的属性将要或已经被修改。需要注意的是不应该在子类中去重写这两个方法。</p>
<p>但如果我们希望自己控制通知发送的一些细节，则可以启用手动控制模式。手动控制通知提供了对KVO更精确控制，它可以控制通知如何以及何时被发送给观察者。采用这种方式可以减少不必要的通知，或者可以将多个修改组合到一个修改中。</p>
<p>实现手动通知的类必须重写<code>NSObject</code>中对<code>automaticallyNotifiesObserversForKey:</code>方法的实现。这个方法是在<code>NSKeyValueObserving</code>协议中声明的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这个方法返回一个布尔值(默认是返回YES)，以标识参数key指定的属性是否支持自动KVO。如果我们希望手动去发送通知，则针对指定的属性返回NO。</p>
<p>假设我们希望<code>PersonObject</code>对象去监听<code>BankObject</code>对象的<code>bankCodeEn</code>属性，并希望执行手动通知，则可以如下处理：</p>
<p><strong>代码清单4：关闭属性的自动通知发送</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"bankCodeEn"</span>]) &#123;</div><div class="line">        automatic = <span class="literal">NO</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> automatic;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样我们便可以手动去发送属性修改通知了。需要注意的是，对于对象中其它没有处理的属性，我们需要调用<code>[super automaticallyNotifiesObserversForKey:key]</code>，以避免无意中修改了父类的属性的处理方式。</p>
<p>现在我们已经通过<code>+automaticallyNotifiesObserversForKey:</code>方法设置了对象中哪些属性需要手动处理。接下来就是实际操作了。为了实现手动发送通知，我们需要在修改属性值前调用<code>willChangeValueForKey:</code>，然后在修改属性值之后调用<code>didChangeValueForKey:</code>方法。继续上面的示例，我们需要对<code>bankCodeEn</code>属性做如下处理：</p>
<p><strong>代码清单5：手动控制通知发送</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBankCodeEn:(<span class="built_in">NSString</span> *)bankCodeEn &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">    _bankCodeEn = bankCodeEn;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如果我们希望只有当<code>bankCodeEn</code>实际被修改时发送通知，以尽量减少不必要的通知，则可以如下实现：</p>
<p><strong>代码清单6：在发送通知前测试值是否修改</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBankCodeEn:(<span class="built_in">NSString</span> *)bankCodeEn &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (bankCodeEn != _bankCodeEn) &#123;</div><div class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">        _bankCodeEn = bankCodeEn;</div><div class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来测试一下上面这段代码的实际效果：</p>
<p><strong>代码清单7：测试避免属性未实际修改下不发送通知</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"bankCodeEn"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *bankCodeEn = <span class="string">@"CCB"</span>;</div><div class="line">bankInstance.bankCodeEn = bankCodeEn;</div><div class="line">bankInstance.bankCodeEn = bankCodeEn;</div></pre></td></tr></table></figure>
<p>这段代码的输出结果如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyPath = bankCodeEn, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = CCB;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>我们可以看到只输出了一次，而不是两次。</p>
<p>如果我们在<code>setter</code>方法之外改变了实例变量(如<code>_bankCodeEn</code>)，且希望这种修改被观察者监听到，则需要像在<code>setter</code>方法里面做一样的处理。这也涉及到我们通常会遇到的一个问题，在类的内部，对于一个属性值，何时用属性(<code>self.bankCodeEn</code>)访问而何时用实例变量(<code>_bankCodeEn</code>)访问。一般的建议是，在获取属性值时，可以用实例变量，在设置属性值时，尽量用<code>setter</code>方法，以保证属性的<code>KVO</code>特性。当然，性能也是一个考量，在设置值时，使用实例变量比使用属性设置值的性能高不少。</p>
<p>另外，对于一对多关系的属性，如果想手动处理通知，则可以使用以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有序的一对多关系</span></div><div class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)change valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)change valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">  </div><div class="line"><span class="comment">// 无序的一对多关系</span></div><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="built_in">NSSet</span> *)objects</div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="built_in">NSSet</span> *)objects</div></pre></td></tr></table></figure>
<p>同样，在子类中也不应该去重写这几个方法。</p>
<h2 id="计算属性-注册依赖键"><a href="#计算属性-注册依赖键" class="headerlink" title="计算属性(注册依赖键)"></a>计算属性(注册依赖键)</h2><p>有时候，我们的监听的某个属性可能会依赖于其它多个属性的变化(类似于<code>swift</code>，可以称之为计算属性)，不管所依赖的哪个属性发生了变化，都会导致计算属性的变化。对于这种一对一(<code>To-one</code>)的关系，我们需要做两步操作，首先是确定计算属性与所依赖属性的关系。如我们在<code>BankObject</code>类中定义一个<code>accountForBank</code>属性，其<code>get</code>方法定义如下：</p>
<p><strong>代码清单8：计算属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)accountForBank &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"account for %@ is %d"</span>, <span class="keyword">self</span>.bankCodeEn, <span class="keyword">self</span>.accountBalance];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>定义了这种依赖关系后，我们就需要以某种方式告诉<code>KVO</code>，当我们的被依赖属性修改时，会发送<code>accountForBank</code>属性被修改的通知。此时，我们需要重写<code>NSKeyValueObserving</code>协议的<code>keyPathsForValuesAffectingValueForKey:</code>方法，该方法声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这个方法返回的是一个集合对象，包含了那些影响key指定的属性依赖的属性所对应的字符串。所以对于<code>accountForBank</code>属性，该方法的实现如下：</p>
<p><strong>代码清单9：accountForBank属性的keyPathsForValuesAffectingValueForKey方法的实现</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"accountForBank"</span>]) &#123;</div><div class="line">        </div><div class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="string">@"accountBalance"</span>, <span class="string">@"bankCodeEn"</span>]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> keyPaths;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们来再来看看监听<code>accountForBank</code>属性是什么效果：</p>
<p><strong>代码清单10：监听accountForBank属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountForBank"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.accountBalance = <span class="number">10</span>;</div><div class="line">bankInstance.bankCodeEn = <span class="string">@"CCB"</span>;</div></pre></td></tr></table></figure>
<p>其输出结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">keyPath = accountForBank, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="string">"account for (null) is 10"</span>;</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = accountForBank, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="string">"account for CCB is 10"</span>;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到，不管是<code>accountBalance</code>还是<code>bankCodeEn</code>被修改了，都会发送<code>accountForBank</code>属性被修改的通知。</p>
<p>需要注意的就是当我们重写<code>+keyPathsForValuesAffectingValueForKey:</code>时，需要去调用<code>super</code>的对应方法，并返回一个包含父类中可能会对<code>key</code>指定属性产生影响的属性集合。</p>
<p>另外，我们还可以实现一个命名为<code>keyPathsForValuesAffecting\&lt;Key\&gt;</code>的类方法来达到同样的目的，其中<code>&lt;Key&gt;</code>是我们计算属性的名称。所以对于<code>accountForBank</code>属性，还可以如下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingAccountForBank &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"accountBalance"</span>, <span class="string">@"bankCodeEn"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种方法的实现效果是一样的。不过更建议使用后面一种方法，这种方法让依赖关系更加清晰明了。</p>
<h2 id="集合属性的监听"><a href="#集合属性的监听" class="headerlink" title="集合属性的监听"></a>集合属性的监听</h2><p><code>keyPathsForValuesAffectingValueForKey:</code>只支持一对一的关系，而不支持一对多的关系，即不支持对集合的处理。</p>
<p>对于集合的<code>KVO</code>，我们需要了解的一点是，<code>KVO</code>旨在观察关系(<code>relationship</code>)而不是集合。对于不可变集合属性，我们更多的是把它当成一个整体来监听，而无法去监听集合中的某个元素的变化；对于可变集合属性，实际上也是当成一个整体，去监听它整体的变化，如添加、删除和替换元素。</p>
<p>在KVC中，我们可以使用<strong>集合代理对象(collection proxy object)</strong>来处理集合相关的操作。我们以数组为例，在我们的<code>BankObject</code>类中有一个<code>departments</code>数组属性，如果我们希望通过集合代理对象来负责响应<code>departments</code>所有的方法，则需要实现以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-countOf&lt;Key&gt;</div><div class="line"></div><div class="line"><span class="comment">// 以下两者二选一</span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:</div><div class="line">-&lt;key&gt;AtIndexes:</div><div class="line"></div><div class="line"><span class="comment">// 可选（增强性能）</span></div><div class="line">-get&lt;Key&gt;:range:</div></pre></td></tr></table></figure>
<p>因此，我们的实现以下几个方法：</p>
<p><strong>代码清单11：集合代码对象的实现</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - 集合代理对象</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)countOfDepartments &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [_departments count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectInDepartmentsAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [_departments objectAtIndex:index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>实现以上方法之后，对于不可变数组，当我们调用<code>[bankInstance valueForKey:@&quot;departments&quot;]</code>的时候，便会返回一个由以上方法来代理所有调用方法的~对象。这个代理数组对象支持所有正常的<code>NSArray</code>调用。换句话说，调用者并不知道返回的是一个真正的<code>NSArray</code>，还是一个代理的数组。</p>
<p>另外，对于可变数组的代理对象，我们需要实现以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 至少实现一个插入方法和一个删除方法</span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:</div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:</div><div class="line">-insert&lt;Key&gt;:atIndexes:</div><div class="line">-remove&lt;Key&gt;AtIndexes:</div><div class="line"></div><div class="line"><span class="comment">// 可选（增强性能）以下方法二选一</span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</div></pre></td></tr></table></figure>
<p>这些方法分别对应插入、删除和替换，有批量操作的，也有只改变一个对象的方法。可以根据实际需要来实现。</p>
<p>另外，对于可变集合，我们通常不使用<code>valueForKey:</code>来获取代理对象，而是使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>通过这个方法，我们便可以将可变数组与强大的<code>KVO</code>结合在一起。<code>KVO</code>机制能在集合改变的时候把详细的变化放进<code>change</code>字典中。</p>
<p>我们先来看看下面的代码：</p>
<p><strong>代码清单12：使用真正的数组对象监听可变数组属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"departments"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.departments = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"></div><div class="line">[bankInstance.departments addObject:<span class="string">@"departments"</span>];</div></pre></td></tr></table></figure>
<p>其输出为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">keyPath = departments, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new =     (</div><div class="line">    );</div><div class="line">    old =     (</div><div class="line">    );</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到通过这种方法，我们获取的是真正的数组，只在<code>departments</code>属性整体被修改时，才会触发<code>KVO</code>，而在添加元素时，并没有触发<code>KVO</code>。</p>
<p>现在我们通过代理集合对象来看看：</p>
<p><strong>代码清单13：使用代理集合对象监听可变数组属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"departments"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.departments = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *departments = [bankInstance mutableArrayValueForKey:<span class="string">@"departments"</span>];</div><div class="line">[departments insertObject:<span class="string">@"departments 0"</span> atIndex:<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">keyPath = departments, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new =     (</div><div class="line">    );</div><div class="line">    old =     (</div><div class="line">    );</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = departments, change = &#123;</div><div class="line">    indexes = <span class="string">"&lt;NSIndexSet: 0x7fcd18673150&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]"</span>;</div><div class="line">    kind = <span class="number">2</span>;</div><div class="line">    new =     (</div><div class="line">        <span class="string">"departments 0"</span></div><div class="line">    );</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到，在往数组中添加对象时，也触发了KVO，并将改变的详细信息也写进了<code>change</code>字典。在第二个消息中，<code>kind</code>的值为2，即表示这是一次插入操作。同样，可变数组的删除，替换操作也是一样的。</p>
<p>集合(<code>Set</code>)也有一套对应的方法来实现集合代理对象，包括无序集合与有序集合；而字典则没有，对于字典属性的监听，还是只能作为一个整理来处理。</p>
<p>如果我们想到手动控制集合属性消息的发送，则可以使用上面提到的几个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-willChange:valuesAtIndexes:forKey:</div><div class="line">-didChange:valuesAtIndexes:forKey:</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">-willChangeValueForKey:withSetMutation:usingObjects:</div><div class="line">-didChangeValueForKey:withSetMutation:usingObjects:</div></pre></td></tr></table></figure>
<p>不过得先保证把自动通知关闭，否则每次改变<code>KVO</code>都会被发送两次。</p>
<h2 id="监听信息"><a href="#监听信息" class="headerlink" title="监听信息"></a>监听信息</h2><p>如果我们想获取一个对象上有哪些观察者正在监听其属性的修改，则可以查看对象的<code>observationInfo</code>属性，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="keyword">void</span> *observationInfo</div></pre></td></tr></table></figure>
<p>可以看到它是一个<code>void</code>指针，指向一个包含所有观察者的一个标识信息对象，这些信息包含了每个监听的观察者，注册时设定的选项等等。我们还是用示例来看看。</p>
<p><strong>代码清单14：observationInfo的使用</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"bankCodeEn"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, personInstance);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, bankInstance);</div><div class="line"></div><div class="line"><span class="keyword">id</span> info = bankInstance.observationInfo;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [info description]);</div></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">personInstance = <span class="number">0x7fdc2369e5e0</span></div><div class="line">bankInstance = <span class="number">0x7fdc2369d8f0</span></div><div class="line">&lt;<span class="built_in">NSKeyValueObservationInfo</span> <span class="number">0x7fdc236a19d0</span>&gt; (</div><div class="line">&lt;<span class="built_in">NSKeyValueObservance</span> <span class="number">0x7fdc236a17a0</span>: Observer: <span class="number">0x7fdc2369e5e0</span>, Key path: bankCodeEn, Options: &lt;New: <span class="literal">YES</span>, Old: <span class="literal">NO</span>, Prior: <span class="literal">NO</span>&gt; Context: <span class="number">0x0</span>, Property: <span class="number">0x7fdc236a15c0</span>&gt;</div><div class="line">&lt;<span class="built_in">NSKeyValueObservance</span> <span class="number">0x7fdc236a1960</span>: Observer: <span class="number">0x7fdc2369e5e0</span>, Key path: accountBalance, Options: &lt;New: <span class="literal">NO</span>, Old: <span class="literal">YES</span>, Prior: <span class="literal">NO</span>&gt; Context: <span class="number">0x0</span>, Property: <span class="number">0x7fdc236a1880</span>&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>我们可以看到<code>observationInfo</code>指针实际上是指向一个<code>NSKeyValueObservationInfo</code>对象，它包含了指定对象上的所有的监听信息。而每条监听信息而是封装在一个<code>NSKeyValueObservance</code>对象中，从上面可以看到，这个对象中包含消息的观察者、被监听的属性、添加观察者时所设置的一些选项、上下文信息等。</p>
<p><code>NSKeyValueObservationInfo</code>类及<code>NSKeyValueObservance</code>类都是私有类，我们无法在官方文档中找到这两个类的实现。不过从一些对系统库<code>dump</code>出来的头文件，我们可以对这两个类有一些初步的了解。<a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump/tree/master/Frameworks/Foundation.framework" target="_blank" rel="external">这里</a>有一个对<code>iOS SKD 4.3</code>的<code>Foundation.framework</code>的<code>dump</code>头文件，可以找到这两个类的头文件，其中<code>NSKeyValueObservationInfo</code>的头文件信息如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;XXUnknownSuperclass.h&gt;</span> // Unknown library</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">NSArray</span>, <span class="title">NSHashTable</span>;</span></div><div class="line"></div><div class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKeyValueObservationInfo</span> : <span class="title">XXUnknownSuperclass</span> </span>&#123;</div><div class="line"><span class="keyword">@private</span></div><div class="line">	<span class="keyword">int</span> _retainCountMinusOne;</div><div class="line">	<span class="built_in">NSArray</span>* _observances;</div><div class="line">	<span class="keyword">unsigned</span> _cachedHash;</div><div class="line">	<span class="built_in">BOOL</span> _cachedIsShareable;</div><div class="line">	<span class="built_in">NSHashTable</span>* _observables;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">id</span>)_initWithObservances:(<span class="keyword">id</span>*)observances count:(<span class="keyword">unsigned</span>)count;</div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span>;</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release;</div><div class="line">-(<span class="keyword">unsigned</span>)retainCount;</div><div class="line">-(<span class="keyword">void</span>)dealloc;</div><div class="line">-(<span class="keyword">unsigned</span>)hash;</div><div class="line">-(<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)equal;</div><div class="line">-(<span class="keyword">id</span>)description;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到其中有一个数组来存储<code>NSKeyValueObservance</code>对象。</p>
<p><code>NSKeyValueObservance</code>类的头文件信息如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Foundation-Structs.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;XXUnknownSuperclass.h&gt;</span> // Unknown library</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">NSPointerArray</span>, <span class="title">NSKeyValueProperty</span>, <span class="title">NSObject</span>;</span></div><div class="line"></div><div class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKeyValueObservance</span> : <span class="title">XXUnknownSuperclass</span> </span>&#123;</div><div class="line"><span class="keyword">@private</span></div><div class="line">	<span class="keyword">int</span> _retainCountMinusOne;</div><div class="line">	<span class="built_in">NSObject</span>* _observer;</div><div class="line">	<span class="built_in">NSKeyValueProperty</span>* _property;</div><div class="line">	<span class="keyword">unsigned</span> _options;</div><div class="line">	<span class="keyword">void</span>* _context;</div><div class="line">	<span class="built_in">NSObject</span>* _originalObservable;</div><div class="line">	<span class="keyword">unsigned</span> _cachedUnrotatedHashComponent;</div><div class="line">	<span class="built_in">BOOL</span> _cachedIsShareable;</div><div class="line">	<span class="built_in">NSPointerArray</span>* _observationInfos;</div><div class="line">	auto_weak_callback_block _observerWentAwayCallback;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">id</span>)_initWithObserver:(<span class="keyword">id</span>)observer property:(<span class="keyword">id</span>)property options:(<span class="keyword">unsigned</span>)options context:(<span class="keyword">void</span>*)context originalObservable:(<span class="keyword">id</span>)observable;</div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span>;</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release;</div><div class="line">-(<span class="keyword">unsigned</span>)retainCount;</div><div class="line">-(<span class="keyword">void</span>)dealloc;</div><div class="line">-(<span class="keyword">unsigned</span>)hash;</div><div class="line">-(<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)equal;</div><div class="line">-(<span class="keyword">id</span>)description;</div><div class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">id</span>)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="keyword">id</span>)change context:(<span class="keyword">void</span>*)context;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到其中包含了一个监听的基本要素。在此不再做深入分析(没有源代码，深入不下去了啊)。</p>
<p>我们再回到<code>observationInfo</code>属性本身来。在文档中，对这个属性的描述有这样一段话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The <span class="keyword">default</span> implementation of <span class="keyword">this</span> method retrieves the information from a global</div><div class="line">dictionary keyed by the receiver’s pointers.</div></pre></td></tr></table></figure>
<p>即这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。由此，我们可以理解为，KVO的信息是存储在一个全局字典中，而不是存储在对象本身。这类似于<code>Notification</code>，所有关于通知的信息都是放在<code>NSNotificationCenter</code>中。</p>
<p>不过，为了提高效率，我们可以重写<code>observationInfo</code>属性的set和get方法，以将这个不透明的数据指针存储到一个实例变量中。但是，在重写时，我们不应该尝试去向这些数据发送一个<code>Objective-C</code>消息，包括<code>retain</code>和<code>release</code>。</p>
<h2 id="KVO的实现机制"><a href="#KVO的实现机制" class="headerlink" title="KVO的实现机制"></a>KVO的实现机制</h2><p>【本来这一小节是想放在另一篇总结中来写的，但后来觉得还是放在这里比较合适，所以就此添加上】</p>
<p>了解了<code>NSKeyValueObserving</code>所提供的功能后，我们再来看看KVO的实现机制，以便更深入地的理解KVO。</p>
<p>KVO据我所查还没有开源(若哪位大大有查到源代码，还烦请告知)，所以我们无法从源代码的层面来分析它的实现。不过<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Mike Ash</a>的博文(译文见参考文献4)为我们解开了一些谜团。</p>
<p>基本的思路是：<code>Objective-C</code>依托于强大的<code>runtime</code>机制来实现KVO。当我们第一次观察某个对象的属性时，<code>runtime</code>会创建一个新的继承自这个对象的<code>class</code>的<code>subclass</code>。在这个新的<code>subclass</code>中，它会重写所有被观察的<code>key</code>的<code>setter</code>，然后将<code>object</code>的<code>isa</code>指针指向新创建的<code>class</code>(这个指针告诉<code>Objective-C</code>运行时某个<code>object</code>到底是什么类型的)。所以<code>object</code>神奇地变成了新的子类的实例。</p>
<p>嗯，让我们通过代码来看看实际的实现：</p>
<p><strong>代码清单15：探究KVO的实现机制</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 辅助方法</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *ClassMethodNames(Class c) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</div><div class="line">    Method *methodList = class_copyMethodList(c, &amp;methodCount);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</div><div class="line">        [array addObject:<span class="built_in">NSStringFromSelector</span>(method_getName(methodList[i]))];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(methodList);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> PrintDescription(<span class="built_in">NSString</span> *name, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> objc_object *objcet = (__bridge <span class="keyword">struct</span> objc_object *)obj;</div><div class="line">    </div><div class="line">    Class cls = objcet-&gt;isa;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@: %@\n\tNSObject class %s\n\tlibobjc class %s : super class %s\n\timplements methods &lt;%@&gt;"</span>,</div><div class="line">                     name,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj <span class="keyword">class</span>]),</div><div class="line">                     class_getName(cls),</div><div class="line">                     class_getName(class_getSuperclass(cls)),</div><div class="line">                     [ClassMethodNames(cls) componentsJoinedByString:<span class="string">@", "</span>]];</div><div class="line">    printf(<span class="string">"%s\n"</span>, [str UTF8String]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line">BankObject *bankInstance1 = [[BankObject alloc] init];</div><div class="line">BankObject *bankInstance2 = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance2 addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">PrintDescription(<span class="string">@"bankInstance1"</span>, bankInstance1);</div><div class="line">PrintDescription(<span class="string">@"bankInstance2"</span>, bankInstance2);</div><div class="line"></div><div class="line">printf(<span class="string">"Using libobjc functions, normal setAccountBalance: is %p, overridden setAccountBalance: is %p"</span>, method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance2), <span class="keyword">@selector</span>(setAccountBalance:))),</div><div class="line">       method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance1), <span class="keyword">@selector</span>(setAccountBalance:))));</div></pre></td></tr></table></figure>
<p>这段代码的输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bankInstance1: &lt;BankObject: <span class="number">0x7f9e8ae3cf60</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span> BankObject</div><div class="line">	libobjc <span class="keyword">class</span> BankObject : <span class="keyword">super</span> <span class="keyword">class</span> <span class="built_in">NSObject</span></div><div class="line">	implements methods &lt;accountBalance, setAccountBalance:, bankCodeEn, setBankCodeEn:, departments, setDepartments:&gt;</div><div class="line">	</div><div class="line">bankInstance2: &lt;BankObject: <span class="number">0x7f9e8ae3cfc0</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span> BankObject</div><div class="line">	libobjc <span class="keyword">class</span> <span class="built_in">NSKVONotifying_BankObject</span> : <span class="keyword">super</span> <span class="keyword">class</span> BankObject</div><div class="line">	implements methods &lt;setAccountBalance:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;</div><div class="line">	</div><div class="line">Using libobjc functions, normal setAccountBalance: is <span class="number">0x1013cec17</span>, overridden setAccountBalance: is <span class="number">0x10129fe50</span></div></pre></td></tr></table></figure>
<p>从输出中可以看到，<code>bankInstance2</code>监听<code>accountBalance</code>属性后，其实际上所属的类已经不是<code>BankObject</code>了，而是继承自<code>BankObject</code>的<code>NSKVONotifying_BankObject</code>类。同时，<code>NSKVONotifying_BankObject</code>类重写了<code>setAccountBalance</code>方法，这个方法将实现如何通知观察者们的操作。当改变<code>accountBalance</code>属性时，就会调用被重写的<code>setAccountBalance</code>方法，并通过这个方法来发送通知。</p>
<p>另外我们也可以看到<code>bankInstance2</code>对象的打印<code>[bankInstance2 class]</code>时，返回的仍然是<code>BankObject</code>。这是苹果故意而为之，他们不希望这个机制暴露在外面。所以除了重写相应的<code>setter</code>，所以动态生成的<code>NSKVONotifying_BankObject</code>类还重写了<code>class</code>方法，让它返回原先的类。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KVO作为<code>Objective-C</code>中两个对象间通信机制中的一种，提供了一种非常强大的机制。在经典的MVC架构中，控制器需要确保视图与模型的同步，当<code>model</code>对象改变时，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。而KVO便为我们提供了这样一种同步机制：我们让控制器去监听一个<code>model</code>对象属性的改变，并根据这种改变来更新我们的视图。所有，有效地使用KVO，对我们应用的开发意义重大。</p>
<p>别话：对KVO的总结感觉还是意犹未尽，总感觉缺少点什么，特别是在对集合这一块的处理。还请大家多多提供指点。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/#//apple_ref/occ/instm/NSObject/observationInfo" target="_blank" rel="external">NSKeyValueObserving Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">Key-Value Observing Programming Guide</a></li>
<li><a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump" target="_blank" rel="external">iOS-SDK-4.3-Framework-Header-Dump</a></li>
<li><a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC 和 KVO</a></li>
<li><a href="http://www.appcoda.com/understanding-key-value-observing-coding/" target="_blank" rel="external">Understanding Key-Value Observing and Coding</a></li>
<li><a href="http://www.cocoachina.com/ios/20140107/7667.html" target="_blank" rel="external">KVO的内部实现</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/24/sourcecode-mbprogresshud/" itemprop="url">
                  MBProgressHUD实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-24T20:41:51+08:00" content="2015-03-24">
              2015-03-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>源码来源：<a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">https://github.com/jdg/MBProgressHUD</a></p>
<p>版本：0.9.1</p>
<p><code>MBProgressHUD</code>是一个显示<code>HUD</code>窗口的第三方类库，用于在执行一些后台任务时，在程序中显示一个表示进度的<code>loading</code>视图和两个可选的文本提示的<code>HUD</code>窗口。我想最多是应用在加载网络数据的时候。其实苹果官方自己有一个带有此功能的类<code>UIProgressHUD</code>，只不过它是私有的，现在不让用。至于实际的效果，可以看看<code>github</code>上工程给出的几张图例(貌似我这经常无法单独打开图片，所以就不在这贴图片了)，也可以运行一下<code>Demo</code>。</p>
<p>具体用法我们就不多说了，参考<code>github</code>上的说明就能用得很顺的。本文主要还是从源码的角度来分析一下它的具体实现。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>在分析实现代码之前，我们先来看看<code>MBProgressHUD</code>中定义的<code>MBProgressHUDMode</code>枚举。它用来表示<code>HUD</code>窗口的模式，即我们从效果图中看到的几种显示样式。其具体定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">// 使用UIActivityIndicatorView来显示进度，这是默认值</span></div><div class="line">    MBProgressHUDModeIndeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用一个圆形饼图来作为进度视图</span></div><div class="line">    MBProgressHUDModeDeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用一个水平进度条</span></div><div class="line">    MBProgressHUDModeDeterminateHorizontalBar,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用圆环作为进度条</span></div><div class="line">    MBProgressHUDModeAnnularDeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 显示一个自定义视图，通过这种方式，可以显示一个正确或错误的提示图</span></div><div class="line">    MBProgressHUDModeCustomView,</div><div class="line">    </div><div class="line">    <span class="comment">// 只显示文本</span></div><div class="line">    MBProgressHUDModeText</div><div class="line">    </div><div class="line">&#125; MBProgressHUDMode;</div></pre></td></tr></table></figure>
<p>通过设置<code>MBProgressHUD</code>的模式，我们可以使用<code>MBProgressHUD</code>自定义的表示进度的视图来满足我们的需求，也可以自定义这个进度视图，当然还可以只显示文本。在下面我们会讨论源码中是如何使用这几个值的。</p>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>我们先来了解一下<code>MBProgressHUD</code>的基本组成。一个<code>MBProgressHUD</code>视图主要由四个部分组成：</p>
<ol>
<li><code>loading</code>动画视图(在此做个统称，当然这个区域可以是自定义的一个<code>UIImageView</code>视图)。这个视图由我们设定的模式值决定，可以是菊花、进度条，也可以是我们自定义的视图；</li>
<li>标题文本框(<code>label</code>)：主要用于显示提示的主题信息。这个文本框是可选的，通常位于<code>loading</code>动画视图的下面，且它是单行显示。它会根据<code>labelText</code>属性来自适应文本的大小(有一个长度上限)，如果过长，则超出的部分会显示为”…”；</li>
<li>详情文本框(<code>detailsLabel</code>)。如果觉得标题不够详细，或者有附属信息，就可以将详细信息放在这里面显示。该文本框对应的是显示<code>detailsLabelText</code>属性的值，它是可以多行显示的。另外，详情的显示还依赖于<code>labelText</code>属性的设置，只有<code>labelText</code>属性被设置了，且不为空串，才会显示<code>detailsLabel</code>；</li>
<li><code>HUD</code>背景框。主要是作为上面三个部分的一个背景，用来突出上面三部分。</li>
</ol>
<p>为了让我们更好地自定义这几个部分，<code>MBProgressHUD</code>还提供了一些属性，我们简单了解一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 背景框的透明度，默认值是0.8</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> opacity;</div><div class="line"></div><div class="line"><span class="comment">// 背景框的颜色</span></div><div class="line"><span class="comment">// 需要注意的是如果设置了这个属性，则opacity属性会失效，即不会有半透明效果</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span> *color;</div><div class="line"></div><div class="line"><span class="comment">// 背景框的圆角半径。默认值是10.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> cornerRadius;</div><div class="line"></div><div class="line"><span class="comment">// 标题文本的字体及颜色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIFont</span>* labelFont;</div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span>* labelColor;</div><div class="line"></div><div class="line"><span class="comment">// 详情文本的字体及颜色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIFont</span>* detailsLabelFont;</div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span>* detailsLabelColor;</div><div class="line"></div><div class="line"><span class="comment">// 菊花的颜色，默认是白色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span> *activityIndicatorColor;</div></pre></td></tr></table></figure>
<p>通过以上属性，我们可以根据自己的需要来设置这几个部分的外观。</p>
<p>另外还有一个比较有意思的属性是<code>dimBackground</code>，用于为<code>HUD</code>窗口的视图区域覆盖上一层径向渐变(<code>radial gradient</code>)层，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> dimBackground;</div></pre></td></tr></table></figure>
<p>让我们来看看通过它，<code>MBProgressHUD</code>都做了些什么。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">	</div><div class="line">	...</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.dimBackground) &#123;</div><div class="line">		<span class="comment">//Gradient colours</span></div><div class="line">		size_t gradLocationsNum = <span class="number">2</span>;</div><div class="line">		<span class="built_in">CGFloat</span> gradLocations[<span class="number">2</span>] = &#123;<span class="number">0.0</span>f, <span class="number">1.0</span>f&#125;;</div><div class="line">		<span class="built_in">CGFloat</span> gradColors[<span class="number">8</span>] = &#123;<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.75</span>f&#125;; </div><div class="line">		<span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">		<span class="built_in">CGGradientRef</span> gradient = <span class="built_in">CGGradientCreateWithColorComponents</span>(colorSpace, gradColors, gradLocations, gradLocationsNum);</div><div class="line">		<span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">		</div><div class="line">		<span class="comment">//Gradient center</span></div><div class="line">		<span class="built_in">CGPoint</span> gradCenter= <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width/<span class="number">2</span>, <span class="keyword">self</span>.bounds.size.height/<span class="number">2</span>);</div><div class="line">		<span class="comment">//Gradient radius</span></div><div class="line">		<span class="keyword">float</span> gradRadius = MIN(<span class="keyword">self</span>.bounds.size.width , <span class="keyword">self</span>.bounds.size.height) ;</div><div class="line">		</div><div class="line">		<span class="comment">// 由中心向四周绘制渐变</span></div><div class="line">		<span class="built_in">CGContextDrawRadialGradient</span> (context, gradient, gradCenter,</div><div class="line">									 <span class="number">0</span>, gradCenter, gradRadius,</div><div class="line">									 kCGGradientDrawsAfterEndLocation);</div><div class="line">		<span class="built_in">CGGradientRelease</span>(gradient);</div><div class="line">	&#125;</div><div class="line">	...	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码由中心向<code>MBProgressHUD</code>视图的四周绘制了一个渐变层。当然，这里的颜色值是写死的，我们无法自行定义。有兴趣的话，大家可以将这个属性设置为YES，看看实际的效果。</p>
<h2 id="创建、布局与绘制"><a href="#创建、布局与绘制" class="headerlink" title="创建、布局与绘制"></a>创建、布局与绘制</h2><p>除了继承自<code>UIView</code>的<code>-initWithFrame:</code>初始化方法，<code>MBProgressHUD</code>还为我们提供了两个初始化方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithWindow:(<span class="built_in">UIWindow</span> *)window;</div><div class="line">- (<span class="keyword">id</span>)initWithView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
<p>这两个方法分别传入一个<code>UIWindow</code>对象和一个<code>UIView</code>对象。传入的视图对象仅仅是做为<code>MBProgressHUD</code>视图定义其<code>frame</code>属性的参照，而不会直接将<code>MBProgressHUD</code>视图添加到传入的视图对象上。这个添加操作还得我们自行处理(当然，<code>MBProgressHUD</code>还提供了几个便捷的类方法，我们下面会说明)。</p>
<p><code>MBProgressHUD</code>提供了几个属性，可以让我们控制<code>HUD</code>的布局，这些属性主要有以下几个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HUD相对于父视图中心点的x轴偏移量和y轴偏移量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> xOffset;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> yOffset;</div><div class="line"></div><div class="line"><span class="comment">// HUD各元素与HUD边缘的间距</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> margin;</div><div class="line"></div><div class="line"><span class="comment">// HUD背景框的最小大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGSize</span> minSize;</div><div class="line"></div><div class="line"><span class="comment">// HUD的实际大小</span></div><div class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> size;</div><div class="line"></div><div class="line"><span class="comment">// 是否强制HUD背景框宽高相等</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span> = isSquare) <span class="built_in">BOOL</span> square;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>MBProgressHUD</code>视图会充满其父视图的<code>frame</code>内，为此，在<code>MBProgressHUD</code>的<code>layoutSubviews</code>方法中，还专门做了处理，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</div><div class="line">	[<span class="keyword">super</span> layoutSubviews];</div><div class="line">	</div><div class="line">	<span class="comment">// Entirely cover the parent view</span></div><div class="line">	<span class="built_in">UIView</span> *parent = <span class="keyword">self</span>.superview;</div><div class="line">	<span class="keyword">if</span> (parent) &#123;</div><div class="line">		<span class="keyword">self</span>.frame = parent.bounds;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也因此，当<code>MBProgressHUD</code>显示时，它也会屏蔽父视图的各种交互操作。</p>
<p>在布局的过程中，会先根据我们要显示的视图计算出容纳这些视图所需要的总的宽度和高度。当然，会设置一个最大值。我们截取其中一段来看看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="built_in">CGFloat</span> remainingHeight = bounds.size.height - totalSize.height - kPadding - <span class="number">4</span> * margin; </div><div class="line"><span class="built_in">CGSize</span> maxSize = <span class="built_in">CGSizeMake</span>(maxWidth, remainingHeight);</div><div class="line"><span class="built_in">CGSize</span> detailsLabelSize = MB_MULTILINE_TEXTSIZE(detailsLabel.text, detailsLabel.font, maxSize, detailsLabel.lineBreakMode);</div><div class="line">totalSize.width = MAX(totalSize.width, detailsLabelSize.width);</div><div class="line">totalSize.height += detailsLabelSize.height;</div><div class="line"><span class="keyword">if</span> (detailsLabelSize.height &gt; <span class="number">0.</span>f &amp;&amp; (indicatorF.size.height &gt; <span class="number">0.</span>f || labelSize.height &gt; <span class="number">0.</span>f)) &#123;</div><div class="line">	totalSize.height += kPadding;</div><div class="line">&#125;</div><div class="line"></div><div class="line">totalSize.width += <span class="number">2</span> * margin;</div><div class="line">totalSize.height += <span class="number">2</span> * margin;</div></pre></td></tr></table></figure>
<p>之后，就开始从上到下放置各个视图。在布局代码的最后，计算了一个<code>size</code>值，这是为后面绘制背景框做准备的。</p>
<p>在上面的布局代码中，主要是处理了<code>loading</code>动画视图、标题文本框和详情文本框，而<code>HUD</code>背景框主要是在<code>drawRect:</code>中来绘制的。背景框的绘制代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Center HUD</span></div><div class="line"><span class="built_in">CGRect</span> allRect = <span class="keyword">self</span>.bounds;</div><div class="line"><span class="comment">// Draw rounded HUD backgroud rect</span></div><div class="line"><span class="built_in">CGRect</span> boxRect = <span class="built_in">CGRectMake</span>(round((allRect.size.width - size.width) / <span class="number">2</span>) + <span class="keyword">self</span>.xOffset,</div><div class="line">							round((allRect.size.height - size.height) / <span class="number">2</span>) + <span class="keyword">self</span>.yOffset, size.width, size.height);</div><div class="line"><span class="keyword">float</span> radius = <span class="keyword">self</span>.cornerRadius;</div><div class="line"><span class="built_in">CGContextBeginPath</span>(context);</div><div class="line"><span class="built_in">CGContextMoveToPoint</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMinY</span>(boxRect));</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMaxX</span>(boxRect) - radius, <span class="built_in">CGRectGetMinY</span>(boxRect) + radius, radius, <span class="number">3</span> * (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMaxX</span>(boxRect) - radius, <span class="built_in">CGRectGetMaxY</span>(boxRect) - radius, radius, <span class="number">0</span>, (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMaxY</span>(boxRect) - radius, radius, (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, (<span class="keyword">float</span>)M_PI, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMinY</span>(boxRect) + radius, radius, (<span class="keyword">float</span>)M_PI, <span class="number">3</span> * (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextClosePath</span>(context);</div><div class="line"><span class="built_in">CGContextFillPath</span>(context);</div></pre></td></tr></table></figure>
<p>这是最平常的绘制操作，在此不多做解释。</p>
<p>我们上面讲过<code>MBProgressHUD</code>提供了几种窗口模式，这几种模式的主要区别在于<code>loading</code>动画视图的展示。默认情况下，使用的是菊花(<code>MBProgressHUDModeIndeterminate</code>)。我们可以通过设置以下属性，来改变<code>loading</code>动画视图：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) MBProgressHUDMode mode;</div></pre></td></tr></table></figure>
<p>对于其它几种模式，<code>MBProgressHUD</code>专门我们提供了几个视图类。如果是进度条模式(<code>MBProgressHUDModeDeterminateHorizontalBar</code>)，则使用的是<code>MBBarProgressView</code>类；如果是饼图模式(<code>MBProgressHUDModeDeterminate</code>)或环形模式(<code>MBProgressHUDModeAnnularDeterminate</code>)，则使用的是<code>MBRoundProgressView</code>类。上面这两个类的主要操作就是在<code>drawRect:</code>中根据一些进度参数来绘制形状，大家可以自己详细看一下。</p>
<p>当然，我们还可以自定义<code>loading</code>动画视图，此时选择的模式是<code>MBProgressHUDModeCustomView</code>。或者不显示<code>loading</code>动画视图，而只显示文本框(<code>MBProgressHUDModeText</code>)。</p>
<p>具体显示哪一种<code>loading</code>动画视图，是在<code>-updateIndicators</code>方法中来处理的，其实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateIndicators &#123;</div><div class="line">	</div><div class="line">	<span class="built_in">BOOL</span> isActivityIndicator = [indicator isKindOfClass:[<span class="built_in">UIActivityIndicatorView</span> <span class="keyword">class</span>]];</div><div class="line">	<span class="built_in">BOOL</span> isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView <span class="keyword">class</span>]];</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (mode == MBProgressHUDModeIndeterminate) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123;</div><div class="line">		<span class="comment">// Update to bar determinate indicator</span></div><div class="line">		[indicator removeFromSuperview];</div><div class="line">		<span class="keyword">self</span>.indicator = MB_AUTORELEASE([[MBBarProgressView alloc] init]);</div><div class="line">		[<span class="keyword">self</span> addSubview:indicator];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123;</div><div class="line">		<span class="keyword">if</span> (!isRoundIndicator) &#123;</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (mode == MBProgressHUDModeAnnularDeterminate) &#123;</div><div class="line">			[(MBRoundProgressView *)indicator setAnnular:<span class="literal">YES</span>];</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeCustomView &amp;&amp; customView != indicator) &#123;</div><div class="line">		...</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeText) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h2><p><code>MBRoundProgressView</code>为我们提供了丰富的显示与隐藏<code>HUD</code>窗口的。在分析这些方法之前，我们先来看看<code>MBProgressHUD</code>为显示与隐藏提供的一些属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HUD显示和隐藏的动画类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) MBProgressHUDAnimation animationType;</div><div class="line"></div><div class="line"><span class="comment">// HUD显示的最短时间。设置这个值是为了避免HUD显示后立即被隐藏。默认值为0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> minShowTime;</div><div class="line"></div><div class="line"><span class="comment">// 这个属性设置了一个宽限期，它是在没有显示HUD窗口前被调用方法可能运行的时间。</span></div><div class="line"><span class="comment">// 如果被调用方法在宽限期内执行完，则HUD不会被显示。</span></div><div class="line"><span class="comment">// 这主要是为了避免在执行很短的任务时，去显示一个HUD窗口。</span></div><div class="line"><span class="comment">// 默认值是0。只有当任务状态是已知时，才支持宽限期。具体我们看实现代码。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> graceTime;</div><div class="line"></div><div class="line"><span class="comment">// 这是一个标识位，标明执行的操作正在处理中。这个属性是配合graceTime使用的。</span></div><div class="line"><span class="comment">// 如果没有设置graceTime，则这个标识是没有太大意义的。在使用showWhileExecuting:onTarget:withObject:animated:方法时，</span></div><div class="line"><span class="comment">// 会自动去设置这个属性为YES，其它情况下都需要我们自己手动设置。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> taskInProgress;</div><div class="line"></div><div class="line"><span class="comment">// 隐藏时是否将HUD从父视图中移除，默认是NO。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> removeFromSuperViewOnHide;</div><div class="line"></div><div class="line"><span class="comment">// 进度指示器，从0.0到1.0，默认值为0.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> progress;</div><div class="line"></div><div class="line"><span class="comment">// 在HUD被隐藏后的回调</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) MBProgressHUDCompletionBlock completionBlock;</div></pre></td></tr></table></figure>
<p>以上这些属性都还好理解，可能需要注意的就是<code>graceTime</code>和<code>taskInProgress</code>的配合使用。在下面我们将会看看这两个属性的用法。</p>
<p>对于显示操作，最基本的就是<code>-show:</code>方法(其它几个显示方法都会调用该方法来显示HUD窗口)，我们先来看看它的实现，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)show:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// If the grace time is set postpone the HUD display</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">		<span class="keyword">self</span>.graceTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> </div><div class="line">						   selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">	&#125; </div><div class="line">	<span class="comment">// ... otherwise show the HUD imediately </span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		[<span class="keyword">self</span> showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果我们没有设置<code>graceTime</code>属性，则会立即显示<code>HUD</code>；而如果设置了<code>graceTime</code>，则会创建一个定时器，并让显示操作延迟到<code>graceTime</code>所设定的时间再执行，而<code>-handleGraceTimer:</code>实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">	<span class="comment">// Show the HUD only if the task is still running</span></div><div class="line">	<span class="keyword">if</span> (taskInProgress) &#123;</div><div class="line">		[<span class="keyword">self</span> showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，只有在设置了<code>taskInProgress</code>标识位为YES的情况下，才会去显示<code>HUD</code>窗口。所以，如果我们要自己调用<code>-show:</code>方法的话，需要酌情考虑设置<code>taskInProgress</code>标识位。</p>
<p>除了<code>-show:</code>方法以外，<code>MBProgressHUD</code>还为我们提供了一组显示方法，可以让我们在显示<code>HUD</code>的同时，执行一些后台任务，我们在此主要介绍两个。其中一个是<code>-showWhileExecuting:onTarget:withObject:animated:</code>，它是基于<code>target-action</code>方式的调用，在执行一个后台任务时显示<code>HUD</code>，等后台任务执行完成后再隐藏<code>HUD</code>，具体实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showWhileExecuting:(SEL)method onTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">id</span>)object animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	methodForExecution = method;</div><div class="line">	targetForExecution = MB_RETAIN(target);</div><div class="line">	objectForExecution = MB_RETAIN(object);	</div><div class="line">	<span class="comment">// Launch execution in new thread</span></div><div class="line">	<span class="keyword">self</span>.taskInProgress = <span class="literal">YES</span>;</div><div class="line">	[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(launchExecution) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</div><div class="line">	<span class="comment">// Show HUD view</span></div><div class="line">	[<span class="keyword">self</span> show:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)launchExecution &#123;</div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">		<span class="comment">// Start executing the requested task</span></div><div class="line">		[targetForExecution performSelector:methodForExecution withObject:objectForExecution];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">		<span class="comment">// Task completed, update view in main thread (note: view operations should</span></div><div class="line">		<span class="comment">// be done only in the main thread)</span></div><div class="line">		[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(cleanUp) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>-showWhileExecuting:onTarget:withObject:animated:</code>首先将<code>taskInProgress</code>属性设置为YES，这样在调用<code>-show:</code>方法时，即使设置了<code>graceTime</code>，也确保能在任务完成之前显示<code>HUD</code>。然后开启一个新线程，来异步执行我们的后台任务，最后去显示<code>HUD</code>。</p>
<p>而在异步调用方法<code>-launchExecution</code>中，线程首先是维护了自己的一个<code>@autoreleasepool</code>，所以在我们自己的方法中，就不需要再去维护一个<code>@autoreleasepool</code>了。之后是去执行我们的任务，在任务完成之后，再回去主线程去执行清理操作，并隐藏<code>HUD</code>窗口。</p>
<p>另一个显示方法是<code>-showAnimated:whileExecutingBlock:onQueue:completionBlock:</code>，它是基于GCD的调用，当<code>block</code>中的任务在指定的队列中执行时，显示<code>HUD</code>窗口，任务完成之后执行<code>completionBlock</code>操作，最后隐藏<code>HUD</code>窗口。我们来看看它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(<span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">	 completionBlock:(MBProgressHUDCompletionBlock)completion &#123;</div><div class="line">	<span class="keyword">self</span>.taskInProgress = <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">self</span>.completionBlock = completion;</div><div class="line">	<span class="built_in">dispatch_async</span>(queue, ^(<span class="keyword">void</span>) &#123;</div><div class="line">		block();</div><div class="line">		<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^(<span class="keyword">void</span>) &#123;</div><div class="line">			[<span class="keyword">self</span> cleanUp];</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">	[<span class="keyword">self</span> show:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也是首先将<code>taskInProgress</code>属性设置为YES，然后开启一个线程去执行<code>block</code>任务，最后主线程去执行清理操作，并隐藏<code>HUD</code>窗口。</p>
<p>对于<code>HUD</code>的隐藏，<code>MBProgressHUD</code>提供了两个方法，一个是<code>-hide:</code>，另一个是<code>-hide:afterDelay:</code>，后者基于前者，所以我们主要来看看<code>-hide:</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hide:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// If the minShow time is set, calculate how long the hud was shown,</span></div><div class="line">	<span class="comment">// and pospone the hiding operation if necessary</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; showStarted) &#123;</div><div class="line">		<span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:showStarted];</div><div class="line">		<span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</div><div class="line">			<span class="keyword">self</span>.minShowTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> </div><div class="line">								selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ... otherwise hide the HUD immediately</span></div><div class="line">	[<span class="keyword">self</span> hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在设置了<code>minShowTime</code>属性并且已经显示了<code>HUD</code>窗口的情况下，会去判断显示的时间是否小于<code>minShowTime</code>指定的时间，如果是，则会开启一个定时器，等到显示的时间到了<code>minShowTime</code>所指定的时间，才会去隐藏<code>HUD</code>窗口；否则会直接去隐藏<code>HUD</code>窗口。</p>
<p>隐藏的实际操作主要是去做了些清理操作，包括根据设定的<code>removeFromSuperViewOnHide</code>值来执行是否从父视图移除<code>HUD</code>窗口，以及执行<code>completionBlock</code>操作，还有就是执行代理的<code>hudWasHidden:</code>方法。这些操作是在私有方法<code>-done</code>里面执行的，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)done &#123;</div><div class="line">	[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</div><div class="line">	isFinished = <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">self</span>.alpha = <span class="number">0.0</span>f;</div><div class="line">	<span class="keyword">if</span> (removeFromSuperViewOnHide) &#123;</div><div class="line">		[<span class="keyword">self</span> removeFromSuperview];</div><div class="line">	&#125;</div><div class="line"><span class="meta">#if NS_BLOCKS_AVAILABLE</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.completionBlock) &#123;</div><div class="line">		<span class="keyword">self</span>.completionBlock();</div><div class="line">		<span class="keyword">self</span>.completionBlock = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">	<span class="keyword">if</span> ([delegate respondsToSelector:<span class="keyword">@selector</span>(hudWasHidden:)]) &#123;</div><div class="line">		[delegate performSelector:<span class="keyword">@selector</span>(hudWasHidden:) withObject:<span class="keyword">self</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><code>MBProgressHUD</code>的一些主要的代码差不多已经分析完了，最后还有些边边角角的地方，一起来看看。</p>
<h3 id="显示和隐藏的便捷方法"><a href="#显示和隐藏的便捷方法" class="headerlink" title="显示和隐藏的便捷方法"></a>显示和隐藏的便捷方法</h3><p>除了上面描述的实例方法之外，<code>MBProgressHUD</code>还为我们提供了几个便捷显示和隐藏<code>HUD</code>窗口的方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div><div class="line">+ (<span class="built_in">NSUInteger</span>)hideAllHUDsForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div></pre></td></tr></table></figure>
<p>方法的签名已经很能说明问题了，在此不多描述。</p>
<h3 id="部分属性值的设置"><a href="#部分属性值的设置" class="headerlink" title="部分属性值的设置"></a>部分属性值的设置</h3><p>对于部分属性(主要是”外观”一节中针对菊花、标题文本框和详情文本框的几个属性值)，为了在设置将这些属性时修改对应视图的属性，并没有直接为每个属性生成一个<code>setter</code>，而是通过KVO来监听这些属性值的变化，再将这些值赋值给视图的对应属性，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听的属性数组</span></div><div class="line">- (<span class="built_in">NSArray</span> *)observableKeypaths &#123;</div><div class="line">	<span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"mode"</span>, <span class="string">@"customView"</span>, <span class="string">@"labelText"</span>, <span class="string">@"labelFont"</span>, <span class="string">@"labelColor"</span>, ..., <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册KVO</span></div><div class="line">- (<span class="keyword">void</span>)registerForKVO &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> [<span class="keyword">self</span> observableKeypaths]) &#123;</div><div class="line">		[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">	<span class="keyword">if</span> (![<span class="built_in">NSThread</span> isMainThread]) &#123;</div><div class="line">		[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateUIForKeypath:) withObject:keyPath waitUntilDone:<span class="literal">NO</span>];</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		[<span class="keyword">self</span> updateUIForKeypath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateUIForKeypath:(<span class="built_in">NSString</span> *)keyPath &#123;</div><div class="line">	<span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"mode"</span>] || [keyPath isEqualToString:<span class="string">@"customView"</span>] ||</div><div class="line">		[keyPath isEqualToString:<span class="string">@"activityIndicatorColor"</span>]) &#123;</div><div class="line">		[<span class="keyword">self</span> updateIndicators];</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"labelText"</span>]) &#123;</div><div class="line">		label.text = <span class="keyword">self</span>.labelText;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	[<span class="keyword">self</span> setNeedsLayout];</div><div class="line">	[<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><code>MBProgressHUD</code>还为我们提供了一个代理<code>MBProgressHUDDelegate</code>，这个代理中只提供了一个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hudWasHidden:(MBProgressHUD *)hud;</div></pre></td></tr></table></figure>
<p>这个代理方法是在隐藏<code>HUD</code>窗口后调用，如果此时我们需要在我们自己的实现中执行某些操作，则可以实现这个方法。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>MBProgressHUD</code>为我们提供了一个<code>HUD</code>窗口的很好的实现，不过个人在使用过程中，觉得它给我们提供的交互功能太少。其代理只提供了一个<code>-hudWasHidden:</code>方法，而且我们也无法通过点击<code>HUD</code>来执行一些操作。在现实的需求中，可能存在这种情况：比如一个网络操作，在发送请求等待响应的过程中，我们会显示一个<code>HUD</code>窗口以显示一个<code>loading</code>框。但如果我们想在等待响应的过程中，在当前视图中取消这个网络请求，就没有相应的处理方式，<code>MBProgressHUD</code>没有为我们提供这样的交互操作。当然这时候，我们可以根据自己的需求来修改源码。</p>
<h2 id="与SVProgressHUD的对比"><a href="#与SVProgressHUD的对比" class="headerlink" title="与SVProgressHUD的对比"></a>与SVProgressHUD的对比</h2><p>与<code>MBProgressHUD</code>类似，<code>SVProgressHUD</code>类库也为我们提供了在视图中显示一个<code>HUD</code>窗口的功能。两者的基本思路是差不多的，差别更多的是在实现细节上。相对于<code>MBProgressHUD</code>来说，<code>SVProgressHUD</code>的实现有以下几点不同：</p>
<ol>
<li><code>SVProgressHUD</code>类对外提供的都是类方法，包括显示、隐藏、和视图属性设置都是使用类方法来操作。其内部实现为一个单例对象，类方法实际是针对这个单例对象来操作的。</li>
<li><code>SVProgressHUD</code>主要包含三部分：<code>loading</code>视图、提示文本框和背景框，没有详情文本框。</li>
<li><code>SVProgressHUD</code>默认提供了正确、错误和信息三种状态视图(与<code>loading</code>视图同一位置，根据需要来设置)。当然<code>MBProgressHUD</code>中，也可以自定义视图(<code>customView</code>)来显示相应的状态视图。</li>
<li><code>SVProgressHUD</code>为我们提供了更多的交互操作，包括点击事件、显示事件及隐藏事件。不过这些都是通过通知的形式向外发送，所以我们需要自己去监听这些事件。</li>
<li><code>SVProgressHUD</code>中一些<code>loading</code>动画是以<code>Layer</code>动画的形式来实现的。</li>
</ol>
<p><code>SVProgressHUD</code>的实现细节还未详细去看，有兴趣的读者可以去研究一下。这两个<code>HUD</code>类库各有优点，大家在使用时，可根据自己的需要和喜好来选择。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总体来说，<code>MBProgressHUD</code>的代码相对朴实，简单易懂，没有什么花哨难懂的东西。就技术点而言，也没有太多复杂的技术，都是我们常用的一些东西。就使用而言，也是挺方便的，参考一下<code>github</code>上的使用指南就能很快上手。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/20/cocoa-foundation-nsnotificationcenter/" itemprop="url">
                  Foundation: NSNotificationCenter
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-20T17:45:28+08:00" content="2015-03-20">
              2015-03-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个<code>NSNotificationCenter</code>对象(通知中心)提供了在程序中广播消息的机制，它实质上就是一个通知分发表。这个分发表负责维护为各个通知注册的观察者，并在通知到达时，去查找相应的观察者，将通知转发给他们进行处理。</p>
<p>本文主要了整理了一下<code>NSNotificationCenter</code>的使用及需要注意的一些问题，并提出了一些未解决的问题，希望能在此得到解答。</p>
<h2 id="获取通知中心"><a href="#获取通知中心" class="headerlink" title="获取通知中心"></a>获取通知中心</h2><p>每个程序都会有一个默认的通知中心。为此，<code>NSNotificationCenter</code>提供了一个类方法来获取这个通知中心：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSNotificationCenter</span> *)defaultCenter</div></pre></td></tr></table></figure>
<p>获取了这个默认的通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者，移除观察者、发送通知等。</p>
<p>通常如果不是出于必要，我们一般都使用这个默认的通知中心，而不自己创建维护一个通知中心。</p>
<h2 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h2><p>如果想让对象监听某个通知，则需要在通知中心中将这个对象注册为通知的观察者。早先，<code>NSNotificationCenter</code>提供了以下方法来添加观察者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)notificationObserver</div><div class="line">           selector:(SEL)notificationSelector</div><div class="line">               name:(<span class="built_in">NSString</span> *)notificationName</div><div class="line">             object:(<span class="keyword">id</span>)notificationSender</div></pre></td></tr></table></figure>
<p>这个方法带有4个参数，分别指定了通知的观察者、处理通知的回调、通知名及通知的发送对象。这里需要注意几个问题：</p>
<ol>
<li><code>notificationObserver</code>不能为nil。</li>
<li><code>notificationSelector</code>回调方法有且只有一个参数(<code>NSNotification</code>对象)。</li>
<li>如果<code>notificationName</code>为nil，则会接收所有的通知(如果<code>notificationSender</code>不为空，则接收所有来自于<code>notificationSender</code>的所有通知)。如代码清单1所示。</li>
<li>如果<code>notificationSender</code>为nil，则会接收所有<code>notificationName</code>定义的通知；否则，接收由<code>notificationSender</code>发送的通知。</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
</ol>
<p>对于以上几点，我们来重点关注一下第3条。以下代码演示了当我们的<code>notificationName</code>设置为nil时，通知的监听情况。</p>
<p><strong>代码清单1：添加一个Observer，其中notificationName为nil</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:<span class="literal">nil</span> object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"notification = %@"</span>, notification.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>运行后的输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">notification = TestNotification</div><div class="line">notification = <span class="built_in">UIWindowDidBecomeVisibleNotification</span></div><div class="line">notification = <span class="built_in">UIWindowDidBecomeKeyNotification</span></div><div class="line">notification = <span class="built_in">UIApplicationDidFinishLaunchingNotification</span></div><div class="line">notification = _UIWindowContentWillRotateNotification</div><div class="line">notification = _UIApplicationWillAddDeactivationReasonNotification</div><div class="line">notification = _UIApplicationDidRemoveDeactivationReasonNotification</div><div class="line">notification = <span class="built_in">UIDeviceOrientationDidChangeNotification</span></div><div class="line">notification = _UIApplicationDidRemoveDeactivationReasonNotification</div><div class="line">notification = <span class="built_in">UIApplicationDidBecomeActiveNotification</span></div></pre></td></tr></table></figure>
<p>可以看出，我们的对象基本上监听了测试程序启动后的所示消息。当然，我们很少会去这么做。</p>
<p>而对于第4条，使用得比较多的场景是监听<code>UITextField</code>的修改事件，通常我们在一个<code>ViewController</code>中，只希望去监听当前视图中的<code>UITextField</code>修改事件，而不希望监听所有<code>UITextField</code>的修改事件，这时我们就可以将当前页面的<code>UITextField</code>对象指定为<code>notificationSender</code>。</p>
<p>在iOS 4.0之后，<code>NSNotificationCenter</code>为了跟上时代，又提供了一个以<code>block</code>方式实现的添加观察者的方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="built_in">NSString</span> *)name</div><div class="line">                            object:(<span class="keyword">id</span>)obj</div><div class="line">                             queue:(<span class="built_in">NSOperationQueue</span> *)queue</div><div class="line">                        usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block</div></pre></td></tr></table></figure>
<p>大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个匿名的对象作为观察者(即方法返回的<code>id&lt;NSObject&gt;</code>对象)，这个匿名对象会在指定的队列(<code>queue</code>)上去执行我们的<code>block</code>。</p>
<p>这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。这个方法也有几个地方需要注意：</p>
<ol>
<li><code>name</code>和<code>obj</code>为nil时的情形与前面一个方法是相同的。</li>
<li>如果<code>queue</code>为nil，则消息是默认在<code>post</code>线程中同步处理，即通知的<code>post</code>与转发是在同一线程中；但如果我们指定了操作队列，情况就变得有点意思了，我们一会再讲。</li>
<li><code>block</code>块会被通知中心拷贝一份(执行<code>copy</code>操作)，以在堆中维护一个<code>block</code>对象，直到观察者被从通知中心中移除。所以，应该特别注意在<code>block</code>中使用外部对象，避免出现对象的循环引用，这个我们在下面将举例说明。</li>
<li>如果一个给定的通知触发了多个观察者的<code>block</code>操作，则这些操作会在各自的<code>Operation Queue</code>中被并发执行。所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
<li>该方法会返回一个表示观察者的对象，记得在不用时释放这个对象。</li>
</ol>
<p>下面我们重点说明一下第2点和第3点。</p>
<p>关于第2点，当我们指定一个<code>Operation Queue</code>时，不管通知是在哪个线程中<code>post</code>的，都会在<code>Operation Queue</code>所属的线程中进行转发，如代码清单2所示：</p>
<p><strong>代码清单2：在指定队列中接收通知</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:TEST_NOTIFICATION object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"receive thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"post thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，我们在主线程里添加了一个观察者，并指定在主线程队列中去接收处理这个通知。然后我们在一个全局队列中<code>post</code>了一个通知。我们来看下输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">post thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ffe0351f5f0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</div><div class="line">receive thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ffe03508b30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div></pre></td></tr></table></figure>
<p>可以看到，消息的<code>post</code>与接收处理并不是在同一个线程中。如上面所提到的，如果<code>queue</code>为nil，则消息是默认在<code>post</code>线程中同步处理，大家可以试一下。</p>
<p>对于第3点，由于使用的是<code>block</code>，所以需要注意的就是避免引起循环引用的问题，如代码清单3所示：</p>
<p><strong>代码清单3：block引发的循环引用问题</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Observer</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> i;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; observer;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Init Observer"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 添加观察者</span></div><div class="line">        _observer =  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:TEST_NOTIFICATION object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"handle notification"</span>);</div><div class="line">            </div><div class="line">            <span class="comment">// 使用self</span></div><div class="line">            <span class="keyword">self</span>.i = <span class="number">10</span>;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="meta">#pragma mark - ViewController</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> createObserver];</div><div class="line">    </div><div class="line">    <span class="comment">// 发送消息</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createObserver &#123;</div><div class="line">    </div><div class="line">    Observer *observer = [[Observer alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>运行后的输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Init Observer</div><div class="line">handle notification</div></pre></td></tr></table></figure>
<p>我们可以看到<code>createObserver</code>中创建的<code>observer</code>并没有被释放。所以，使用<code>addObserverForName:object:queue:usingBlock:</code>一定要注意这个问题。</p>
<h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>与注册观察者相对应的，<code>NSNotificationCenter</code>为我们提供了两个移除观察者的方法。它们的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)notificationObserver</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)notificationObserver name:(<span class="built_in">NSString</span> *)notificationName object:(<span class="keyword">id</span>)notificationSender</div></pre></td></tr></table></figure>
<p>前一个方法会将<code>notificationObserver</code>从通知中心中移除，这样<code>notificationObserver</code>就无法再监听任何消息。而后一个会根据三个参数来移除相应的观察者。</p>
<p>这两个方法也有几点需要注意：</p>
<ol>
<li><p>由于注册观察者时(不管是哪个方法)，通知中心会维护一个观察者的弱引用，所以在释放对象时，要确保移除对象所有监听的通知。否则，可能会导致程序崩溃或一些莫名其妙的问题。</p>
</li>
<li><p>对于第二个方法，如果<code>notificationName</code>为nil，则会移除所有匹配<code>notificationObserver</code>和<code>notificationSender</code>的通知，同理<code>notificationSender</code>也是一样的。而如果<code>notificationName</code>和<code>notificationSender</code>都为nil，则其效果就与第一个方法是一样的了。大家可以试一下。</p>
</li>
<li><p>最有趣的应该是这两个方法的使用时机。<code>–removeObserver:</code>适合于在类的<code>dealloc</code>方法中调用，这样可以确保将对象从通知中心中清除；而在<code>viewWillDisappear:</code>这样的方法中，则适合于使用-<code>removeObserver:name:object:</code>方法，以避免不知情的情况下移除了不应该移除的通知观察者。例如，假设我们的<code>ViewController</code>继承自一个类库的某个<code>ViewController</code>类(假设为<code>SKViewController</code>吧)，可能<code>SKViewController</code>自身也监听了某些通知以执行特定的操作，但我们使用时并不知道。如果直接在<code>viewWillDisappear:</code>中调用<code>–removeObserver:</code>，则也会把父类监听的通知也给移除。</p>
<p>​</p>
<p>关于注册监听者，还有一个需要注意的问题是，每次调用<code>addObserver</code>时，都会在通知中心重新注册一次，即使是同一对象监听同一个消息，而不是去覆盖原来的监听。这样，当通知中心转发某一消息时，如果同一对象多次注册了这个通知的观察者，则会收到多个通知，如代码清单4所示：</p>
</li>
</ol>
<p><strong>代码清单4：同一对象多次注册同一消息</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"notification = %@"</span>, notification.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其输出结果如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">notification = TestNotification</div><div class="line">notification = TestNotification</div></pre></td></tr></table></figure>
<p>可以看到对象处理了两次通知。所以，如果我们需要在<code>viewWillAppear</code>监听一个通知时，一定要记得在对应的<code>viewWillDisappear</code>里面将观察者移除，否则就可能会出现上面的情况。</p>
<p>最后，再特别重点强调的非常重要的一点是，在释放对象前，一定要记住如果它监听了通知，一定要将它从通知中心移除。如果是用<code>addObserverForName:object:queue:usingBlock:</code>，也记得一定得移除这个匿名观察者。说白了就一句话，添加和移除要配对出现。</p>
<h2 id="post消息"><a href="#post消息" class="headerlink" title="post消息"></a>post消息</h2><p>注册了通知观察者，我们便可以随时随地的去<code>post</code>一个通知了(当然，如果闲着没事，也可以不注册观察者，<code>post</code>通知随便玩，只是没人理睬罢了)。<code>NSNotificationCenter</code>提供了三个方法来<code>post</code>一个通知，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- postNotification:</div><div class="line">– postNotificationName:object:</div><div class="line">– postNotificationName:object:userInfo:</div></pre></td></tr></table></figure>
<p>我们可以根据需要指定通知的发送者(<code>object</code>)并附带一些与通知相关的信息(<code>userInfo</code>)，当然这些发送者和<code>userInfo</code>可以封装在一个<code>NSNotification</code>对象中，由<code>- postNotification:</code>来发送。注意，<code>- postNotification</code>:的参数不能为空，否则会引发一个异常，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSNotificationCenter postNotification:]: notification is nil'</div></pre></td></tr></table></figure>
<p>每次<code>post</code>一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者。</p>
<p>另外，通知的发送与处理是同步的，在某个地方<code>post</code>一个消息时，会等到所有观察者对象执行完处理操作后，才回到<code>post</code>的地方，继续执行后面的代码。如代码清单5所示：</p>
<p><strong>代码清单5：通知的同步处理</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle notification"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>运行后输出结果是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">handle notification</div><div class="line"><span class="keyword">continue</span></div></pre></td></tr></table></figure>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>翻了好些资料，还有两个问题始终没有明确的答案。</p>
<p>首先就是通知中心是如何维护观察者对象的。可以明确的是，添加观察者时，通知中心没有对观察者做<code>retain</code>操作，即不会使观察者的引用计数加1。那通知中心维护的是观察者的<code>weak</code>引用呢还是<code>unsafe_unretained</code>引用呢？</p>
<p>个人认为可能是<code>unsafe_unretained</code>的引用，因为我们知道如果是<code>weak</code>引用，其所指的对象被释放后，这个引用会被置成nil。而实际情况是通知中心还会给这个对象发送消息，并引发一个异常。而如果向nil发送一个消息是不会导致异常的。</p>
<p>【非常感谢 <a href="http://weibo.com/u/2814972697" target="_blank" rel="external">@lv-pw</a>，上面这个问题在<a href="http://open.163.com/movie/2014/1/L/H/M9H7S9F1H_M9H801GLH.html" target="_blank" rel="external">《斯坦福大学公开课：iOS 7应用开发》的第5集</a>的第57分50秒中得到了解答：确实使用的是<code>unsafe_unretained</code>，老师的解释是，之所以使用<code>unsafe_unretained</code>，而不使用<code>weak</code>，是为了兼容老版本的系统。】</p>
<p>另外，我们知道<code>NSNotificationCenter</code>实现的是观察者模式，而且通常情况下消息在哪个线程被<code>post</code>，就在哪个线程被转发。而从上面的描述可以发现，</p>
<p><code>-addObserverForName:object:queue:usingBlock:</code>添加的匿名观察者可以在指定的队列中处理通知，那它的实现机制是什么呢？</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在我们的应用程序中，一个大的话题就是两个对象之间如何通信。我们需要根据对象之间的关系来确定采用哪一种通信方式。对象之间的通信方式主要有以下几种：</p>
<ol>
<li>直接方法调用</li>
<li><code>Target-Action</code></li>
<li><code>Delegate</code></li>
<li>回调(<code>block</code>)</li>
<li><code>KVO</code></li>
<li>通知</li>
</ol>
<p>一般情况下，我们可以根据以下两点来确定使用哪种方式：</p>
<ol>
<li>通信对象是一对一的还是一对多的</li>
<li>对象之间的耦合度，是强耦合还是松耦合</li>
</ol>
<p><code>Objective-C</code>中的通知由于其广播性及松耦合性，非常适合于大的范围内对象之间的通信(模块与模块，或一些框架层级)。通知使用起来非常方便，也正因为如此，所以容易导致滥用。所以在使用前还是需要多想想，是否有更好的方法来实现我们所需要的对象间通信。毕竟，通知机制会在一定程度上会影响到程序的性能。</p>
<p>对于使用<code>NSNotificationCenter</code>，最后总结一些小建议：</p>
<ol>
<li>在需要的地方使用通知。</li>
<li>注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。</li>
<li>尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每<code>post</code>一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。</li>
<li>记住通知的发送和处理是在同一个线程中。</li>
<li>使用<code>-addObserverForName:object:queue:usingBlock:</code>务必处理好内存问题，避免出现循环引用。</li>
<li><code>NSNotificationCenter</code>是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。</li>
</ol>
<p>最后，“<a href="http://weibo.com/u/1438670852" target="_blank" rel="external">@叶孤城___</a>”叶大大在微博中推荐了几篇文章，即参考中的4-7，值得细读一下。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/" target="_blank" rel="external">NSNotificationCenter Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationQueues.html" target="_blank" rel="external">Notification Programming Topics</a></li>
<li><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">NSNotification &amp; NSNotification​Center</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-1/" target="_blank" rel="external">NSNotificationCenter part 1: Receiving and sending notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-2/" target="_blank" rel="external">NSNotificationCenter part 2: Implementing the observer pattern with notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-3/" target="_blank" rel="external">NSNotificationCenter part 3: Unit testing notifications with OCMock</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-4/" target="_blank" rel="external">NSNotificationCenter part 4: Asynchronous notifications with NSNotificationQueue</a></li>
<li><a href="http://stackoverflow.com/questions/12699118/view-controller-dealloc-not-called-when-using-nsnotificationcenter-code-block-me" target="_blank" rel="external">View controller dealloc not called when using NSNotificationCenter code block method with ARC</a></li>
<li><a href="http://open.163.com/movie/2014/1/L/H/M9H7S9F1H_M9H801GLH.html" target="_blank" rel="external">《斯坦福大学公开课：iOS 7应用开发》第5集</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/14/nsnotification-and-multithreading/" itemprop="url">
                  Notification与多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-14T12:58:59+08:00" content="2015-03-14">
              2015-03-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。</p>
<p>先来看看官方的文档，是这样写的：</p>
<blockquote>
<p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p>
</blockquote>
<p>翻译过来是：</p>
<blockquote>
<p>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。</p>
</blockquote>
<p>也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：</p>
<p><strong>代码清单1：Notification的发送与处理</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test notification"</span>);</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">12.856</span> test[<span class="number">865</span>:<span class="number">45102</span>] current thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbb23412f30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">12.857</span> test[<span class="number">865</span>:<span class="number">45174</span>] current thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7fbb23552370</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">12.857</span> test[<span class="number">865</span>:<span class="number">45174</span>] test notification</div></pre></td></tr></table></figure>
<p>可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。</p>
<p>这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：</p>
<blockquote>
<p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p>
</blockquote>
<p>这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。</p>
<p>一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。</p>
<p>官方文档已经给出了示例代码，在此借用一下，以测试实际结果：</p>
<p><strong>代码清单2：在不同线程中post和转发一个Notification</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;         <span class="comment">// 通知队列</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;    <span class="comment">// 期望线程</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;      <span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;      <span class="comment">// 用于向期望线程发送信号的通信端口</span></div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    <span class="keyword">self</span>.notifications = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.notificationLock = [[<span class="built_in">NSLock</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</div><div class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.notificationPort.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 往当前线程的run loop添加端口源</span></div><div class="line">    <span class="comment">// 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop</span></div><div class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</div><div class="line">                                forMode:(__bridge <span class="built_in">NSString</span> *)kCFRunLoopCommonModes];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:<span class="string">@"TestNotification"</span> object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</div><div class="line">	</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.notificationLock lock];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</div><div class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</div><div class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</div><div class="line">        [<span class="keyword">self</span>.notificationLock unlock];</div><div class="line">        [<span class="keyword">self</span> processNotification:notification];</div><div class="line">        [<span class="keyword">self</span>.notificationLock lock];</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.notificationLock unlock];</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</div><div class="line">        <span class="comment">// Forward the notification to the correct thread.</span></div><div class="line">        [<span class="keyword">self</span>.notificationLock lock];</div><div class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</div><div class="line">        [<span class="keyword">self</span>.notificationLock unlock];</div><div class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</div><div class="line">                                   components:<span class="literal">nil</span></div><div class="line">                                         from:<span class="literal">nil</span></div><div class="line">                                     reserved:<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Process the notification here;</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"process notification"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>运行后，其输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">31.637</span> test[<span class="number">1474</span>:<span class="number">92483</span>] current thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ffa4070ed50</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">31.663</span> test[<span class="number">1474</span>:<span class="number">92483</span>] current thread = &lt;<span class="built_in">NSThread</span>: <span class="number">0x7ffa4070ed50</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-11</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">31.663</span> test[<span class="number">1474</span>:<span class="number">92483</span>] process notification</div></pre></td></tr></table></figure>
<p>可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。</p>
<p>这种实现方式的具体解析及其局限性大家可以参考官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="external">Delivering Notifications To Particular Threads</a>，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p>
<h2 id="NSNotificationCenter的线程安全性"><a href="#NSNotificationCenter的线程安全性" class="headerlink" title="NSNotificationCenter的线程安全性"></a>NSNotificationCenter的线程安全性</h2><p>苹果之所以采取通知中心在同一个线程中post和转发同一消息这一策略，应该是出于线程安全的角度来考量的。官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。原文在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank" rel="external">Threading Programming Guide</a>中，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">The following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.</div><div class="line">	</div><div class="line">NSArray</div><div class="line">...</div><div class="line">NSNotification</div><div class="line">NSNotificationCenter</div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们可以在任何线程中添加/删除通知的观察者，也可以在任何线程中post一个通知。</p>
<p>NSNotificationCenter在线程安全性方面已经做了不少工作了，那是否意味着我们可以高枕无忧了呢？再回过头来看看第一个例子，我们稍微改造一下，一点一点来：</p>
<p><strong>代码清单3：NSNotificationCenter的通用模式</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Observer</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        _poster = [[Poster alloc] init];</div><div class="line">        </div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>]</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle notification "</span>);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 其它地方</span></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">```	</div><div class="line">	</div><div class="line">上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：<span class="built_in">NSNotification</span>的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？</div><div class="line"></div><div class="line">我们再改造一下上面的代码：</div><div class="line"></div><div class="line">**代码清单<span class="number">4</span>：<span class="built_in">NSNotificationCenter</span>引发的线程安全问题**</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="meta">#pragma mark - Poster</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Poster</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Poster</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(postNotification) withObject:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)postNotification</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="meta">#pragma mark - Observer</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Observer</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    Poster  *_poster;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> i;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        _poster = [[Poster alloc] init];</div><div class="line">        </div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle notification begin"</span>);</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle notification end"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.i = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Observer dealloc"</span>);</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line"><span class="meta">#pragma mark - ViewController</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    __autoreleasing Observer *observer = [[Observer alloc] init];</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-14</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">41.286</span> <span class="built_in">SKTest</span>[<span class="number">932</span>:<span class="number">88791</span>] handle notification begin</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-14</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">41.291</span> <span class="built_in">SKTest</span>[<span class="number">932</span>:<span class="number">88713</span>] Observer dealloc</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-14</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">42.361</span> <span class="built_in">SKTest</span>[<span class="number">932</span>:<span class="number">88791</span>] handle notification end</div><div class="line">(lldb) </div><div class="line">	</div><div class="line"><span class="comment">// 程序在self.i = 10处抛出了"Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)"</span></div></pre></td></tr></table></figure>
<p>经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：</p>
<ol>
<li>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。</li>
<li>主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。</li>
<li>后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。</li>
</ol>
<p>当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。</p>
<p>那我们该怎么做呢？这里有一些好的建议：</p>
<ol>
<li>尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。</li>
<li>注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。</li>
<li>使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。</li>
<li>使用代理。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看<a href="http://inessential.com/2013/12/20/observers_and_thread_safety" target="_blank" rel="external">Observers and Thread Safety</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html" target="_blank" rel="external">Notification Programming Topics</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank" rel="external">Threading Programming Guide</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8489516" target="_blank" rel="external">NSNotification的几点说明</a></li>
<li><a href="http://lapcatsoftware.com/articles/nsnotificationcenter-is-threadsafe-not.html" target="_blank" rel="external">NSNotificationCenter is thread-safe NOT</a></li>
<li><a href="http://inessential.com/2013/12/20/observers_and_thread_safety" target="_blank" rel="external">Observers and Thread Safety</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/07/cocoa-uikit-uiresponder/" itemprop="url">
                  UIKit: UIResponder
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-07T18:54:23+08:00" content="2015-03-07">
              2015-03-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的<code>App</code>与用户进行交互，基本上是依赖于各种各样的事件。例如，用户点击界面上的按钮，我们需要触发一个按钮点击事件，并进行相应的处理，以给用户一个响应。<code>UIView</code>的三大职责之一就是处理事件，一个视图是一个事件响应者，可以处理点击等事件，而这些事件就是在<code>UIResponder</code>类中定义的。</p>
<p>一个<code>UIResponder</code>类为那些需要响应并处理事件的对象定义了一组接口。这些事件主要分为两类：触摸事件(<code>touch events</code>)和运动事件(<code>motion events</code>)。<code>UIResponder</code>类为每两类事件都定义了一组接口，这个我们将在下面详细描述。</p>
<p>在<code>UIKit</code>中，<code>UIApplication</code>、<code>UIView</code>、<code>UIViewController</code>这几个类都是直接继承自<code>UIResponder</code>类。另外<code>SpriteKit</code>中的<code>SKNode</code>也是继承自<code>UIResponder</code>类。因此UIKit中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。这些对象通常被称为响应对象，或者是响应者(以下我们统一使用响应者)。</p>
<p>本文将详细介绍一个<code>UIResponder</code>类提供的基本功能。不过在此之前，我们先来了解一下事件响应链机制。</p>
<h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><p>大多数事件的分发都是依赖响应链的。响应链是由一系列链接在一起的响应者组成的。一般情况下，一条响应链开始于第一响应者，结束于<code>application</code>对象。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。</p>
<p>那这里就会有三个问题：</p>
<ol>
<li>响应链是何时构建的</li>
<li>系统是如何确定第一响应者的</li>
<li>确定第一响应者后，系统又是按照什么样的顺序来传递事件的</li>
</ol>
<h3 id="构建响应链"><a href="#构建响应链" class="headerlink" title="构建响应链"></a>构建响应链</h3><p>我们都知道在一个App中，所有视图是按一定的结构组织起来的，即树状层次结构。除了根视图外，每个视图都有一个父视图；而每个视图都可以有0个或多个子视图。而在这个树状结构构建的同时，也构建了一条条的事件响应链。</p>
<h3 id="确定第一响应者"><a href="#确定第一响应者" class="headerlink" title="确定第一响应者"></a>确定第一响应者</h3><p>当用户触发某一事件(触摸事件或运动事件)后，<code>UIKit</code>会创建一个事件对象(<code>UIEvent</code>)，该对象包含一些处理事件所需要的信息。然后事件对象被放到一个事件队列中。这些事件按照先进先出的顺序来处理。当处理事件时，程序的<code>UIApplication</code>对象会从队列头部取出一个事件对象，将其分发出去。通常首先是将事件分发给程序的主<code>window</code>对象，对于触摸事件来讲，<code>window</code>对象会首先尝试将事件分发给触摸事件发生的那个视图上。这一视图通常被称为<code>hit-test</code>视图，而查找这一视图的过程就叫做<code>hit-testing</code>。</p>
<p>系统使用<code>hit-testing</code>来找到触摸下的视图，它检测一个触摸事件是否发生在相应视图对象的边界之内(即视图的<code>frame</code>属性，这也是为什么子视图如果在父视图的<code>frame</code>之外时，是无法响应事件的)。如果在，则会递归检测其所有的子视图。包含触摸点的视图层次架构中最底层的视图就是<code>hit-test</code>视图。在检测出<code>hit-test</code>视图后，系统就将事件发送给这个视图来进行处理。</p>
<p>我们通过一个示例来演示<code>hit-testing</code>的过程。图1是一个视图层次结构，</p>
<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image"></p>
<p>假设用户点击了视图E，系统按照以下顺序来查找<code>hit-test</code>视图：</p>
<ol>
<li>点击事件发生在视图A的边界内，所以检测子视图B和C；</li>
<li>点击事件不在视图B的边界内，但在视图C的边界范围内，所以检测子图片D和E；</li>
<li>点击事件不在视图D的边界内，但在视图E的边界范围内；</li>
</ol>
<p>视图E是包含触摸点的视图层次架构中最底层的视图(倒树结构)，所以它就是<code>hit-test</code>视图。</p>
<p><code>hit-test</code>视图可以最先去处理触摸事件，如果<code>hit-test</code>视图不能处理事件，则事件会沿着响应链往上传递，直到找到能处理它的视图。</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>最有机会处理事件的对象是<code>hit-test</code>视图或第一响应者。如果这两者都不能处理事件，<code>UIKit</code>就会将事件传递到响应链中的下一个响应者。每一个响应者确定其是否要处理事件或者是通过<code>nextResponder</code>方法将其传递给下一个响应者。这一过程一直持续到找到能处理事件的响应者对象或者最终没有找到响应者。</p>
<p>图2演示了这样一个事件传递的流程，</p>
<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="image"></p>
<p>当系统检测到一个事件时，将其传递给初始对象，这个对象通常是一个视图。然后，会按以下路径来处理事件(我们以左图为例)：</p>
<ol>
<li>初始视图(<code>initial view</code>)尝试处理事件。如果它不能处理事件，则将事件传递给其父视图。</li>
<li>初始视图的父视图(<code>superview</code>)尝试处理事件。如果这个父视图还不能处理事件，则继续将视图传递给上层视图。</li>
<li>上层视图(<code>topmost view</code>)会尝试处理事件。如果这个上层视图还是不能处理事件，则将事件传递给视图所在的视图控制器。</li>
<li>视图控制器会尝试处理事件。如果这个视图控制器不能处理事件，则将事件传递给窗口(<code>window</code>)对象。</li>
<li>窗口(<code>window</code>)对象尝试处理事件。如果不能处理，则将事件传递给单例<code>app</code>对象。</li>
<li>如果<code>app</code>对象不能处理事件，则丢弃这个事件。</li>
</ol>
<p>从上面可以看到，视图、视图控制器、窗口对象和<code>app</code>对象都能处理事件。另外需要注意的是，手势也会影响到事件的传递。</p>
<p>以上便是响应链的一些基本知识。有了这些知识，我们便可以来看看<code>UIResponder</code>提供给我们的一些方法了。</p>
<h2 id="管理响应链"><a href="#管理响应链" class="headerlink" title="管理响应链"></a>管理响应链</h2><p><code>UIResponder</code>提供了几个方法来管理响应链，包括让响应对象成为第一响应者、放弃第一响应者、检测是否是第一响应者以及传递事件到下一响应者的方法，我们分别来介绍一下。</p>
<p>上面提到在响应链中负责传递事件的方法是<code>nextResponder</code>，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIResponder</span> *)nextResponder</div></pre></td></tr></table></figure>
<p><code>UIResponder</code>类并不自动保存或设置下一个响应者，该方法的默认实现是返回<code>nil</code>。子类的实现必须重写这个方法来设置下一响应者。<code>UIView</code>的实现是返回管理它的<code>UIViewController</code>对象(如果它有)或者其父视图。而<code>UIViewController</code>的实现是返回它的视图的父视图；<code>UIWindow</code>的实现是返回<code>app</code>对象；而<code>UIApplication</code>的实现是返回nil。所以，响应链是在构建视图层次结构时生成的。</p>
<p>一个响应对象可以成为第一响应者，也可以放弃第一响应者。为此，<code>UIResponder</code>提供了一系列方法，我们分别来介绍一下。</p>
<p>如果想判定一个响应对象是否是第一响应者，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isFirstResponder</div></pre></td></tr></table></figure>
<p>如果我们希望将一个响应对象作为第一响应者，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)becomeFirstResponder</div></pre></td></tr></table></figure>
<p>如果对象成为第一响应者，则返回YES；否则返回NO。默认实现是返回YES。子类可以重写这个方法来更新状态，或者来执行一些其它的行为。</p>
<p>一个响应对象只有在当前响应者能放弃第一响应者状态(<code>canResignFirstResponder</code>)且自身能成为第一响应者(<code>canBecomeFirstResponder</code>)时才会成为第一响应者。</p>
<p>这个方法相信大家用得比较多，特别是在希望<code>UITextField</code>获取焦点时。另外需要注意的是只有当视图是视图层次结构的一部分时才调用这个方法。如果视图的<code>window</code>属性不为空时，视图才在一个视图层次结构中；如果该属性为<code>nil</code>，则视图不在任何层次结构中。</p>
<p>上面提到一个响应对象成为第一响应者的一个前提是它可以成为第一响应者，我们可以使用<code>canBecomeFirstResponder</code>方法来检测，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</div></pre></td></tr></table></figure>
<p>需要注意的是我们不能向一个不在视图层次结构中的视图发送这个消息，其结果是未定义的。</p>
<p>与上面两个方法相对应的是响应者放弃第一响应者的方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)resignFirstResponder</div><div class="line">- (<span class="built_in">BOOL</span>)canResignFirstResponder</div></pre></td></tr></table></figure>
<p><code>resignFirstResponder</code>默认也是返回YES。需要注意的是，如果子类要重写这个方法，则在我们的代码中必须调用<code>super</code>的实现。</p>
<p><code>canResignFirstResponder</code>默认也是返回YES。不过有些情况下可能需要返回NO，如一个输入框在输入过程中可能需要让这个方法返回NO，以确保在编辑过程中能始终保证是第一响应者。</p>
<h2 id="管理输入视图"><a href="#管理输入视图" class="headerlink" title="管理输入视图"></a>管理输入视图</h2><p>所谓的输入视图，是指当对象为第一响应者时，显示另外一个视图用来处理当前对象的信息输入，如<code>UITextView</code>和<code>UITextField</code>两个对象，在其成为第一响应者是，会显示一个系统键盘，用来输入信息。这个系统键盘就是输入视图。输入视图有两种，一个是<code>inputView</code>，另一个是<code>inputAccessoryView</code>。这两者如图3所示：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/kuku/b.jpg" alt="image"></p>
<p>与<code>inputView</code>相关的属性有如下两个，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">UIView</span> *inputView</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">UIInputViewController</span> *inputViewController</div></pre></td></tr></table></figure>
<p>这两个属性提供一个视图(或视图控制器)用于替代为<code>UITextField</code>和<code>UITextView</code>弹出的系统键盘。我们可以在子类中将这两个属性重新定义为读写属性来设置这个属性。如果我们需要自己写一个键盘的，如为输入框定义一个用于输入身份证的键盘(只包含0-9和X)，则可以使用这两个属性来获取这个键盘。</p>
<p>与<code>inputView</code>类似，<code>inputAccessoryView</code>也有两个相关的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">UIView</span> *inputAccessoryView</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">UIInputViewController</span> *inputAccessoryViewController</div></pre></td></tr></table></figure>
<p>设置方法与前面相同，都是在子类中重新定义为可读写属性，以设置这个属性。</p>
<p>另外，<code>UIResponder</code>还提供了以下方法，在对象是第一响应者时更新输入和访问视图，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)reloadInputViews</div></pre></td></tr></table></figure>
<p>调用这个方法时，视图会立即被替换，即不会有动画之类的过渡。如果当前对象不是第一响应者，则该方法是无效的。</p>
<h2 id="响应触摸事件"><a href="#响应触摸事件" class="headerlink" title="响应触摸事件"></a>响应触摸事件</h2><p><code>UIResponder</code>提供了如下四个大家都非常熟悉的方法来响应触摸事件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当一个或多个手指触摸到一个视图或窗口</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 当与事件相关的一个或多个手指在视图或窗口上移动时</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 当一个或多个手指从视图或窗口上抬起时</span></div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 当一个系统事件取消一个触摸事件时</span></div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>这四个方法默认都是什么都不做。不过，<code>UIKit</code>中<code>UIResponder</code>的子类，尤其是<code>UIView</code>，这几个方法的实现都会把消息传递到响应链上。因此，为了不阻断响应链，我们的子类在重写时需要调用父类的相应方法；而不要将消息直接发送给下一响应者。</p>
<p>默认情况下，多点触摸是被禁用的。为了接受多点触摸事件，我们需要设置响应视图的<code>multipleTouchEnabled</code>属性为YES。</p>
<h2 id="响应移动事件"><a href="#响应移动事件" class="headerlink" title="响应移动事件"></a>响应移动事件</h2><p>与触摸事件类似，<code>UIResponder</code>也提供了几个方法来响应移动事件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移动事件开始</span></div><div class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 移动事件结束</span></div><div class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 取消移动事件</span></div><div class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>与触摸事件不同的是，运动事件只有开始与结束操作；它不会报告类似于晃动这样的事件。这几个方法的默认操作也是什么都不做。不过，<code>UIKit</code>中<code>UIResponder</code>的子类，尤其是<code>UIView</code>，这几个方法的实现都会把消息传递到响应链上。</p>
<h2 id="响应远程控制事件"><a href="#响应远程控制事件" class="headerlink" title="响应远程控制事件"></a>响应远程控制事件</h2><p>远程控制事件来源于一些外部的配件，如耳机等。用户可以通过耳机来控制视频或音频的播放。接收响应者对象需要检查事件的子类型来确定命令(如播放，子类型为<code>UIEventSubtypeRemoteControlPlay</code>)，然后进行相应处理。</p>
<p>为了响应远程控制事件，<code>UIResponder</code>提供了以下方法，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>我们可以在子类中实现该方法，来处理远程控制事件。不过，为了允许分发远程控制事件，我们必须调用<code>UIApplication</code>的<code>beginReceivingRemoteControlEvents</code>方法；而如果要关闭远程控制事件的分发，则调用<code>endReceivingRemoteControlEvents</code>方法。</p>
<h2 id="获取Undo管理器"><a href="#获取Undo管理器" class="headerlink" title="获取Undo管理器"></a>获取Undo管理器</h2><p>默认情况下，程序的每一个<code>window</code>都有一个undo管理器，它是一个用于管理undo和redo操作的共享对象。然而，响应链上的任何对象的类都可以有自定义undo管理器。例如，<code>UITextField</code>的实例的自定义管理器在文件输入框放弃第一响应者状态时会被清理掉。当需要一个undo管理器时，请求会沿着响应链传递，然后<code>UIWindow</code>对象会返回一个可用的实例。</p>
<p><code>UIResponder</code>提供了一个只读方法来获取响应链中共享的undo管理器，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUndoManager</span> *undoManager</div></pre></td></tr></table></figure>
<p>我们可以在自己的视图控制器中添加undo管理器来执行其对应的视图的undo和redo操作。</p>
<h2 id="验证命令"><a href="#验证命令" class="headerlink" title="验证命令"></a>验证命令</h2><p>在我们的应用中，经常会处理各种菜单命令，如文本输入框的”复制”、”粘贴”等。<code>UIResponder</code>为此提供了两个方法来支持此类操作。首先使用以下方法可以启动或禁用指定的命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</div></pre></td></tr></table></figure>
<p>该方法默认返回YES，我们的类可以通过某种途径处理这个命令，包括类本身或者其下一个响应者。子类可以重写这个方法来开启菜单命令。例如，如果我们希望菜单支持”<code>Copy</code>“而不支持”<code>Paser</code>“，则在我们的子类中实现该方法。需要注意的是，即使在子类中禁用某个命令，在响应链上的其它响应者也可能会处理这些命令。</p>
<p>另外，我们可以使用以下方法来获取可以响应某一行为的接收者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)targetForAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</div></pre></td></tr></table></figure>
<p>在对象需要调用一个<code>action</code>操作时调用该方法。默认的实现是调用<code>canPerformAction:withSender:</code>方法来确定对象是否可以调用<code>action</code>操作。如果可以，则返回对象本身，否则将请求传递到响应链上。如果我们想要重写目标的选择方式，则应该重写这个方法。下面这段代码演示了一个文本输入域禁用拷贝/粘贴操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)targetForAction:(SEL)action withSender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController];</div><div class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(selectAll:) || action == <span class="keyword">@selector</span>(paste:) ||action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(cut:)) &#123;</div><div class="line">        <span class="keyword">if</span> (menuController) &#123;</div><div class="line">            [<span class="built_in">UIMenuController</span> sharedMenuController].menuVisible = <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> targetForAction:action withSender:sender];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="访问快捷键命令"><a href="#访问快捷键命令" class="headerlink" title="访问快捷键命令"></a>访问快捷键命令</h2><p>我们的应用可以支持外部设备，包括外部键盘。在使用外部键盘时，使用快捷键可以大大提高我们的输入效率。因此从iOS7后，<code>UIResponder</code>类新增了一个只读属性<code>keyCommands</code>，来定义一个响应者支持的快捷键，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *keyCommands</div></pre></td></tr></table></figure>
<p>一个支持硬件键盘命令的响应者对象可以重新定义这个方法并使用它来返回一个其所支持快捷键对象(<code>UIKeyCommand</code>)的数组。每一个快捷键命令表示识别的键盘序列及响应者的操作方法。</p>
<p>我们用这个方法返回的快捷键命令数组被用于整个响应链。当与快捷键命令对象匹配的快捷键被按下时，<code>UIKit</code>会沿着响应链查找实现了响应行为方法的对象。它调用找到的第一个对象的方法并停止事件的处理。</p>
<h2 id="管理文本输入模式"><a href="#管理文本输入模式" class="headerlink" title="管理文本输入模式"></a>管理文本输入模式</h2><p>文本输入模式标识当响应者激活时的语言及显示的键盘。<code>UIResponder</code>为此定义了一个属性来返回响应者对象的文本输入模式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">UITextInputMode</span> *textInputMode</div></pre></td></tr></table></figure>
<p>对于响应者而言，系统通常显示一个基于用户语言设置的键盘。我们可以重新定义这个属性，并让它返回一个不同的文本输入模式，以让我们的响应者使用一个特定的键盘。用户在响应者被激活时仍然可以改变键盘，在切换到另一个响应者时，可以再恢复到指定的键盘。</p>
<p>如果我们想让<code>UIKit</code>来跟踪这个响应者的文本输入模式，我们可以通过<code>textInputContextIdentifier</code>属性来设置一个标识，该属性的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *textInputContextIdentifier</div></pre></td></tr></table></figure>
<p>该标识指明响应者应保留文本输入模式的信息。在跟踪模式下，任何对文本输入模式的修改都会记录下来，当响应者激活时再用于恢复处理。</p>
<p>为了从程序的<code>user default</code>中清理输入模式信息，<code>UIResponder</code>定义了一个类方法，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)clearTextInputContextIdentifier:(<span class="built_in">NSString</span> *)identifier</div></pre></td></tr></table></figure>
<p>调用这个方法可以从程序的<code>user default</code>中移除与指定标识相关的所有文本输入模式。移除这些信息会让响应者重新使用默认的文本输入模式。</p>
<h2 id="支持User-Activities"><a href="#支持User-Activities" class="headerlink" title="支持User Activities"></a>支持User Activities</h2><p>从iOS 8起，苹果为我们提供了一个非常棒的功能，即<code>Handoff</code>。使用这一功能，我们可以在一部iOS设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。<code>Handoff</code>的基本思想是用户在一个应用里所做的任何操作都可以看作是一个<code>Activity</code>，一个<code>Activity</code>可以和一个特定<code>iCloud</code>用户的多台设备关联起来。在编写一个支持<code>Handoff</code>的应用时，会有以下三个交互事件：</p>
<ol>
<li>为将在另一台设备上继续做的事创建一个新的<code>User Activity</code>；</li>
<li>当需要时，用新的数据更新已有的<code>User Activity</code>；</li>
<li>把一个<code>User Activity</code>传递到另一台设备上。</li>
</ol>
<p>为了支持这些交互事件，在iOS 8后，<code>UIResponder</code>类新增了几个方法，我们在此不讨论这几个方法的实际使用，想了解更多的话，可以参考<a href="http://www.cocoachina.com/ios/20150115/10926.html" target="_blank" rel="external">iOS 8 Handoff 开发指南</a>。我们在此只是简单描述一下这几个方法。</p>
<p>在<code>UIResponder</code>中，已经为我们提供了一个<code>userActivity</code>属性，它是一个<code>NSUserActivity</code>对象。因此我们在<code>UIResponder</code>的子类中不需要再去声明一个<code>userActivity</code>属性，直接使用它就行。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSUserActivity</span> *userActivity</div></pre></td></tr></table></figure>
<p>由<code>UIKit</code>管理的<code>User Activities</code>会在适当的时间自动保存。一般情况下，我们可以重写<code>UIResponder</code>类的<code>updateUserActivityState:</code>方法来延迟添加表示<code>User Activity</code>的状态数据。当我们不再需要一个<code>User Activity</code>时，我们可以设置<code>userActivity</code>属性为nil。任何由<code>UIKit</code>管理的<code>NSUserActivity</code>对象，如果它没有相关的响应者，则会自动失效。</p>
<p>另外，多个响应者可以共享一个<code>NSUserActivity</code>实例。</p>
<p>上面提到的<code>updateUserActivityState:</code>是用于更新给定的<code>User Activity</code>的状态。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateUserActivityState:(<span class="built_in">NSUserActivity</span> *)activity</div></pre></td></tr></table></figure>
<p>子类可以重写这个方法来按照我们的需要更新给定的<code>User Activity</code>。我们需要使用<code>NSUserActivity</code>对象的<code>addUserInfoEntriesFromDictionary:</code>方法来添加表示用户<code>Activity</code>的状态。</p>
<p>在我们修改了<code>User Activity</code>的状态后，如果想将其恢复到某个状态，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)restoreUserActivityState:(<span class="built_in">NSUserActivity</span> *)activity</div></pre></td></tr></table></figure>
<p>子类可以重写这个方法来使用给定<code>User Activity</code>的恢复响应者的状态。系统会在接收到数据时，将数据传递给<code>application:continueUserActivity:restorationHandler:</code>以做处理。我们重写时应该使用存储在<code>user activity</code>的<code>userInfo</code>字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class" target="_blank" rel="external">UIResponder Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html" target="_blank" rel="external">Event Handling Guide for iOS</a></li>
<li><a href="http://www.cnblogs.com/kuku/archive/2011/11/12/2246389.html" target="_blank" rel="external">iOS UIResponder 学习笔记</a></li>
<li><a href="http://firestudio.cn/blog/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/" target="_blank" rel="external">如何让你的iOS7应用支持键盘快捷键</a></li>
<li><a href="http://www.cocoachina.com/ios/20150115/10926.html" target="_blank" rel="external">iOS 8 Handoff 开发指南</a></li>
<li><a href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">iOS 8 Handoff Tutorial</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/01/translate-ios-8-handoff-tutorial/" itemprop="url">
                  iOS 8 Handoff Tutorial
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-01T12:33:51+08:00" content="2015-03-01">
              2015-03-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Soheil Azarpour</code>发表于<code>raywenderlich</code>，地址是<a href="http://www.raywenderlich.com/84174/ios-8-handoff-tutorial" target="_blank" rel="external">iOS 8 Handoff Tutorial</a></p>
<p><code>Handoff</code>是<code>iOS 8</code>和<code>OS X Yosemite</code>中的一个新特性。它让我们在不同的设备间切换时，可以不间断地继续一个<code>Activity</code>，而不需要重新配置任何设备。</p>
<p>我们可以为在<code>iOS 8</code>和<code>Yosemite</code>上的应用添加<code>Handoff</code>特性。在这篇指南中，我们将学习<code>Handoff</code>的基本功能和如何在非基于文档的<code>app</code>中使用<code>Handoff</code>。</p>
<h2 id="Handoff概览"><a href="#Handoff概览" class="headerlink" title="Handoff概览"></a>Handoff概览</h2><p>在开始写代码前，我们需要先来了解一下<code>handoff</code>的一些基本概念。</p>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p><code>Handoff</code>不仅可以将当前的<code>activity</code>从一个<code>iOS</code>设备传递到<code>OS X</code>设备，还可以将<code>activity</code>在不同的<code>iOS</code>设备传递。目前在模拟器上还不能使用<code>Handoff</code>功能，所以需要在<code>iOS</code>设备上运行我们的实例。</p>
<h4 id="设备兼容性：iOS"><a href="#设备兼容性：iOS" class="headerlink" title="设备兼容性：iOS"></a>设备兼容性：iOS</h4><p>为了查看我们的<code>iOS</code>设备是否支持<code>handoff</code>功能，我们可以查看“设置”-&gt;“通用”列表。如果在列表中看到“Handoff与建议的应用程序”，则设备具备<code>Handoff</code>功能。以下截图显示了<code>iPhone 5s</code>(具备<code>Handoff</code>功能)和<code>iPad3</code>(不具备<code>Handoff</code>功能)的对比：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/settings_screenshots-436x320.jpg" alt="image"></p>
<p><code>Handoff</code>功能依赖于以下几点：</p>
<ol>
<li>一个<code>iCloud</code>账户：我们必须在希望使用<code>Handoff</code>功能的多台设备上登录同一个<code>iCloud</code>账户。</li>
<li>低功耗蓝牙(<code>Bluetooth LE 4.0</code>)：<code>Handoff</code>是通过低功耗蓝牙来广播<code>activities</code>的，所以广播设备和接收设备都必须支持<code>Bluetooth LE 4.0</code>。</li>
<li><code>iCloud</code>配对：设备必须已经通过<code>iCloud</code>配对。当在支持<code>Handoff</code>的设备上登录<code>iCloud</code>账户后，每台设备都会与其它支持<code>Handoff</code>的设备进行配对。</li>
</ol>
<p>此时，我们需要确保已经使用同一<code>iCloud</code>账号在两台支持<code>Handoff</code>功能且运行<code>iOS 8+</code>系统的设备上登录了。(译者注：具体配置可以参考<a href="https://support.google.com/chrome/answer/6153783?hl=zh-Hans" target="_blank" rel="external">在 Chrome（iOS 版）中使用 Handoff</a>)</p>
<h3 id="User-Activities"><a href="#User-Activities" class="headerlink" title="User Activities"></a>User Activities</h3><p><code>Handoff</code>是基于<code>User Activity</code>的。<code>User Activity</code>是一个独立的信息集合单位，可以不依赖于任何其它信息而进行传输(<code>be handed off</code>)。</p>
<p><code>NSUserActivity</code>对象表示一个<code>User Activity</code>实例。它封装了程序的一些状态，这些状态可以在其它设备相关的程序中继续使用。</p>
<p>有三种方法和一个<code>NSUserActivity</code>对象交互：</p>
<p>1) 创建一个<code>user activity</code>：原始应用程序创建一个<code>NSUserActivity</code>实例并调用<code>becomeCurrent()</code>以开启一个广播进程。下面是一个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="string">"com.razeware.shopsnap.view"</span>)</div><div class="line">activity.title = <span class="string">"Viewing"</span></div><div class="line">activity.userInfo = [<span class="string">"shopsnap.item.key"</span>: [<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Banana"</span>]]</div><div class="line"><span class="keyword">self</span>.userActivity = activity;</div><div class="line"><span class="keyword">self</span>.userActivity?.becomeCurrent()</div></pre></td></tr></table></figure>
<p>我们可以使用<code>NSUserActivity</code>的<code>userInfo</code>字典来传递本地数据类型对象或可编码的自定义对象以将其传输到接收设备。本地数据类型包括<code>NSArray</code>, <code>NSData</code>, <code>NSDate</code>, <code>NSDictionary</code>, <code>NSNull</code>, <code>NSNumber</code>, <code>NSSet</code>, <code>NSString</code>, <code>NSUUID</code>和<code>NSURL</code>。通过<code>NSURL</code>可能会有点棘手。在使用<code>NSURL</code>前可以先参考一下下面的“最佳实践”一节。</p>
<p>2) 更新<code>user activity</code>：一旦一个<code>NSUserActivity</code>成为当前的<code>activity</code>，则<code>iOS</code>会在最上层的视图控制器中调用<code>updateUserActivityState(activity:)</code>方法，以让我们有机会来更新<code>user activity</code>。下面是一个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> activityListItems = <span class="comment">// ... get updated list of items</span></div><div class="line">    activity.addUserInfoEntriesFromDictionary([<span class="string">"shopsnap.item.key"</span>: activityListItems])</div><div class="line">    <span class="keyword">super</span>.updateUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意我们不要将<code>userInfo</code>设置为一个新的字典或直接更新它，而是应该使用便捷方法<code>addUserInfoEntriesFromDictionary()</code>。</p>
<p>在下文中，我们将学习如何按需求强制刷新<code>user activity</code>，或者是在程序的<code>app delegate</code>级别来获取一个相似功能的回调。</p>
<p>3) 接收<code>user activity</code>：当我们的接收程序以<code>Handoff</code>的方式启动时，程序代理会调用<code>application(:willContinueUserActivityWithType:)</code>方法。注意这个方法的参数不是<code>NSUserActivity</code>对象，因为接收程序在下载并传递<code>NSUserActivity</code>数据需要花费一定的时间。在<code>user activity</code>已经被下载完成后，会调用以下的回调函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication!, </span></span></div><div class="line">                 continueUserActivity userActivity: NSUserActivity!,</div><div class="line">                 restorationHandler: <span class="params">(<span class="params">([AnyObject]!)</span></span> -&gt; <span class="type">Void</span>)!) </div><div class="line">                 -&gt; <span class="type">Bool</span> &#123;</div><div class="line"> </div><div class="line">    <span class="comment">// Do some checks to make sure you can proceed</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> window = <span class="keyword">self</span>.window &#123;</div><div class="line">        window.rootViewController?.restoreUserActivityState(userActivity)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以使用存储在<code>NSUserActivity</code>对象中的数据来重新创建用户的<code>activity</code>。在这里，我们更新我们的应用以继续相关的<code>activity</code>。</p>
<h3 id="Activity类型"><a href="#Activity类型" class="headerlink" title="Activity类型"></a>Activity类型</h3><p>当创建一个<code>user activity</code>后，我们必须为其指定一个<code>activity</code>类型。一个<code>activity</code>类型是一个简单的唯一字符串，通常使用反转<code>DNS</code>语义，如<code>com.razeware.shopsnap.view</code>。</p>
<p>每一个可以接收<code>user activity</code>的程序都必须声明其可接收的<code>activity</code>类型。这类似于在程序中声明支持的<code>URL</code>方案(<code>URL schemes</code>)。对于非基于文本的程序，<code>activity</code>类型需要在<code>Info.plist</code>文件中定义，其键值为<code>NSUserActivityTypes</code>，如下所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/image10-38-480x259.png" alt="image"></p>
<p>对于支持一个给定<code>activity</code>的程序来说，需要满足三个要求：</p>
<ol>
<li>相同的组：两个程序都必须源于使用同一开发者组<code>ID(developer Team ID)</code>的开发者。</li>
<li>相同的<code>activity</code>类型：发送程序创建某一<code>activity</code>类型的<code>user activity</code>，接收程序必须有相应类型的<code>NSUserActivityTypes</code>入口。</li>
<li>签约：两个程序必须通过<code>App store</code>来发布或使用同一开发者账号来签约。</li>
</ol>
<p>现在我们已经学习了<code>user activities</code>和<code>activity</code>类型的基础知识，接下来让我们来看一个实例。</p>
<h2 id="启动工程"><a href="#启动工程" class="headerlink" title="启动工程"></a>启动工程</h2><p>本指南的启动工程可以在“<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Starter.zip" target="_blank" rel="external">启动工程</a>”中下载。下载后，使用<code>Xcode</code>打开工程并在<code>iPhone</code>模拟器中运行。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/App_Screenshots-700x412.jpg" alt="image"></p>
<p>工程名是<code>ShopSnap</code>，我们可以在这个程序中构建一个简单的购物清单。一个购物项由一个字符串表示，然后我们将购物项存储在一个字符串的数组中。点击+按钮添加一个新的项目到清单中，而轻扫可以移除项目。</p>
<p>我们将在程序中定义两个独立的<code>user activity</code>：</p>
<ol>
<li>查看清单。如果用户当前正在查看清单，我们将传输整个数组。</li>
<li>添加或编译项目。如果用户当前正在添加新的项目，我们将传递一个单一项目的“编辑”<code>activity</code>。</li>
</ol>
<h3 id="设置开发组"><a href="#设置开发组" class="headerlink" title="设置开发组"></a>设置开发组</h3><p>为了让<code>Handoff</code>工作，发送和接收<code>app</code>都必须使用相同的开发组来签约。由于这个示例程序即是发送者也是接收者，所以这很简单！</p>
<p>选择<code>ShopSnap</code>工程，在“通用”选项卡中，在”<code>Team</code>“中选择自己的开发组：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/image15-49-700x232.png" alt="image"></p>
<p>在支持<code>Handoff</code>的设备中编译并运行程序，以确保运行正常，然后继续。</p>
<h3 id="配置activity类型"><a href="#配置activity类型" class="headerlink" title="配置activity类型"></a>配置activity类型</h3><p>接下来是配置程序所支持的<code>activity</code>类型。打开<code>&quot;Supporting Files\Info.plist&quot;</code>，点击<code>&quot;Information Property List&quot;</code>旁边的”+”按钮，在<code>&quot;Information Property List&quot;</code>中添加一个新的选项：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image16-52-480x268.png" alt="image"></p>
<p>键名为<code>&quot;NSUserActivityTypes&quot;</code>，类型设备为数组类型，如下所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image17-55-480x233.png" alt="image"></p>
<p>在<code>NSUserActivityTypes</code>下添加两项并设置类型为字符串。<code>Item 0</code>的值为<code>com.razeware.shopsnap.view</code>，<code>Item 1</code>的值为<code>com.razeware.shopsnap.edit</code>。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image18-58-480x85.png" alt="image"></p>
<p>这些任意的<code>activity</code>类型对于我们的程序来说是特定和唯一的。因为我们将在程序的不同地方引用它们，所以在独立的文件中将其添加为常量是一种好的实践。</p>
<p>在工程导航中右键点击<code>ShopSnap</code>组，选择<code>&quot;New File \ iOS \ Source \ Swift File&quot;</code>。将文件命名为<code>Constants.swift</code>并确保新类被添加到<code>ShopSnap target</code>中。</p>
<p>在类中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="type">ActivityTypeView</span> = <span class="string">"com.razeware.shopsnap.view"</span></div><div class="line"><span class="keyword">let</span> <span class="type">ActivityTypeEdit</span> = <span class="string">"com.razeware.shopsnap.edit"</span></div><div class="line"> </div><div class="line"><span class="keyword">let</span> <span class="type">ActivityItemsKey</span> = <span class="string">"shopsnap.items.key"</span></div><div class="line"><span class="keyword">let</span> <span class="type">ActivityItemKey</span>  = <span class="string">"shopsnap.item.key"</span></div></pre></td></tr></table></figure>
<p>然后我们就可以使用这两个<code>activity</code>类型的常量。同时我们定义一些用于<code>user activity</code>的<code>userInfo</code>字典的键名字符串。</p>
<h3 id="快速端到端测试"><a href="#快速端到端测试" class="headerlink" title="快速端到端测试"></a>快速端到端测试</h3><p>让我们来运行一个快速端到端测试以确保设备可以正确地通信。</p>
<p>打开<code>ListViewController.swift</code>并添加以下两个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startUserActivity</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="type">ActivityTypeView</span>)</div><div class="line">    activity.title = <span class="string">"Viewing Shopping List"</span></div><div class="line">    activity.userInfo = [<span class="type">ActivityItemsKey</span>: [<span class="string">"Ice cream"</span>, <span class="string">"Apple"</span>, <span class="string">"Nuts"</span>]]</div><div class="line">    userActivity = activity</div><div class="line">    userActivity?.becomeCurrent()</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 2.</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    activity.addUserInfoEntriesFromDictionary([<span class="type">ActivityItemsKey</span>: [<span class="string">"Ice cream"</span>, <span class="string">"Apple"</span>, <span class="string">"Nuts"</span>]])</div><div class="line">    <span class="keyword">super</span>.updateUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过硬编码一个<code>user activity</code>来快速测试，以确保我们可以在另一端正常接收。</p>
<p>上面的代码做了以下两件事：</p>
<ol>
<li><code>startUserActivity()</code>是一个辅助函数，它使用一个硬编码的购物清单来创建了一个<code>NSUserActivity</code>实例。然后调用<code>becomeCurrent()</code>来广播这个<code>activity</code>。</li>
<li>在调用<code>becomeCurrent()</code>后，系统将定期调用<code>updateUserActivityState()</code>。<code>UIViewController</code>从<code>UIResponder</code>类中继承了这个方法，我们应该重写它来更新我们的<code>userActivity</code>的状态。在这里，我们像前面一样使用硬编码来更新购物清单。注意，我们应该使用<code>addUserInfoEntriesFromDictionary</code>方法来修改<code>NSUserActivity的userInfo</code>字典。我们应该总是在方法的结尾调用<code>super.updateUserActivityState()</code>。</li>
</ol>
<p>注意，我们只需要调用上面的起始方法。在<code>viewDidLoad()</code>起始行下面添加以下代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startUserActivity()</div></pre></td></tr></table></figure>
<p>开始广播至少需要以上步骤。现在来看看接收者。打开AppDelegate.swift并添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication!, </span></span></div><div class="line">                 continueUserActivity userActivity: NSUserActivity!, </div><div class="line">                 restorationHandler: <span class="params">(<span class="params">([AnyObject]!)</span></span> -&gt; <span class="type">Void</span>)!) </div><div class="line">                 -&gt; <span class="type">Bool</span> &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> userInfo = userActivity.userInfo <span class="keyword">as</span> <span class="type">NSDictionary</span></div><div class="line">    <span class="built_in">println</span>(<span class="string">"Received a payload via handoff: <span class="subst">\(userInfo)</span>"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AppDelegate</code>中的这个方法在所有事情都准备好，且一个<code>userActivity</code>被成功传送后调用。在这里我们简单打印<code>userActivity</code>中的<code>userInfo</code>字典。我们返回<code>true</code>来标识我们处理了<code>user activity</code>。</p>
<p>让我们来试试！要想在两台设备中正常工作，还需要做一些协调工作，所以还得仔细跟着。</p>
<ol>
<li>在第一台设备上安装并运行程序。</li>
<li>在第二台设备上安装并运行程序。确保在<code>Xcode</code>中调用程序以便我们能看到打印输出。</li>
<li>按下电源按钮让第二台设备休眠。在同一台设备上，按下<code>Home</code>键。如果所有事件都正常运行，我们应该可以看到<code>ShopSnap</code>程序的<code>icon</code>显示在屏幕的左下角上。从这里我们可以启动程序，然后在<code>Xcode</code>控制台可以看到以下的日志信息：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="type">Received</span> a payload via handoff: &#123;</div><div class="line">    <span class="string">"shopsnap.items.key"</span> = (</div><div class="line">    <span class="string">"Ice cream"</span>,</div><div class="line">    <span class="type">Apple</span>,</div><div class="line">    <span class="type">Nuts</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在锁屏下没有看到程序的<code>icon</code>，则在源设备上关闭并重新打开程序。这将强制系统重新广播信息。同时确认一下设备的控制台以查看是否有来自于<code>Handoff</code>的错误消息。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image20-63-180x320.png" alt="image"></p>
<h2 id="创建一个新的Activity"><a href="#创建一个新的Activity" class="headerlink" title="创建一个新的Activity"></a>创建一个新的Activity</h2><p>现在我们有一个基本上可以工作的<code>Handoff</code>程序，是时候来扩展它了。打开<code>ListViewController.swift</code>，更新<code>startUserActivity()</code>方法，这次我们传入实际的购物清单以代码硬编码。使用以下代码来更新方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startUserActivity</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="type">ActivityTypeView</span>)</div><div class="line">    activity.title = <span class="string">"Viewing Shopping List"</span></div><div class="line">    activity.userInfo = [<span class="type">ActivityItemsKey</span>: items]</div><div class="line">    userActivity = activity</div><div class="line">    userActivity?.becomeCurrent()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，更新<code>ListViewController.swift</code>的<code>updateUserActivityState(activity:)</code>方法，传递购物清单数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    activity.addUserInfoEntriesFromDictionary([<span class="type">ActivityItemsKey</span>: items])</div><div class="line">    <span class="keyword">super</span>.updateUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，更新<code>ListViewController.swift</code>中的<code>viewDidLoad()</code>，在从前面的代码中成功获取到清单后开启<code>userActivity</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    title = <span class="string">"Shopping List"</span></div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> weakSelf = <span class="keyword">self</span></div><div class="line">    <span class="type">PersistentStore</span>.defaultStore().fetchItems(&#123; (items:[<span class="type">String</span>]) <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> unwrapped = weakSelf &#123;</div><div class="line">            unwrapped.items = items</div><div class="line">            unwrapped.tableView.reloadData()</div><div class="line">            <span class="keyword">if</span> items.isEmpty == <span class="literal">false</span> &#123;</div><div class="line">                unwrapped.startUserActivity()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果程序开始时，清单是空的，则程序不会去广播<code>user activity</code>。我们需要解决这个问题：在用户第一次添加一个购物项到列表时开启<code>user activity</code>。</p>
<p>为了做到这一点，更新<code>ListViewController.swift</code>中代理回调<code>detailViewController(controller:didFinishWithUpdatedItem:)</code>的实现，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detailViewController</span><span class="params">(#controller: DetailViewController,</span></span></div><div class="line">                          didFinishWithUpdatedItem item: String) &#123;</div><div class="line">    <span class="comment">// ... some code</span></div><div class="line">    <span class="keyword">if</span> !items.isEmpty &#123;</div><div class="line">        startUserActivity()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此有三种可能：</p>
<ol>
<li>用于更新一个已存在的购物项</li>
<li>用户删除一个存在的购物项</li>
<li>用户添加一个新的购物项</li>
</ol>
<p>现存的代码处理了所有的可能性；我们只需要添加一些检测代码，以在有一个非空的清单时开始一个<code>activity</code>。</p>
<p>在两台设备上编译并运行。此时，我们应该可以在一台设备上添加新的项目，然后将其发送给另外一台设备。</p>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>当用户开始添加一个新的项目或编辑一个已存在的项目时，用户可能不是在查看购物清单。所以我们需要停止广播当前<code>activity</code>。同样，当清单中的所有项目被删除时，没有理由去继续广播当前<code>activiry</code>。在<code>ListViewController.swift</code>中添加以下辅助方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopUserActivity</span><span class="params">()</span></span> &#123;</div><div class="line">    userActivity?.invalidate()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>stopUserActivity()</code>中，我们废止已存在的<code>NSUserActivity</code>。这让<code>handoff</code>停止广播。</p>
<p>现在有了<code>stopUserActivity()</code>，是时候在适当的地方调用它了。</p>
<p>在<code>ListViewController.swift</code>中，更新<code>prepareForSegue(segue:, sender:)</code>方法的实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) &#123;</div><div class="line">    // ... some code</div><div class="line">    stopUserActivity()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户选择一行或者点击添加按钮时，<code>ListViewController</code>准备导航到详情视图。我们废弃当前的清单查看<code>activity</code>。</p>
<p>在同一文件中，更新<code>tableView(_:commitEditingStyle:forRowAtIndexPath:)</code>的实现，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, </span></span></div><div class="line">                        commitEditingStyle editingStyle: UITableViewCellEditingStyle,</div><div class="line">                        forRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class="line">    <span class="comment">// ... some code</span></div><div class="line">    <span class="keyword">if</span> items.isEmpty &#123;</div><div class="line">        stopUserActivity()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        userActivity?.needsSave = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户从清单中删除一项时，我们需要相应地更新<code>user activity</code>。如果移除清单中的所有项目，我们停止广播。否则，我们设置<code>userActivity</code>的<code>needsSave</code>属性为<code>true</code>。当我们这样做时，系统会立即回调<code>updateUserActivityState(activity:)</code>，在这里我们会更新<code>userActivity</code>。</p>
<p>结束这一节之前，还有一种情况需要考虑，用户点击取消按钮，然后从<code>DetailViewController</code>中返回。这触发了一个已存在的场景。我们需要重新开始<code>userActivity</code>。更新<code>unwindDetailViewController(unwindSegue:)</code>的实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@IBAction func unwindDetailViewController(unwindSegue: UIStoryboardSegue) &#123;</div><div class="line">  // ... some code</div><div class="line">  startUserActivity()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译并运行，确保所有事情运行正常。尝试添加一些项目到清单中，确保它们在设备间传输。</p>
<h2 id="创建一个编辑Activity"><a href="#创建一个编辑Activity" class="headerlink" title="创建一个编辑Activity"></a>创建一个编辑Activity</h2><p>接下来，我们以类似的方式来处理<code>DetailViewController</code>。这一次，我们广播另一个<code>activity</code>类型。</p>
<p>打开<code>DetailViewController.swift</code>并修改<code>textFieldDidBeginEditing(textField:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldDidBeginEditing</span><span class="params">(textField: UITextField!)</span></span> &#123;</div><div class="line">    <span class="comment">// Broadcast what we have, if there is anything!</span></div><div class="line">    <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="type">ActivityTypeEdit</span>)</div><div class="line">    activity.title = <span class="string">"Editing Shopping List Item"</span></div><div class="line">    <span class="keyword">let</span> activityItem = (<span class="built_in">countElements</span>(textField.text!) &gt; <span class="number">0</span>) ? textField.text : <span class="string">""</span></div><div class="line">    activity.userInfo = [<span class="type">ActivityItemKey</span>: activityItem]</div><div class="line">    userActivity = activity</div><div class="line">    userActivity?.becomeCurrent()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<p>上面的方法使用项目的字符串的当前内容创建一个“编辑”<code>activity</code>。</p>
<p>当用户继续编辑项目时，我们需要更新<code>user activity</code>。仍然是在<code>DetailViewController.swift</code>中，更新<code>textFieldTextDidChange(notification:)</code>的实现，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldTextDidChange</span><span class="params">(notification: NSNotification)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> text = textField!.text &#123;</div><div class="line">        item = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    userActivity?.needsSave = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们已经标记了<code>activity</code>需要更新，接下来实现<code>updateUserActivityState(activity:)</code>，以备系统的更新需求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> activityListItem = (<span class="built_in">countElements</span>(textField!.text!) &gt; <span class="number">0</span>) ? textField!.text : <span class="string">""</span></div><div class="line">    activity.addUserInfoEntriesFromDictionary([<span class="type">ActivityItemKey</span>: activityListItem])</div><div class="line">    <span class="keyword">super</span>.updateUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们简单地更新了当前项为文本输入框中的文本。</p>
<p>编译并运行。此时，如果我们在一个设备中开始添加一个新项或编辑已存在的项目，我们可以将编辑进程同步给另一个设备。</p>
<h3 id="收尾-1"><a href="#收尾-1" class="headerlink" title="收尾"></a>收尾</h3><p>因为<code>needsSave</code>是一个轻量级的操作，在上面的代码中，你可以根据需要来设置它，然后在每次按键时更新<code>userInfo</code>。</p>
<p>这里有一个小细节你可能已经注意到了。视图控制器在<code>iPad</code>和<code>iPhone</code>的景观模式下中是一个分离视图。这样可以在清单的项目间切换而不需要收起键盘。这种情况发生时，<code>textFieldDidBeginEditing(textField:)</code>方法不会被调用，导致我们的<code>user activity</code>不会更新为新的文本。</p>
<p>为了解决这个问题，更新<code>DetailViewController.swift</code>中<code>item</code>属性的<code>didSet</code>观察者，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> item: <span class="type">String</span>? &#123;</div><div class="line">    <span class="keyword">didSet</span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> textField = <span class="keyword">self</span>.textField &#123;</div><div class="line">            textField.text = item</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> activity = userActivity &#123;</div><div class="line">            activity.needsSave = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户点击<code>ListViewController</code>中的一个项目时，<code>DetailViewController</code>的<code>item</code>属性被设置。一个简单解决方案是让视图控制器知道，在项目更新时它必须更新<code>activity</code>。</p>
<p>最后，当用户离开<code>DetailViewController</code>时，我们需要废止<code>userActivity</code>，以让编辑<code>activity</code>不再被广播。</p>
<p>在<code>DetailViewController.swift</code>的<code>textFieldShouldReturn(_:)</code>方法的起始位置添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userActivity?.invalidate()</div></pre></td></tr></table></figure>
<p>编译并运行程序，确保程序工作正常。接下来，我们将处理接收的<code>activity</code>。</p>
<h2 id="接收Activity"><a href="#接收Activity" class="headerlink" title="接收Activity"></a>接收Activity</h2><p>当用户通过<code>Handoff</code>启动程序时，处理接收的<code>NSUserActivity</code>的任务大部分是由程序的<code>delegate</code>来完成的。</p>
<p>假设所有事情运行正常，数据成功传输，<code>iOS</code>会调用<code>application(_:continueUserActivity:restorationHandler:)</code>方法。这是我们与<code>NSUserActivity</code>实例交互的第一次机会。</p>
<p>我们在前面的章节中已经有一个该方法的实现了。现在，我们做如下修改：</p>
<p>​    </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication!, </span></span></div><div class="line">                 continueUserActivity userActivity: NSUserActivity!,</div><div class="line">                 restorationHandler: <span class="params">(<span class="params">([AnyObject]!)</span></span> -&gt; <span class="type">Void</span>)!)</div><div class="line">                 -&gt; <span class="type">Bool</span> &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> window = <span class="keyword">self</span>.window &#123;</div><div class="line">        window.rootViewController?.restoreUserActivityState(userActivity)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将<code>userActivity</code>传递给程序的<code>window</code>对象的<code>rootViewController</code>，然后返回<code>true</code>。这告诉系统成功处理了<code>Handoff</code>行为。从这里开始，我们将自己转发调用并恢复<code>activity</code>。</p>
<p>我们在<code>rootViewController</code>中调用的方法是<code>restoreUserActivityState(activity:)</code>。这是在<code>UIResponder</code>中声明的一个标准方法。系统使用这个方法来告诉接收者恢复一个<code>NSUserActivivty</code>实例。</p>
<p>我们现在的任务是沿着视图控制器架构往下，将<code>activity</code>从父视图控制器传递到子视图控制器，直到到达需要使用<code>activity</code>的地方：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image22-691-700x360.png" alt="image"></p>
<p>根视图控制器是一个<code>TraitOverrideViewController</code>对象，它的任务是管理程序的<code>size classes</code>；它对我们的<code>user activity</code>不感兴趣。打开<code>TraitOverrideViewController.swift</code>并添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> nextViewController = childViewControllers.first <span class="keyword">as</span> <span class="type">UIViewController</span></div><div class="line">    nextViewController.restoreUserActivityState(activity)</div><div class="line">    <span class="keyword">super</span>.restoreUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们获取<code>TraitOverrideViewController</code>的第一个子视图控制器，然后将<code>activity</code>往下传递。这样做是安全的，因为我们知道程序的视图控制器只包含一个子视图控制器。</p>
<p>层级架构中的下一个视图控制器是<code>SplitViewController</code>，在这里事情会变得更有趣一些。</p>
<p>打开<code>SplitViewController.swift</code>并添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="comment">// What type of activity is it?</span></div><div class="line">    <span class="keyword">let</span> activityType = activity.activityType</div><div class="line"></div><div class="line">    <span class="comment">// This is an activity for ListViewController.</span></div><div class="line">    <span class="keyword">if</span> activityType == <span class="type">ActivityTypeView</span> &#123;</div><div class="line">        <span class="keyword">let</span> controller = viewControllerForViewing()</div><div class="line">        controller.restoreUserActivityState(activity)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> activityType == <span class="type">ActivityTypeEdit</span> &#123;</div><div class="line">        <span class="comment">// This is an activity for DetailViewController.</span></div><div class="line">        <span class="keyword">let</span> controller = viewControllerForEditing()</div><div class="line">        controller.restoreUserActivityState(activity)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.restoreUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SplitViewController</code>知道<code>ListViewController</code>和<code>DetailViewController</code>。如果<code>NSUserActivity</code>是一个列表查看<code>activity</code>类型，则将其传递给<code>ListViewController</code>；否则，如果是一个编辑<code>activity</code>类型，则传递给<code>DetailViewController</code>。</p>
<p>我们将所有的<code>activity</code>传递给正确的对象，现在是时候从这些<code>activity</code>中获取数据了。</p>
<p>打开<code>ListViewController.swift</code>并实现<code>restoreUserActivityState(activity:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="comment">// Get the list of items.</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> userInfo = activity.userInfo &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> importedItems = userInfo[<span class="type">ActivityItemsKey</span>] <span class="keyword">as</span>? <span class="type">NSArray</span> &#123;</div><div class="line">            <span class="comment">// Merge it with what we have locally and update UI.</span></div><div class="line">            <span class="keyword">for</span> anItem <span class="keyword">in</span> importedItems &#123;</div><div class="line">                addItemToItemsIfUnique(anItem <span class="keyword">as</span> <span class="type">String</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="type">PersistentStore</span>.defaultStore().updateStoreWithItems(items)</div><div class="line">            <span class="type">PersistentStore</span>.defaultStore().commit()</div><div class="line">            tableView.reloadData()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.restoreUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的方法中，我们终于可以继续一个查看<code>activity</code>了。因为我们需要维护一个唯一的购物清单时，我们只需要将这些唯一的项目添加到本地列表中，然后保存并更新UI。</p>
<p>编译并运行。现在我们可以看到通过<code>Handoff</code>从另一台设备上同步过来的清单数据了。</p>
<p>编辑<code>activity</code>以类似的方法来处理。打开<code>DetailViewController.swift</code>并实现<code>restoreUserActivityState(activity:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserActivityState</span><span class="params">(activity: NSUserActivity)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> userInfo = activity.userInfo &#123;</div><div class="line">        <span class="keyword">var</span> activityItem: <span class="type">AnyObject</span>? = userInfo[<span class="type">ActivityItemKey</span>]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> itemToRestore = activityItem <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">            item = itemToRestore</div><div class="line">            textField?.text = item</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.restoreUserActivityState(activity)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里获取编辑<code>activity</code>的信息并更新文本域的内容。</p>
<p>编译并运行，查看运行结果！</p>
<h3 id="收尾-2"><a href="#收尾-2" class="headerlink" title="收尾"></a>收尾</h3><p>当用户在另一台设备上点击程序的<code>icon</code>以表明他们想要继续一个<code>user activity</code>时，系统启动相应的程序。一旦程序启动后，系统调用<code>application(_, willContinueUserActivityWithType:)</code>方法。打开<code>AppDelegate.swift</code>并添加以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication,</span></span></div><div class="line">                 willContinueUserActivityWithType userActivityType: String!)</div><div class="line">                 -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，我们的程序已经下载了<code>NSUserActivity</code>实例及其<code>userInfo</code>有效载荷。现在我们只是简单返回<code>true</code>。这强制程序在每次用户初始<code>Handoff</code>进程时接收<code>activity</code>。如果想要通知用户<code>activity</code>正在处理，则这是个好地方。</p>
<p>到这里，系统开始将数据从一台设备同步到另一台设备上。我们已经覆盖了任务正常运行的所有情况。但是可以想象<code>Handoff</code>的<code>activity</code>在某些情况下会失败。</p>
<p>将以下方法添加到<code>AppDelegate.swift</code>中来处理这种情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication!, </span></span></div><div class="line">                 didFailToContinueUserActivityWithType userActivityType: String!,</div><div class="line">                 error: NSError!) &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> error.code != <span class="type">NSUserCancelledError</span> &#123;</div><div class="line">        <span class="keyword">let</span> message = <span class="string">"The connection to your other device may have been interrupted. Please try again. <span class="subst">\(error.localizedDescription)</span>"</span></div><div class="line">        <span class="keyword">let</span> alertView = <span class="type">UIAlertView</span>(title: <span class="string">"Handoff Error"</span>, message: message, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"Dismiss"</span>)</div><div class="line">        alertView.show()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们接收到除了<code>NSUserCancelledError</code>之外的任何信息，则发生了某些错误，且我们不能恢复<code>activity</code>。在这种情况下，我们显示一个适当的消息给用户。然而，如果用户显示取消<code>Handoff</code>行为，则在这里我们不需要做任何事情，只需要放弃操作。</p>
<h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p>使用<code>Handoff</code>的最佳实践之一是版本化。处理这的一个策略是为每个发送的<code>Handoff</code>添加一个版本号，并且只接收来自这个版本号(或者更早的)<code>handoff</code>。让我们来试试。</p>
<p>打开<code>Constants.swift</code>并添加以下常量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="type">ActivityVersionKey</span> = <span class="string">"shopsnap.version.key"</span></div><div class="line"><span class="keyword">let</span> <span class="type">ActivityVersionValue</span> = <span class="string">"1.0"</span></div></pre></td></tr></table></figure>
<p>上面的版本键名和值是我们为这个版本的程序随意挑选的键值对。</p>
<p>如果我们回顾一下上面的章节，系统会定期并自动调用<code>restoreUserActivityState(activity:)</code>方法。这个方法的实现聚集于并限定于实现它的对象的范围内。例如，<code>ListViewController</code>重写了这个方法来更新带有购物清单的<code>userActivity</code>，而<code>DetailViewController</code>的实现是更新当前正在被编辑的项目。</p>
<p>如果涉及到的东西对于<code>userActivity</code>来说是通用的，可用于所有的<code>user activity</code>，如版本号，则处理它的最好的地方就是在<code>AppDelegate</code>中了。</p>
<p>任何时候调用<code>restoreUserActivityState(activity:)</code>，系统都会紧接着调用程序<code>delegate</code>的<code>application(application:, didUpdateUserActivity userActivity:)</code>方法。我们使用这个方法来为我们的<code>Handoff</code>添加版本支持。</p>
<p>打开<code>AppDelegate.swift</code>并添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, </span></span></div><div class="line">                 didUpdateUserActivity userActivity: NSUserActivity) &#123;</div><div class="line">    userActivity.addUserInfoEntriesFromDictionary([<span class="type">ActivityVersionKey</span>: <span class="type">ActivityVersionValue</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们简单地使用了程序的版本号来更新了<code>userInfo</code>字典。</p>
<p>仍然是在<code>AppDelegate.swift</code>中，更新<code>application(_:, continueUserActivity: restorationHandler:)</code>的实现，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication!,</span></span></div><div class="line">                 continueUserActivity userActivity: NSUserActivity!,</div><div class="line">                 restorationHandler: <span class="params">(<span class="params">([AnyObject]!)</span></span> -&gt; <span class="type">Void</span>)!)</div><div class="line">                 -&gt; <span class="type">Bool</span> &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> userInfo: <span class="type">NSDictionary</span> = userActivity.userInfo &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> version = userInfo[<span class="type">ActivityVersionKey</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">            <span class="comment">// Pass it on.</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> window = <span class="keyword">self</span>.window &#123;</div><div class="line">                window.rootViewController?.restoreUserActivityState(userActivity)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们检查<code>userAcitivty</code>的版本，只有当版本号与我们知道的相匹配时才传递。编译并运行，确保程序运行正常。</p>
<h2 id="Handoff最佳实践"><a href="#Handoff最佳实践" class="headerlink" title="Handoff最佳实践"></a>Handoff最佳实践</h2><p>在结束之前，我们来看看<code>Handoff</code>的最佳实践：</p>
<ol>
<li><code>NSURL</code>：在<code>NSUserActivity</code>的<code>userInfo</code>字典中使用<code>NSURL</code>有点棘手。唯一可以安全地在<code>Handoff</code>中传输的<code>NSURLs</code>是使用<code>HTTP/HTTPS</code>和<code>iCloud</code>文档的<code>web</code>网址。我们不能传递本地文件的URL，因为在接收者端，接收者不能正确地转换并映射这些<code>URL</code>。传输文件链接的最好的方式是传递相对路径，然后在接收者端重新构建我们的<code>URL</code>。</li>
<li>平台特定值：避免使用平台特定值，如滑动视图的内容偏移量；更好的方法是使用相对位置。例如，如果用户查看<code>table view</code>中的一些项目时，在我们的<code>user activity</code>中传递<code>table view</code>最上面的可视项的<code>index path</code>，而不是传递<code>table view</code>可视区域的内容偏移量。</li>
<li>版本：想想在程序中使用版本和将来的更新。我们可以在程序的未来版本中添加一些新数据格式或者从<code>userInfo</code>字典中移除值。版本让我们可以理好地控制我们的<code>user activity</code>在当前和将来版本的程序中的行为。</li>
</ol>
<h2 id="下一步是哪"><a href="#下一步是哪" class="headerlink" title="下一步是哪"></a>下一步是哪</h2><p>这里是<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Final.zip" target="_blank" rel="external">示例工程</a>的最终版本。</p>
<p>如果想了解更多的关于<code>Handoff</code>，流和基于文档的<code>Handoff</code>，则可以查看<code>Handoff</code>的开发文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html" target="_blank" rel="external">Apple’s Handoff Programming Guide</a>以获取更多的信息。</p>
<p>如果喜欢这篇文章，则可以下载我们的书<a href="http://www.raywenderlich.com/store/ios-8-by-tutorials" target="_blank" rel="external">iOS 8 by Tutorials</a>，这里塞满了这样的教程。</p>
<p>如果有更多的总量或关于这篇文章的评论，那么可以加入下面的讨论。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/11/cocoa-foundation-nscache/" itemprop="url">
                  Foundation: NSCache
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-11T21:45:14+08:00" content="2015-02-11">
              2015-02-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>NSCache</code>是一个类似于集合的容器，即缓存。它存储<code>key-value</code>对，这一点类似于<code>NSDictionary</code>类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。如果对象被丢弃了，则下次使用时需要重新计算。</p>
<p>当一个<code>key-value</code>对在缓存中时，缓存维护它的一个强引用。存储在<code>NSCache</code>中的通用数据类型通常是实现了<code>NSDiscardableContent</code>协议的对象。在缓存中存储这类对象是有好处的，因为当不再需要它时，可以丢弃这些内容，以节省内存。默认情况下，缓存中的<code>NSDiscardableContent</code>对象在其内容被丢弃时，会被移除出缓存，尽管我们可以改变这种缓存策略。如果一个<code>NSDiscardableContent</code>被放进缓存，则在对象被移除时，缓存会调用<code>discardContentIfPossible</code>方法。</p>
<p><code>NSCache</code>与可变集合有几点不同：</p>
<ol>
<li><code>NSCache</code>类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。</li>
<li><code>NSCache</code>是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。</li>
<li>不像<code>NSMutableDictionary</code>对象，一个缓存对象不会拷贝<code>key</code>对象。</li>
</ol>
<p>这些特性对于<code>NSCache</code>类来说是必须的，因为在需要释放内存时，缓存必须异步地在幕后决定去自动修改自身。</p>
<h2 id="缓存限制"><a href="#缓存限制" class="headerlink" title="缓存限制"></a>缓存限制</h2><p><code>NSCache</code>提供了几个属性来限制缓存的大小，如属性<code>countLimit</code>限定了缓存最多维护的对象的个数。声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit</div></pre></td></tr></table></figure>
<p>默认值为0，表示不限制数量。但需要注意的是，这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。</p>
<p>另外，<code>NSCache</code>提供了<code>totalCostLimit</code>属性来限定缓存能维持的最大内存。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> totalCostLimit</div></pre></td></tr></table></figure>
<p>默认值也是0，表示没有限制。当我们添加一个对象到缓存中时，我们可以为其指定一个消耗(<code>cost</code>)，如对象的字节大小。如果添加这个对象到缓存导致缓存总的消耗超过<code>totalCostLimit</code>的值，则缓存会自动丢弃一些对象，直到总消耗低于<code>totalCostLimit</code>值。不过被丢弃的对象的顺序无法保证。</p>
<p>需要注意的是<code>totalCostLimit</code>也不是一个严格限制，其策略是与<code>countLimit</code>一样的。</p>
<h2 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h2><p><code>NSCache</code>提供了一组方法来存取<code>key-value</code>对，类似于<code>NSMutableDictionary</code>类。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="keyword">id</span>)key</div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key</div><div class="line">- (<span class="keyword">void</span>)removeAllObjects</div></pre></td></tr></table></figure>
<p>如上所述，与<code>NSMutableDictionary</code>不同的就是它不会拷贝<code>key</code>对象。</p>
<p>此外，我们在存储对象时，可以为对象指定一个消耗值，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="keyword">id</span>)key cost:(<span class="built_in">NSUInteger</span>)num</div></pre></td></tr></table></figure>
<p>这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用<code>-setObject:forKey:</code>方法，这个方法不需要传入一个消耗值。</p>
<h2 id="NSDiscardableContent协议"><a href="#NSDiscardableContent协议" class="headerlink" title="NSDiscardableContent协议"></a>NSDiscardableContent协议</h2><p><code>NSDiscardableContent</code>是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>
<p>一个<code>NSDiscardableContent</code>对象的生命周期依赖于一个“<code>counter</code>”变量。一个<code>NSDiscardableContent</code>对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的<code>counter</code>变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时<code>counter</code>变量将等于0。当<code>counter</code>变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。</p>
<p>为了丢弃这些内容，可以调用对象的<code>discardContentIfPossible</code>方法，该方法的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)discardContentIfPossible</div></pre></td></tr></table></figure>
<p>这样当<code>counter</code>变量等于0时将会释放相关的内存。而如果<code>counter</code>变量不为0，则该方法什么也不做。</p>
<p>默认情况下，<code>NSDiscardableContent</code>对象的<code>counter</code>变量初始值为1，以确保对象不会被内存管理系统立即释放。从这个点开始，我们就需要去跟踪<code>counter</code>变量的状态。为此。协议声明了两个方法：<code>beginContentAccess</code>和<code>endContentAccess</code>。</p>
<p>其中调用<code>beginContentAccess</code>方法会增加对象的<code>counter</code>变量(+1)，这样就可以确保对象不会被丢弃。该方法声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)beginContentAccess</div></pre></td></tr></table></figure>
<p>通常我们在对象被需要或者将要使用时调用这个方法。具体的实现类可以决定在对象已经被丢弃的情况下是否重新创建这些内存，且重新创建成功后返回YES。协议的实现者在<code>NSDiscardableContent</code>对象被使用，而又没有调用它的<code>beginContentAccess</code>方法时，应该抛出一个异常。</p>
<p>函数的返回值如果是YES，则表明可丢弃内存仍然可用且已被成功访问；否则返回NO。另外需要注意的是，该方法是在实现类中必须实现(<code>required</code>)。</p>
<p>与<code>beginContentAccess</code>相对应的是<code>endContentAccess</code>。如果可丢弃内存不再被访问时调用。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)endContentAccess</div></pre></td></tr></table></figure>
<p>该方法会减少对象的<code>counter</code>变量，通常是让对象的<code>counter</code>值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>
<p><code>NSCache</code>类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(<code>discardable-content object</code>)，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> evictsObjectsWithDiscardedContent</div></pre></td></tr></table></figure>
<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。默认值为YES。</p>
<h2 id="NSCacheDelegate代理"><a href="#NSCacheDelegate代理" class="headerlink" title="NSCacheDelegate代理"></a>NSCacheDelegate代理</h2><p><code>NSCache</code>对象还有一个代理属性，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">assign</span>) <span class="keyword">id</span>&lt; <span class="built_in">NSCacheDelegate</span> &gt; delegate</div></pre></td></tr></table></figure>
<p>实现<code>NSCacheDelegate</code>代理的对象会在对象即将从缓存中移除时执行一些特定的操作，因此代理对象可以实现以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cache:(<span class="built_in">NSCache</span> *)cache willEvictObject:(<span class="keyword">id</span>)obj</div></pre></td></tr></table></figure>
<p>需要注意的是在这个代理方法中不能修改cache对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实际上，我们常用的<code>SDWebImage</code>图片下载库的缓存机制就是通过<code>NSCache</code>来实现的。<code>《Effectiveobjc 2.0》</code>中也专门用一小篇的内容来介绍<code>NSCache</code>的使用(第50条：构建缓存时选用<code>NSCache</code>而非<code>NSDictionary</code>)，里面有更精彩的内容。如果我们需要构建缓存机制，则应该使用<code>NSCache</code>，而不是<code>NSDictionary</code>，这样可以减少我们应用对内存的占用，从而达到优化内存的目标。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/" target="_blank" rel="external">NSCache Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSDiscardableContent_Protocol/index.html" target="_blank" rel="external">NSDiscardableContent Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSCacheDelegate_Protocol/index.html" target="_blank" rel="external">NSCacheDelegate Protocol Reference</a></li>
<li><a href="http://www.15yan.com/story/45toOUzFGlr/" target="_blank" rel="external">Objective-C中的缓存: NSCache介绍</a></li>
<li><a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/07/sourcecode-sdwebimage/" itemprop="url">
                  SDWebImage实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T23:30:45+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>源码来源：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></p>
<p>版本: 3.7</p>
<p><code>SDWebImage</code>是一个开源的第三方库，它提供了<code>UIImageView</code>的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>
<ol>
<li>提供<code>UIImageView</code>的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持<code>GIF</code>图片</li>
<li>支持<code>WebP</code>图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个<code>URL</code>的图片不被下载多次</li>
<li>确保虚假的<code>URL</code>不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
</ol>
<p>从<code>github</code>上对<code>SDWebImage</code>使用情况就可以看出，<code>SDWebImage</code>在图片下载及缓存的处理方面还是很被认可的。在本文中，我们主要从源码的角度来分析一下<code>SDWebImage</code>的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对<code>GIF</code>图片及<code>WebP</code>图片的支持操作。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在<code>SDWebImage</code>中，图片的下载是由<code>SDWebImageDownloader</code>类来完成的。它是一个异步下载器，并对图像加载做了优化处理。下面我们就来看看它的具体实现。</p>
<h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同的操作。下载选项由枚举<code>SDWebImageDownloaderOptions</code>定义，具体如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache</span></div><div class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block</span></div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">	<span class="comment">// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消</span></div><div class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL证书。主要用于测试目的。</span></div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 将图片下载放到高优先级队列中</span></div><div class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、<code>cookie</code>处理以认证几个方面。</p>
<h3 id="下载顺序"><a href="#下载顺序" class="headerlink" title="下载顺序"></a>下载顺序</h3><p><code>SDWebImage</code>的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序</span></div><div class="line">    SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">    </div><div class="line">    <span class="comment">// 以栈的方式，按照后进先出的顺序下载。</span></div><div class="line">    SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h3><p><code>SDWebImageDownloader</code>下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个<code>NSOperationQueue</code>操作队列中来完成的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</div></pre></td></tr></table></figure>
<p>默认情况下，队列最大并发数是6。如果需要的话，我们可以通过<code>SDWebImageDownloader</code>类的<code>maxConcurrentDownloads</code>属性来修改。</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        ...</div><div class="line">        _barrierQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderBarrierQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以<code>block</code>形式来呈现，为此在<code>SDWebImageDownloader.h</code>中定义了几个<code>block</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下载进度</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderProgressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize);</div><div class="line"><span class="comment">// 下载完成</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderCompletedBlock)(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished);</div><div class="line"><span class="comment">// Header过滤</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> *(^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSDictionary</span> *headers);</div></pre></td></tr></table></figure>
<p>图片下载的这些回调信息存储在<code>SDWebImageDownloader</code>类的<code>URLCallbacks</code>属性中，该属性是一个字典，<code>key</code>是图片的<code>URL</code>地址，<code>value</code>则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作<code>URLCallbacks</code>属性。为了保证<code>URLCallbacks</code>操作(添加、删除)的线程安全性，<code>SDWebImageDownloader</code>将这些操作作为一个个任务放到<code>barrierQueue</code>队列中，并设置屏障来确保同一时间只有一个线程操作<code>URLCallbacks</code>属性，我们以添加操作为例，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    	    </div><div class="line">   	<span class="comment">// 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 处理同一URL的同步下载请求的单个下载</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">        [callbacksForURL addObject:callbacks];</div><div class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</div><div class="line">        </div><div class="line">        ...</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个下载管理器对于下载请求的管理都是放在<code>downloadImageWithURL:options:progress:completed:</code>方法里面来处理的，该方法调用了上面所提到的addProgressCallback:andCompletedBlock:forURL:createCallback:方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入<code>downloadQueue</code>操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 创建请求对象，并根据options参数设置其属性</span></div><div class="line">        <span class="comment">// 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 创建SDWebImageDownloaderOperation操作对象，并进行配置</span></div><div class="line">        <span class="comment">// 配置信息包括是否需要认证、优先级</span></div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</div><div class="line">                                                         	 <span class="comment">// 3. 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用</span></div><div class="line">                                                             ...</div><div class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                 <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                                                        	 <span class="comment">// 4. 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，</span></div><div class="line">                                                        	 <span class="comment">// 如果finished为YES，则将该url对应的回调信息从URLCallbacks中删除</span></div><div class="line">                                                            ...</div><div class="line">                                                            <span class="keyword">if</span> (finished) &#123;</div><div class="line">                                                                [sself removeCallbacksForURL:url];</div><div class="line">                                                            &#125;</div><div class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                        	<span class="comment">// 5. 取消操作将该url对应的回调信息从URLCallbacks中删除</span></div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            [sself removeCallbacksForURL:url];</div><div class="line">                                                        &#125;];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// 6. 将操作加入到操作队列downloadQueue中</span></div><div class="line">		<span class="comment">// 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</span></div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，每个下载操作的超时时间可以通过<code>downloadTimeout</code>属性来设置，默认值为15秒。</p>
<h3 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h3><p>每个图片的下载都是一个<code>Operation</code>操作。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>
<p><code>SDWebImage</code>定义了一个协议，即<code>SDWebImageOperation</code>作为图片下载操作的基础协议。它只声明了一个<code>cancel</code>方法，用于取消操作。协议的具体声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>SDWebImage</code>自定义了一个<code>Operation</code>类，即<strong><code>SDWebImageDownloaderOperation</code></strong>，它继承自<code>NSOperation</code>，并采用了<code>SDWebImageOperation</code>协议。除了继承而来的方法，该类只向外暴露了一个方法，即上面所用到的初始化方法<code>initWithRequest:options:progress:completed:cancelled:</code>。</p>
<p>对于图片的下载，<code>SDWebImageDownloaderOperation</code>完全依赖于URL加载系统中的<code>NSURLConnection</code>类(并未使用7.0以后的<code>NSURLSession</code>类)。我们先来分析一下<code>SDWebImageDownloaderOperation</code>类中对于图片实际数据的下载处理，即<code>NSURLConnection</code>各代理方法的实现。</p>
<p>首先，<code>SDWebImageDownloaderOperation</code>在分类中采用了<code>NSURLConnectionDataDelegate</code>协议，并实现了该协议的以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- connection:didReceiveResponse:</div><div class="line">- connection:didReceiveData:</div><div class="line">- connectionDidFinishLoading:</div><div class="line">- connection:didFailWithError:</div><div class="line">- connection:willCacheResponse:</div><div class="line">- connectionShouldUseCredentialStorage:</div><div class="line">- connection:willSendRequestForAuthenticationChallenge:</div></pre></td></tr></table></figure>
<p>我们在此不逐一分析每个方法的实现，就重点分析一下<code>-connection:didReceiveData:</code>方法。该方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个<code>CGImageSourceRef</code>对象以做处理。在首次获取到数据时(<code>width+height==0</code>)会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用<code>CGImageSourceRef</code>对象创建一个图片对象，经过缩放、解压缩操作后生成一个<code>UIImage</code>对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>
<p><em>注：缩放操作可以查看<code>SDWebImageCompat</code>文件中的<code>SDScaledImageForKey</code>函数；解压缩操作可以查看<code>SDWebImageDecoder</code>文件<code>+decodedImageWithImage</code>方法</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="comment">// 1. 附加数据</span></div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 获取已下载数据总大小</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据</span></div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值</span></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                ...</div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line">                </div><div class="line">                <span class="comment">// 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span></div><div class="line">                <span class="comment">//    的方向会不对，所以在这边我们先保存这个信息并在后面使用。</span></div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 6. 图片还未下载完成</span></div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            </div><div class="line"><span class="meta">#ifdef TARGET_OS_IPHONE</span></div><div class="line">            <span class="comment">// 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">            </div><div class="line">            <span class="comment">// 9. 对图片进行缩放、解码操作</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">                        <span class="keyword">self</span>.completedBlock(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们前面说过<code>SDWebImageDownloaderOperation</code>类是继承自<code>NSOperation</code>类。它没有简单的实现<code>main</code>方法，而是采用更加灵活的<code>start</code>方法，以便自己管理下载的状态。</p>
<p>在<code>start</code>方法中，创建了我们下载所使用的<code>NSURLConnection</code>对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含<code>SDWebImageDownloaderContinueInBackground</code>选项。<code>start</code>方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    	<span class="comment">// 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">        <span class="comment">// 1. 如果设置了在后台执行，则进行后台执行</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                ...</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</div><div class="line">        <span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.connection start];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 在主线程抛出下载开始通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 启动run loop</span></div><div class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</div><div class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRunLoopRun</span>();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 4. 如果未完成，则取消连接</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) &#123;</div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span>.connection didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span>.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        ... </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，在下载完成或下载失败后，需要停止当前线程的<code>run loop</code>，清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考<code>-connectionDidFinishLoading:</code>与<code>-connection:didFailWithError:</code>的实现。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下载的核心其实就是利用<code>NSURLConnection</code>对象来加载数据。每个图片的下载都由一个<code>Operation</code>操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的另一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>
<p><code>SDWebImage</code>提供了对图片缓存的支持，而该功能是由<code>SDImageCache</code>类来完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>
<h3 id="内存缓存及磁盘缓存"><a href="#内存缓存及磁盘缓存" class="headerlink" title="内存缓存及磁盘缓存"></a>内存缓存及磁盘缓存</h3><p>内存缓存的处理是使用<code>NSCache</code>对象来实现的。<code>NSCache</code>是一个类似于集合的容器。它存储<code>key-value</code>对，这一点类似于<code>NSDictionary</code>类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p>
<p>磁盘缓存的处理则是使用<code>NSFileManager</code>对象来实现的。图片存储的位置是位于<code>Cache</code>文件夹。另外，<code>SDImageCache</code>还定义了一个串行队列，来异步存储图片。</p>
<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSCache</span> *memCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *diskCachePath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *customPaths;</div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithNamespace:(<span class="built_in">NSString</span> *)ns &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">// Init the memory cache</span></div><div class="line">        _memCache = [[<span class="built_in">NSCache</span> alloc] init];</div><div class="line">        _memCache.name = fullNamespace;</div><div class="line">        </div><div class="line">        <span class="comment">// Init the disk cache</span></div><div class="line">        <span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</div><div class="line">        _diskCachePath = [paths[<span class="number">0</span>] stringByAppendingPathComponent:fullNamespace];</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">            _fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SDImageCache</code>提供了大量方法来缓存、获取、移除及清空图片。而对于每个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个<code>key</code>值来索引它。在内存中，我们将其作为<code>NSCache</code>的<code>key</code>值，而在磁盘中，我们用这个<code>key</code>作为图片的文件名。对于一个远程服务器下载的图片，其<code>url</code>是作为这个<code>key</code>的最佳选择了。我们在后面会看到这个<code>key</code>值的重要性。</p>
<h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个<code>task</code>放到串行队列中处理。在iOS中，会先检测图片是<code>PNG</code>还是<code>JPEG</code>，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做<code>MD5</code>摘要后的串)。缓存操作的基础方法是-<code>storeImage:recalculateFromImage:imageData:forKey:toDisk</code>，它的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 内存缓存，将其存入NSCache中，同时传入图片的消耗值</span></div><div class="line">    [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (toDisk) &#123;</div><div class="line">        <span class="comment">// 2. 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中</span></div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            <span class="built_in">NSData</span> *data = imageData;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</div><div class="line"><span class="meta">#if TARGET_OS_IPHONE</span></div><div class="line">                </div><div class="line">                <span class="comment">// 3. 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10</span></div><div class="line">                <span class="comment">// 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span></div><div class="line">                <span class="built_in">BOOL</span> imageIsPng = <span class="literal">YES</span>;</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</div><div class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (imageIsPng) &#123;</div><div class="line">                    data = <span class="built_in">UIImagePNGRepresentation</span>(image);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</div><div class="line">                &#125;</div><div class="line"><span class="meta">#else</span></div><div class="line">                data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image.representations usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</div><div class="line"><span class="meta">#endif</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 4. 创建缓存文件并存储图片</span></div><div class="line">            <span class="keyword">if</span> (data) &#123;</div><div class="line">                <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                [_fileManager createFileAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询图片"><a href="#查询图片" class="headerlink" title="查询图片"></a>查询图片</h3><p>如果我们想在内存或磁盘中查询是否有<code>key</code>指定的图片，则可以分别使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>而如果只是想查看本地是否在key指定的图片，则不管是在内存还是在磁盘上，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromDiskCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage) &#123;</div><div class="line">                <span class="built_in">CGFloat</span> cost = diskImage.size.height * diskImage.size.width * diskImage.scale * diskImage.scale;</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h3><p>图片的移除操作则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key withCompletion:(SDWebImageNoParamsBlock)completion;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk;</div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>我们可以选择同时移除内存及磁盘上的图片。</p>
<h3 id="清理图片"><a href="#清理图片" class="headerlink" title="清理图片"></a>清理图片</h3><p>磁盘缓存图片的清理操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，清空操作有以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)clearDisk;</div><div class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>而部分清理则是根据我们设定的一些参数值来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过<code>maxCacheAge</code>属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过<code>maxCacheSize</code>属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在-<code>cleanDiskWithCompletionBlock:</code>方法中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</div><div class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 该枚举器预先获取缓存文件的有用的属性</span></div><div class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</div><div class="line">        </div><div class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.maxCacheAge];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// 3. 跳过文件夹</span></div><div class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 4. 移除早于有效期的老文件</span></div><div class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 5. 存储文件的引用并计算所有文件的总大小，以备后用</span></div><div class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</div><div class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.maxCacheSize) &#123;</div><div class="line">            <span class="comment">// 7. 以设置的最大缓存大小的一半作为清理目标</span></div><div class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.maxCacheSize / <span class="number">2</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// 8. 按照最后修改时间来排序剩下的缓存文件</span></div><div class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></div><div class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</div><div class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</div><div class="line">                                                            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">// 9. 删除文件，直到缓存总大小降到我们期望的大小</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</div><div class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</div><div class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        	        	        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，<code>SDImageCache</code>类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个<code>key</code>指定的图片。另外，<code>SDImageCache</code>类提供了一个单例方法的实现，所以我们可以将其当作单例对象来处理。</p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><p>在实际的运用中，我们并不直接使用<code>SDWebImageDownloader</code>类及<code>SDImageCache</code>类来执行图片的下载及缓存。为了方便用户的使用，<code>SDWebImage</code>提供了<code>SDWebImageManager</code>对象来管理图片的下载与缓存。而且我们经常用到的诸如<code>UIImageView+WebCache</code>等控件的分类都是基于<code>SDWebImageManager</code>对象的。该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的代码中我们还可以看到有一个<code>delegate</code>属性，其是一个<code>id\&lt;SDWebImageManagerDelegate\&gt;</code>对象。<code>SDWebImageManagerDelegate</code>声明了两个可选实现的方法，如下所示：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 控制当图片在缓存中没有找到时，应该下载哪个图片</span></div><div class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line"></div><div class="line"><span class="comment">// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换</span></div><div class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</div></pre></td></tr></table></figure>
<p>这两个代理方法会在<code>SDWebImageManager</code>的<code>-downloadImageWithURL:options:progress:completed:</code>方法中调用，而这个方法是<code>SDWebImageManager</code>类的核心所在。我们来看看它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">    <span class="comment">// 前面省略n行。主要作了如下处理：</span></div><div class="line">    <span class="comment">// 1. 判断url的合法性</span></div><div class="line">    <span class="comment">// 2. 创建SDWebImageCombinedOperation对象</span></div><div class="line">    <span class="comment">// 3. 查看url是否是之前下载失败过的</span></div><div class="line">    <span class="comment">// 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调</span></div><div class="line">    </div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line"></div><div class="line">			<span class="comment">// 下载</span></div><div class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="keyword">if</span> (weakOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 操作被取消，则不做任务事情</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                	<span class="comment">// 如果出错，则调用完成回调，并将url放入下载挫败url数组中</span></div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">	                    <span class="comment">// 在全局队列中并行处理图片的缓存</span></div><div class="line">	                    <span class="comment">// 首先对图片做个转换操作，该操作是代理对象实现的</span></div><div class="line">	                    <span class="comment">// 然后对图片做缓存处理</span></div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                            </div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            ...</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 下载完成并缓存后，将操作从队列中移除</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                        [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">// 设置取消回调</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [subOperation cancel];</div><div class="line">                </div><div class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                    [<span class="keyword">self</span>.runningOperations removeObject:weakOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项来缓存图片。上面这个下载方法中的操作选项参数是由枚举<code>SDWebImageOptions</code>来定义的，这个操作中的一些选项是与<code>SDWebImageDownloaderOptions</code>中的选项对应的。我们来看看这个<code>SDWebImageOptions</code>选项都有哪些：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记禁用磁盘缓存</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。</span></div><div class="line">    <span class="comment">// 默认情况下，图像在下载完成后一次性显示</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。</span></div><div class="line">    <span class="comment">// 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。</span></div><div class="line">    <span class="comment">// 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次</span></div><div class="line">    <span class="comment">// 然后再用最终图片调用一次</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成</span></div><div class="line">    <span class="comment">// 如果后台任务超时，则操作被取消</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL认证</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，</span></div><div class="line">    <span class="comment">// 以便图片能立即下载而不是等到当前队列被加载</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。</span></div><div class="line">    <span class="comment">// 使用这个票房则不任何情况下都进行转换。</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>大家在看<code>-downloadImageWithURL:options:progress:completed:</code>，可以看到两个<code>SDWebImageOptions</code>与<code>SDWebImageDownloaderOptions</code>中的选项是如何对应起来的，在此不多做解释。</p>
<h2 id="视图扩展"><a href="#视图扩展" class="headerlink" title="视图扩展"></a>视图扩展</h2><p>我在使用<code>SDWebImage</code>的时候，使用得最多的是<code>UIImageView+WebCache</code>中的针对<code>UIImageView</code>的扩展方法，这些扩展方法将<code>UIImageView</code>与<code>WebCache</code>集成在一起，来让<code>UIImageView</code>对象拥有异步下载和缓存远程图片的能力。其中最核心的方法是<code>-sd_setImageWithURL:placeholderImage:options:progress:completed:</code>，其使用<code>SDWebImageManager</code>单例对象下载并缓存图片，完成后将图片赋值给<code>UIImageView</code>对象的<code>image</code>属性，以使图片显示出来，其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line">        __<span class="keyword">weak</span> <span class="built_in">UIImageView</span> *wself = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 使用SDWebImageManager单例对象来下载图片</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">                </div><div class="line">                <span class="comment">// 图片下载完后显示图片</span></div><div class="line">                <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了扩展<code>UIImageView</code>之外，<code>SDWebImage</code>还扩展了<code>UIView</code>、<code>UIButton</code>、<code>MKAnnotationView</code>等视图类，大家可以参考源码。</p>
<p>当然，如果不想使用这些扩展，则可以直接使用<code>SDWebImageManager</code>来下载图片，这也是很OK的。</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p><code>SDWebImage</code>的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>
<ol>
<li><code>dispatch_barrier_sync</code>函数：该方法用于对操作设置屏幕，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</li>
<li><code>NSMutableURLRequest</code>：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</li>
<li><code>NSOperation</code>及<code>NSOperationQueue</code>：操作队列是<code>Objective-C</code>中一种高级的并发处理方法，现在它是基于<code>GCD</code>来实现的。相对于<code>GCD</code>来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对<code>SDWebImage</code>中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</li>
<li><code>NSURLConnection</code>：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即<code>NSURLSession</code>类。</li>
<li>开启一个后台任务。</li>
<li><code>NSCache</code>类：一个类似于集合的容器。它存储<code>key-value</code>对，这一点类似于<code>NSDictionary</code>类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</li>
<li>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
<li>对图片的解压缩操作：这一操作可以查看<code>SDWebImageDecoder.m</code>中<code>+decodedImageWithImage</code>方法的实现。</li>
<li>对<code>GIF</code>图片的处理</li>
<li>对<code>WebP</code>图片的处理</li>
</ol>
<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage工程</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="http://objccn.io/issue-2-2/" target="_blank" rel="external">常见的后台实践</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/" target="_blank" rel="external">NSCache Class Reference</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/31/cocoa-foundation-nsobject-protocol/" itemprop="url">
                  Foundation: NSObject Protocol
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-31T22:41:09+08:00" content="2015-01-31">
              2015-01-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面一章我们整理了<code>NSObject</code>类，这一章我们来看看<code>NSObject</code>协议的内容。</p>
<p><code>NSObject</code>协议提供了一组方法作为<code>Objective-C</code>对象的基础。其实我们对照一个<code>NSObject</code>类和<code>NSObject</code>协议，可以看到很多方法的方法名都是一样的，只不过<code>NSObject</code>类提供的是类方法，是基于类级别的操作；而<code>NSObject</code>协议提供的是实例方法，是基于实例对象级别的操作。</p>
<p>如果一个对象如果采用了这个协议，则可以被看作是一级对象。我们可以从这个对象获取以下信息：</p>
<ol>
<li>类信息，以及类所在的继承体系。</li>
<li>协议信息</li>
<li>响应特定消息的能力</li>
</ol>
<p>实际上，<code>Cocoa</code>的根类<code>NSObject</code>就采用了这个类，所以所有继承自<code>NSObject</code>类的对象都具备<code>NSObject</code>协议中描述的功能。接下来，我们参照<code>NSObject</code>类，整理一下这些功能。</p>
<h2 id="识别对象"><a href="#识别对象" class="headerlink" title="识别对象"></a>识别对象</h2><p>类似于<code>NSObject</code>类，<code>NSObject</code>协议提供了一些方法来识别类。 </p>
<p>如果想获取对象的类对象，则可以使用如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="keyword">class</span></div></pre></td></tr></table></figure>
<p>如果想获取对象父类的类对象，则可以使用以下只读属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) Class superclass</div></pre></td></tr></table></figure>
<p>如果想查看某个对象是否是给定类的实例或者是给定类子类的实例，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass</div></pre></td></tr></table></figure>
<p>这个方法应该是大家常用的方法。需要注意的是在类簇中使用这个方法。在类簇中，我们获取到的对象类型可能并不是我们期望的类型。如果我们调用一个返回类簇的方法，则这个方法返回的实际类型会是最能标识这个类能做些什么的类型。例如，如果一个方法返回一个指向<code>NSArray</code>对象的指针，则不能使用<code>isKindOfClass:</code>方法查看经是否是一个可变数组，如以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([myArray isKindOfClass:[<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>]])</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Modify the object</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们使用这样的代码，我们可能会认为修改一个实际上不应该被修改的对象是没问题的。这样做可能会对那些期望对象保持不要变的代码产生影响。</p>
<p>另外，查看对象是否是指定类的一个实例还可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass</div></pre></td></tr></table></figure>
<p>注意，这个方法无法确定对象是否是指定类子类的实例。另外，类对象可能是编译器创建的对象，但它仍然支持这一概念。</p>
<h2 id="测试对象"><a href="#测试对象" class="headerlink" title="测试对象"></a>测试对象</h2><p>对于对象的测试，<code>NSObject</code>协议也定义了两个方法，其中<code>respondsToSelector:</code>方法用于测试对象是否能响应指定的消息，这个方法可以是类自定义的实例方法，也可以是继承而来的实例方法。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>不过我们不能使用<code>super</code>关键字来调用<code>respondsToSelector:</code>，以查看对象是否是从其父类继承了某个方法。因为我们可以从<code>super</code>的定义可知，消息的最终实际接收者还是<code>self</code>本身，因此测试的还是对象的整个体系(包括对象所在类本身)，而不仅仅是父类。不过，我们可以使用父类来调用<code>NSObject</code>类的类方法<code>instancesRespondToSelector:</code>来达到这个目的，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( [MySuperclass instancesRespondToSelector:<span class="keyword">@selector</span>(aMethod)] ) &#123;</div><div class="line">    <span class="comment">// invoke the inherited method</span></div><div class="line">    [<span class="keyword">super</span> aMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不能简单地使用<code>[[self superclass] instancesRespondToSelector:@selector(aMethod)]</code>，因为如果由一个子类来调用，则可能导致方法的失败。</p>
<p>还需要注意的是，如果对象能够转发消息，则也可以响应这个消息，不过这个方法会返回NO。</p>
<p>如果想查看对象是否实现了某个类，则可以使用如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol</div></pre></td></tr></table></figure>
<p>这个方法与<code>NSObject</code>类的类方法<code>conformsToProtocol:</code>是一样的。它只是提供了一个便捷方法，我们不需要先去取对象的类，再调用类方法<code>conformsToProtocol:</code>。</p>
<h2 id="标识和比较对象"><a href="#标识和比较对象" class="headerlink" title="标识和比较对象"></a>标识和比较对象</h2><p>如果我们想获取对象本身，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">self</span></div></pre></td></tr></table></figure>
<p>比较两个对象是否相同，则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)anObject</div></pre></td></tr></table></figure>
<p>这个方法定义了对象相同的意义。例如，一个容器对象可能会按照特定规则来定义两个对象是否相等，如其所有元素的<code>isEqual:</code>请求都返回YES。我们在自定义子类时，可以重写这个方法，以使用我们自己的规则来评判两个对象相等。</p>
<p>如果两个对象相等，则它们必须拥有相同的<code>hash</code>值。在子类中定义<code>isEqual:</code>方法并打算把子类的实例放入集合中时，这一点非常重要。因此在子类中必须同时定义<code>hash</code>。</p>
<p>hash值是一个整数值，它可以用于在<code>hash</code>表结构中作为一个表地址。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> hash</div></pre></td></tr></table></figure>
<p>如果一个可变对象被添加到一个以<code>hash</code>值来确定对象位置的集合中，则当对象还在集合中时，其由<code>hash</code>方法返回的值不能改变。因此，<code>hash</code>方法不能依赖于对象内部的任何状态信息，或许我们必须确保对象在集合中时，不能改变其内部状态信息。比如，一个可变字典可以放到一个<code>hash</code>表中，但当它还在表中时，不能改变它。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>在<code>NSObject</code>类中，定义了一系列的发送消息的方法，用于在目标线程中执行方法。<code>NSObject</code>协议也定义了如下几个方法，来执行发送消息的任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anObject</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anObject withObject:(<span class="keyword">id</span>)anotherObject</div></pre></td></tr></table></figure>
<p>这三个方法基本相同，只不过后面两个方法能为<code>selector</code>指定的方法携带参数。因此我们以<code>performSelector:</code>为例。</p>
<p><code>performSelector:</code>方法的使用与直接将消息发送给对象的效果是一样的，如下面几个操作，做的事情是一样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> myClone = [anObject <span class="keyword">copy</span>];</div><div class="line"><span class="keyword">id</span> myClone = [anObject performSelector:<span class="keyword">@selector</span>(<span class="keyword">copy</span>)];</div><div class="line"><span class="keyword">id</span> myClone = [anObject performSelector:sel_getUid(<span class="string">"copy"</span>)];</div></pre></td></tr></table></figure>
<p>区别在于，<code>performSelector:</code>允许在运行时再去确定对象是否能处理消息。而<code>[anObject copy]</code>中，如果<code>anObject</code>不能处理<code>copy</code>，编译器就直接会报错。</p>
<p>如果方法的参数过多，以至于上面几个方法都无法处理，则可以考虑使用<code>NSInvocation</code>对象。</p>
<h2 id="描述对象"><a href="#描述对象" class="headerlink" title="描述对象"></a>描述对象</h2><p>描述对象的方法与<code>NSObject</code>类中描述类的方法其方法名相同，都是<code>description</code>，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *description</div></pre></td></tr></table></figure>
<p>这个方法用于创建一个对象的文本表达方式，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassName *anObject = &lt;<span class="meta">#An object#&gt;;</span></div><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"anObject is %@"</span>, anObject];</div></pre></td></tr></table></figure>
<p>为了便于调试，<code>NSObject</code>协议还定义<code>debugDescription</code>方法，该方法声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *debugDescription</div></pre></td></tr></table></figure>
<p>该方法返回一个在调试器中显示的用于描述对象内容的字符串。在调试器中打印一个对象时，会调用这个方法。<code>NSObject</code>类实现这个方法时只是调用了<code>description</code>方法，所以默认情况下，这两个方法的输出都是一样的。我们在子类中可以重写这个方法的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>NSObject</code>协议的定义的很多方法都是我们平常经常使用的。我们在创建<code>NSObject</code>类的子类时，默认都继承了<code>NSObject</code>类对于<code>NSObject</code>协议的实现。如果有特殊的需求，我们可以重写这些方法。</p>
<p>当然，<code>NSObject</code>协议还定义了一些方法，如我们非常熟悉的<code>retain</code>, <code>release</code>, <code>autorelease</code>, <code>retainCount</code>方法，不过这些方法在<code>ARC</code>时代已经过时了，我们在此不过多说明。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html" target="_blank" rel="external">NSObject Protocol Reference</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
