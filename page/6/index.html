<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/6/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/6/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/03/objective-c-runtime-3/" itemprop="url">
                  Objective-C Runtime 运行时之三：方法与消息
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-03T18:11:02+08:00" content="2014-11-03">
              2014-11-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/objectivec/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure>
<p><code>objc_selector</code>结构体的详细定义没有在<code>&lt;objc/runtime.h&gt;</code>头文件中找到。方法的<code>selector</code>用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code>类型的地址)，这个标识就是<code>SEL</code>。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL sel1 = <span class="keyword">@selector</span>(method1);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sel : %p"</span>, sel1);</div></pre></td></tr></table></figure>
<p>上面的输出为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-30</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></div></pre></td></tr></table></figure>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个<code>SEL</code>。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个<code>SEL</code>。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">int</span>)width;</div><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setWidthIntValue:(<span class="keyword">int</span>)width;</div><div class="line">-(<span class="keyword">void</span>)setWidthDoubleValue:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure>
<p>当然，不同的类可以拥有相同的<code>selector</code>，这个没有问题。不同类的实例对象执行相同的<code>selector</code>时，会在各自的方法列表中去根据<code>selector</code>去寻找自己对应的<code>IMP</code>。</p>
<p>工程中的所有的<code>SEL</code>组成一个<code>Set</code>集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名<code>hash</code>化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是<code>perfect hash</code>）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个<code>SEL</code>），那将是最犀利的方法。那么，我们就不难理解，为什么<code>SEL</code>仅仅是函数名了。</p>
<p>本质上，<code>SEL</code>只是一个指向方法的指针（准确的说，只是一个根据方法名<code>hash</code>化了的<code>KEY</code>值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的<code>selector</code>，也可以在运行时获取已存在的<code>selector</code>，我们可以通过下面三种方法来获取SEL:</p>
<ol>
<li><code>sel_registerName</code>函数</li>
<li>Objective-C编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ol>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code>实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</div></pre></td></tr></table></figure>
<p>这个函数使用当前<code>CPU</code>架构实现的标准的C调用约定。第一个参数是指向<code>self</code>的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(<code>selector</code>)，接下来是方法的实际参数列表。</p>
<p>前面介绍过的<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的。由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>，查找过程将在下面讨论。取得<code>IMP</code>后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得<code>IMP</code>，我们可以跳过Runtime的消息传递机制，直接执行<code>IMP</code>指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>介绍完<code>SEL</code>和<code>IMP</code>，我们就可以来讲讲<code>Method</code>了。<code>Method</code>用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                	OBJC2_UNAVAILABLE;	<span class="comment">// 方法名</span></div><div class="line">    <span class="keyword">char</span> *method_types                	OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp             			OBJC2_UNAVAILABLE;	<span class="comment">// 方法实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个<code>SEL</code>和<code>IMP</code>，实际上相当于在<code>SEL</code>和<code>IMP</code>之间作了一个映射。有了SEL，我们便可以找到对应的<code>IMP</code>，从而调用方法的实现代码。具体操作流程我们将在下面讨论。</p>
<h4 id="objc-method-description"><a href="#objc-method-description" class="headerlink" title="objc_method_description"></a>objc_method_description</h4><p><code>objc_method_description</code>定义了一个Objective-C方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_method_description &#123; SEL name; <span class="keyword">char</span> *types; &#125;;</div></pre></td></tr></table></figure>
<h2 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h2><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法操作相关函数包括下以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"></div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"></div><div class="line"><span class="comment">// 获取方法名</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 返回方法的实现</span></div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"></div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"></div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div><div class="line"></div><div class="line"><span class="comment">// 设置方法的实现</span></div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"></div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个<code>SEL</code>。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h3><p>选择器相关的操作函数包括：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"></div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"></div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"></div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在<code>Objective-C Runtime</code>系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h2 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h2><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到<code>selector</code>对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体<code>objc_class</code>，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code>。</li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="image"></p>
<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的<code>isa</code>指针获取到类的结构体，然后在方法分发表里面查找方法的<code>selector</code>。如果没有找到<code>selector</code>，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的<code>selector</code>。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到<code>selector</code>，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到<code>selector</code>，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的<code>selector</code>及对应的方法的地址。这点我们在<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">前面</a>讨论过，不再重复。</p>
<h3 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h3><p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用<code>self</code>来引用接收者对象，使用<code>_cmd</code>来引用选择器。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span>  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这两个参数我们用得比较多的是<code>self</code>，<code>_cmd</code>在实际中用得比较少。</p>
<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"></div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++)</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>。</p>
<p>当然这种方式只适合于在类似于<code>for</code>循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓”<strong>消息转发(message forwarding)</strong>“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940</div><div class="line"></div><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'</div></pre></td></tr></table></figure>
<p>这段异常信息实际上是由NSObject的”<code>doesNotRecognizeSelector</code>“方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法””。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</div><div class="line">    SUTRuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)object &#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">        _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</div><div class="line"></div><div class="line">    <span class="comment">// 将消息转发给_helper来处理</span></div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> _helper;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div></pre></td></tr></table></figure>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的<code>selector</code>提供一个合适的方法签名。</p>
<p>完整的示例如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">    <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_helper];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h3 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h3><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector])</div><div class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">		 * be forwarded to another object and whether that  *</div><div class="line">		 * object can respond to it. Return YES if it can.  */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">NO</span>; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在此，我们已经了解了Runtime中消息发送和转发的基本机制。这也是Runtime的强大之处，通过它，我们可以为程序增加很多动态的行为，虽然我们在实际开发中很少直接使用这些机制(如直接调用<code>objc_msgSend</code>)，但了解它们有助于我们更多地去了解底层的实现。其实在实际的编码过程中，我们也可以灵活地使用这些机制，去实现一些特殊的功能，如<code>hook</code>操作等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.xcoder.cn/html/2013/objc_0304/1373.html" target="_blank" rel="external">Objective-C runtime之消息（二）</a></li>
<li><a href="http://www.cnblogs.com/kesalin/archive/2011/08/15/objc_method_base.html" target="_blank" rel="external">深入浅出Cocoa之消息</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/30/objective-c-runtime-2/" itemprop="url">
                  Objective-C Runtime 运行时之二：成员变量与属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-30T16:03:21+08:00" content="2014-10-30">
              2014-10-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/objectivec/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>
<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>
<h2 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h2><p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的<code>selector</code>关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用<code>@encode</code>编译器指令来获取它。当给定一个类型时，<code>@encode</code>返回这个类型的字符串编码。这些类型可以是诸如<code>int</code>、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为<code>sizeof()</code>操作参数的类型都可以用于<code>@encode()</code>。</p>
<p>在<code>Objective-C Runtime Programming Guide</code>中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>
<p><em>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em></p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> a[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"array encoding type: %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(a)));</div></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">54.731</span> RuntimeTest[<span class="number">942</span>:<span class="number">50791</span>] array encoding type: [<span class="number">3</span>f]</div></pre></td></tr></table></figure>
<p>其它类型可参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>，在此不细说。</p>
<p>另外，还有些编码类型，<code>@encode</code>虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、<code>retain</code>等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a>。</p>
<h2 id="成员变量、属性"><a href="#成员变量、属性" class="headerlink" title="成员变量、属性"></a>成员变量、属性</h2><p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>是表示实例变量的类型，其实际是一个指向<code>objc_ivar</code>结构体的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *ivar_name               	OBJC2_UNAVAILABLE;	<span class="comment">// 变量名</span></div><div class="line">    <span class="keyword">char</span> *ivar_type             	OBJC2_UNAVAILABLE;	<span class="comment">// 变量类型</span></div><div class="line">    <span class="keyword">int</span> ivar_offset            		OBJC2_UNAVAILABLE;	<span class="comment">// 基地址偏移字节</span></div><div class="line"></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                 		OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h4><p><code>objc_property_t</code>是表示Objective-C声明的属性的类型，其实际是指向<code>objc_property</code>结构体的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure>
<h4 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h4><p><code>objc_property_attribute_t</code>定义了属性的特性(<code>attribute</code>)，它是一个结构体，定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 特性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>
<h3 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h3><p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>
<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(<code>Ivar</code>)放在类声明的头文件中，或者放在类实现的<code>@implementation</code>后面。但这有一个缺点，我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是<code>Ivar</code>，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(<code>Associated Object</code>)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个<code>void</code>指针(<code>const void *</code>)。我们还需要指定一个内存管理策略，以告诉<code>Runtime</code>如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">OBJC_ASSOCIATION_ASSIGN</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC</div><div class="line">OBJC_ASSOCIATION_RETAIN</div><div class="line">OBJC_ASSOCIATION_COPY</div></pre></td></tr></table></figure>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是<code>assign</code>，则宿主释放时，关联对象不会被释放；而如果指定的是<code>retain</code>或者是<code>copy</code>，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动<code>retain/copy</code>。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</div></pre></td></tr></table></figure>
<p>在这种情况下，<code>self</code>对象将获取一个新的关联的对象<code>anObject</code>，且内存管理策略是自动<code>retain</code>关联对象，当<code>self</code>对象释放时，会自动<code>release</code>关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</div></pre></td></tr></table></figure>
<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>假定我们想要动态地将一个Tap手势操作连接到任何<code>UIView</code>中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的<code>UIView</code>对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)setTapActionWithBlock:(void (^)(void))block</div><div class="line">&#123;</div><div class="line">	UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);</div><div class="line"> </div><div class="line">	if (!gesture)</div><div class="line">	&#123;</div><div class="line">		gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];</div><div class="line">		[self addGestureRecognizer:gesture];</div><div class="line">		objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line">```	</div><div class="line"></div><div class="line">这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意`block`对象的关联内存管理策略。</div><div class="line"></div><div class="line">手势识别对象需要一个`target`和`action`，所以接下来我们定义处理方法：</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line">- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</div><div class="line">&#123;</div><div class="line">	if (gesture.state == UIGestureRecognizerStateRecognized)</div><div class="line">	&#123;</div><div class="line">		void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);</div><div class="line"></div><div class="line">		if (action)</div><div class="line">		&#123;</div><div class="line">			action();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要检测手势识别对象的状态，因为我们只需要在点击手势被识别出来时才执行操作。</p>
<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>
<h3 id="成员变量、属性的操作方法"><a href="#成员变量、属性的操作方法" class="headerlink" title="成员变量、属性的操作方法"></a>成员变量、属性的操作方法</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量操作包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"></div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"></div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure>
<ul>
<li><code>ivar_getOffset</code>函数，对于类型<code>id</code>或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><p>关联对象操作函数包括以下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"></div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"></div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div></pre></td></tr></table></figure>
<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性操作相关函数包括以下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"></div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"></div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"></div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<ul>
<li><code>property_copyAttributeValue</code>函数，返回的<code>char *</code>在使用完后需要调用<code>free()</code>释放。</li>
<li><code>property_copyAttributeList</code>函数，返回值在使用完后需要调用<code>free()</code>释放。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   name;                  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   status;                 </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>接口A、B返回的字典数据如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@&#123;<span class="string">@"name1"</span>: <span class="string">"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;</div><div class="line">@&#123;<span class="string">@"name2"</span>: <span class="string">"张三"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;</div></pre></td></tr></table></figure>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span>	</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    map = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    map[<span class="string">@"name1"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status1"</span>]              = <span class="string">@"status"</span>;</div><div class="line">    map[<span class="string">@"name2"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status2"</span>]              = <span class="string">@"status"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上面的代码将两个字典中不同的字段映射到<code>MyObject</code>中相同的属性上，这样，转换方法可如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</div><div class="line">&#123;</div><div class="line">    [dic enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">NSString</span> *propertyKey = [<span class="keyword">self</span> propertyForKey:key];</div><div class="line">        <span class="keyword">if</span> (propertyKey)</div><div class="line">        &#123;</div><div class="line">            objc_property_t property = class_getProperty([<span class="keyword">self</span> <span class="keyword">class</span>], [propertyKey UTF8String]);</div><div class="line"></div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></div><div class="line">            <span class="built_in">NSString</span> *attributeString = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            [<span class="keyword">self</span> setValue:obj forKey:propertyKey];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章中我们讨论了Runtime中与成员变量和属性相关的内容。成员变量与属性是类的数据基础，合理地使用Runtime中的相关操作能让我们更加灵活地来处理与类数据相关的工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.cocoanetics.com/2012/06/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/25/objective-c-runtime-1/" itemprop="url">
                  Objective-C Runtime 运行时之一：类与对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-25T21:00:05+08:00" content="2014-10-25">
              2014-10-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/objectivec/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p><code>Runtime</code>库主要做下面几件事：</p>
<ol>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ol>
<p>Objective-C runtime目前有两个版本：<code>Modern runtime</code>和<code>Legacy runtime</code>。<code>Modern Runtime</code>覆盖了64位的<code>Mac OS X Apps</code>，还有<code>iOS Apps</code>，<code>Legacy Runtime</code>是早期用来给32位 <code>Mac OS X Apps</code> 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>
<h2 id="类与对象基础数据结构"><a href="#类与对象基础数据结构" class="headerlink" title="类与对象基础数据结构"></a>类与对象基础数据结构</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Objective-C类是由<code>Class</code>类型来表示的，它实际上是一个指向<code>objc_class</code>结构体的指针。它的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure>
<p>查看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line"></div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                   	OBJC2_UNAVAILABLE;	<span class="comment">// 父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                      	OBJC2_UNAVAILABLE;	<span class="comment">// 类名</span></div><div class="line">    <span class="keyword">long</span> version                          	OBJC2_UNAVAILABLE;	<span class="comment">// 类的版本信息，默认为0</span></div><div class="line">    <span class="keyword">long</span> info                            	OBJC2_UNAVAILABLE;	<span class="comment">// 类信息，供运行期使用的一些位标识</span></div><div class="line">    <span class="keyword">long</span> instance_size                   	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的实例变量大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars         	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的成员变量链表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists 	OBJC2_UNAVAILABLE;	<span class="comment">// 方法定义的链表</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache              	OBJC2_UNAVAILABLE;	<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols 	OBJC2_UNAVAILABLE;	<span class="comment">// 协议链表</span></div><div class="line"></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>在这个定义中，下面几个字段是我们感兴趣的</p>
<ol>
<li><code>isa</code>：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的<code>Class</code>里面也有一个<code>isa</code>指针，它指向<code>metaClass</code>(元类)，我们会在后面介绍它。</li>
<li><code>super_class</code>：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则<code>super_class</code>为NULL。</li>
<li><code>cache</code>：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据<code>isa</code>指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是<code>methodLists</code>中遍历一遍，性能势必很差。这时，<code>cache</code>就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到<code>cache</code>列表中，下次调用的时候runtime就会优先去<code>cache</code>中查找，如果<code>cache</code>没有，才去<code>methodLists</code>中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li><code>version</code>：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ol>
<p>针对<code>cache</code>，我们用下面例子来说明其执行过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] init];</div><div class="line">```	</div><div class="line"></div><div class="line">其流程是：</div><div class="line"></div><div class="line"><span class="number">1.</span> `[<span class="built_in">NSArray</span> alloc]`先被执行。因为<span class="built_in">NSArray</span>没有`+alloc`方法，于是去父类<span class="built_in">NSObject</span>去查找。</div><div class="line"><span class="number">2.</span> 检测<span class="built_in">NSObject</span>是否响应`+alloc`方法，发现响应，于是检测<span class="built_in">NSArray</span>类，并根据其所需的内存空间大小开始分配内存空间，然后把`isa`指针指向<span class="built_in">NSArray</span>类。同时，`+alloc`也被加进cache列表里面。</div><div class="line"><span class="number">3.</span> 接着，执行`-init`方法，如果<span class="built_in">NSArray</span>响应该方法，则直接将其加入`cache`；如果不响应，则去父类查找。</div><div class="line"><span class="number">4.</span> 在后期的操作中，如果再以`[[<span class="built_in">NSArray</span> alloc] init]`这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</div><div class="line"></div><div class="line"><span class="meta">### objc_object与id</span></div><div class="line"></div><div class="line">`objc_object`是表示一个类的实例的结构体，它的定义如下(`objc/objc.h`)：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure>
<p>可以看到，这个结构体只有一个字体，即指向其类的<code>isa</code>指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的<code>isa</code>指针找到这个实例对象所属的类。<code>Runtime</code>库会在类的方法列表及父类的方法列表中去寻找与消息对应的<code>selector</code>指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个<code>objc_object</code>数据结构，然后是类的实例变量的数据。NSObject类的<code>alloc</code>和<code>allocWithZone:</code>方法使用函数<code>class_createInstance</code>来创建<code>objc_object</code>数据结构。</p>
<p>另外还有我们常见的id，它是一个<code>objc_object</code>结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中<code>void *</code>指针类型的作用。</p>
<h3 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h3><p>上面提到了<code>objc_class</code>结构体中的<code>cache</code>字段，它用于缓存调用过的方法。这个字段是一个指向<code>objc_cache</code>结构体的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该结构体的字段描述如下：</p>
<ol>
<li><code>mask</code>：一个整数，指定分配的缓存<code>bucket</code>的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法<code>selector</code>的指针与该字段做一个<code>AND</code>位操作<code>(index = (mask &amp; selector))</code>。这可以作为一个简单的<code>hash</code>散列算法。</li>
<li><code>occupied</code>：一个整数，指定实际占用的缓存<code>bucket</code>的总数。</li>
<li><code>buckets</code>：指向<code>Method</code>数据结构指针的数组。这个数组可能包含不超过<code>mask+1</code>个元素。需要注意的是，指针可能是NULL，表示这个缓存<code>bucket</code>没有被占用，另外被占用的<code>bucket</code>可能是不连续的。这个数组可能会随着时间而增长。</li>
</ol>
<h3 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h3><p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</div></pre></td></tr></table></figure>
<p>这个例子中，<code>+array</code>消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个<code>objc_object</code>指针，它包含一个指向其类的一个<code>isa</code>指针。那么这些就有一个问题了，这个<code>isa</code>指针指向什么呢？为了调用<code>+array</code>方法，这个类的<code>isa</code>指针必须指向一个包含这些类方法的一个<code>objc_class</code>结构体。这就引出了<code>meta-class</code>的概念</p>
<pre><code>meta-class是一个类对象的类。
</code></pre><p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的<code>meta-class</code>的方法列表中查找。</p>
<p><code>meta-class</code>之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的<code>meta-class</code>，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，<code>meta-class</code>也是一个类，也可以向它发送一个消息，那么它的<code>isa</code>又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的<code>meta-class</code>的<code>isa</code>指向基类的<code>meta-class</code>，以此作为它们的所属类。即，任何NSObject继承体系下的<code>meta-class</code>都使用NSObject的<code>meta-class</code>作为自己的所属类，而基类的<code>meta-class</code>的<code>isa</code>指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对<code>objc_class</code>结构体中<code>super_class</code>指针的分析，我们就可以描绘出类及相应<code>meta-class</code>类的一个继承体系了，如下图所示：</p>
<p><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt="image"></p>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和<code>meta-class</code>都是有效的；而类方法对于体系内的所有类和<code>meta-class</code>都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</div><div class="line"></div><div class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</div><div class="line">        currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</div><div class="line"></div><div class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">"TestClass"</span>, <span class="number">0</span>);</div><div class="line">    class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</div><div class="line">    objc_registerClassPair(newClass);</div><div class="line"></div><div class="line">    <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个例子是在运行时创建了一个<code>NSError</code>的子类<code>TestClass</code>，然后为这个子类添加一个方法<code>testMetaClass</code>，这个方法的实现是<code>TestMetaClass</code>函数。</p>
<p>运行后，打印结果是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000</div><div class="line">2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0</div></pre></td></tr></table></figure>
<p>我们在for循环中，我们通过<code>objc_getClass</code>来获取对象的<code>isa</code>，并将其打印出来，依此一直回溯到NSObject的<code>meta-class</code>。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的<code>meta-class</code>的类地址。</p>
<p><em>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</em></p>
<h2 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h2><p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以<code>class_</code>为前缀的，而对象的操作方法大部分是以<code>objc_</code>或<code>object_</code>为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h3 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h3><p>我们可以回过头去看看<code>objc_class</code>的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<h4 id="类名-name"><a href="#类名-name" class="headerlink" title="类名(name)"></a>类名(name)</h4><p>类名操作的函数主要有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div></pre></td></tr></table></figure>
<ul>
<li>对于<code>class_getName</code>函数，如果传入的<code>cls</code>为<code>Nil</code>，则返回一个字字符串。</li>
</ul>
<h4 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h4><p>父类和元类操作的函数主要有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div></pre></td></tr></table></figure>
<ul>
<li><p><code>class_getSuperclass</code>函数，当<code>cls</code>为Nil或者<code>cls</code>为根类时，返回Nil。不过通常我们可以使用NSObject类的<code>superclass</code>方法来达到同样的目的。</p>
</li>
<li><p><code>class_isMetaClass</code>函数，如果是<code>cls</code>是元类，则返回YES；如果否或者传入的<code>cls</code>为Nil，则返回NO。</p>
</li>
</ul>
<h4 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h4><p>实例变量大小操作的函数有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div></pre></td></tr></table></figure>
<h4 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h4><p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表<code>ivars</code>中的。<code>ivars</code>是一个数组，数组中每个元素是指向<code>Ivar</code>(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<p>1.成员变量操作函数，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<ul>
<li><p><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的<code>objc_ivar</code>结构体的指针(<code>Ivar</code>)。</p>
</li>
<li><p><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>
</li>
<li><p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是<code>1&lt;&lt;alignment</code>。这取决于<code>ivar</code>的类型和机器的架构。如果变量的类型是指针类型，则传递<code>log2(sizeof(pointer_type))</code>。</p>
</li>
<li><p><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的<code>objc_ivar</code>结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code>指针返回数组的大小。需要注意的是，我们必须使用<code>free()</code>来释放这个数组。</p>
</li>
</ul>
<p>2.属性操作函数，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取指定的属性</span></div><div class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取属性列表</span></div><div class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 为类添加属性</span></div><div class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"></div><div class="line"><span class="comment">// 替换类的属性</span></div><div class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div></pre></td></tr></table></figure>
<p>这一种方法也是针对<code>ivars</code>来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理<code>strong/weak</code>引用。这几个函数定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> uint8_t * class_getIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div><div class="line"><span class="keyword">const</span> uint8_t * class_getWeakIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setWeakIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div></pre></td></tr></table></figure>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
<h4 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h4><p>方法操作主要有以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 获取实例方法</span></div><div class="line">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类方法</span></div><div class="line">Method class_getClassMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取所有方法的数组</span></div><div class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 替代方法的实现</span></div><div class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 返回方法的具体实现</span></div><div class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 类实例是否响应指定的selector</span></div><div class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure>
<ul>
<li><code>class_addMethod</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用<code>method_setImplementation</code>。一个Objective-C方法是一个简单的C函数，它至少包含两个参数–<code>self</code>和<code>_cmd</code>。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</li>
<li><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。</p>
<p>另外，参数<code>types</code>是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
<ul>
<li><p><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数，与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li><p><code>class_copyMethodList</code>函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls), &amp;count)</code>(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。<code>outCount</code>参数返回方法的个数。在获取到列表后，我们需要使用<code>free()</code>方法来释放它。</p>
</li>
<li><p><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已存在name指定的方法，则类似于<code>method_setImplementation</code>一样替代原方法的实现。</p>
</li>
<li><p><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls, name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应<code>selector</code>，则返回的函数指针将是运行时消息转发机制的一部分。</p>
</li>
<li><p><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instancesRespondToSelector:</code>方法来达到相同目的。</p>
</li>
</ul>
<h4 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议(objc_protocol_list)"></a>协议(objc_protocol_list)</h4><p>协议相关的操作包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<ul>
<li><p><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来替代。</p>
</li>
<li><p><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用<code>free()</code>手动释放。</p>
</li>
</ul>
<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><p>版本相关的操作包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div></pre></td></tr></table></figure>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>runtime还提供了两个函数来供<code>CoreFoundation</code>的<code>tool-free bridging</code>使用，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class objc_getFutureClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="keyword">void</span> objc_setFutureClass ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure>
<p>通常我们不直接使用这两个函数。</p>
<h4 id="实例-Example"><a href="#实例-Example" class="headerlink" title="实例(Example)"></a>实例(Example)</h4><p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line">+ (<span class="keyword">void</span>)classMethod1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</div><div class="line">    <span class="built_in">NSInteger</span>       _instance1;</div><div class="line">    <span class="built_in">NSString</span>    *   _instance2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"call method method1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>, arg1, arg2);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// main.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MySubClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    </div><div class="line">        MyClass *myClass = [[MyClass alloc] init];</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">        Class cls = myClass.class;</div><div class="line"></div><div class="line">        <span class="comment">// 类名</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 父类</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"super class name: %s"</span>, class_getName(class_getSuperclass(cls)));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 是否是元类</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ a meta-class"</span>, (class_isMetaClass(cls) ? <span class="string">@""</span> : <span class="string">@"not"</span>));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        Class meta_class = objc_getMetaClass(class_getName(cls));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s's meta-class is %s"</span>, class_getName(cls), class_getName(meta_class));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 变量实例大小</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instance size: %zu"</span>, class_getInstanceSize(cls));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 成员变量</span></div><div class="line">        Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"instance variable's name: %s at index: %d"</span>, ivar_getName(ivar), i);</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line"></div><div class="line">        Ivar string = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</div><div class="line">        <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"instace variable %s"</span>, ivar_getName(string));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 属性操作</span></div><div class="line">        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">            objc_property_t property = properties[i];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"property's name: %s"</span>, property_getName(property));</div><div class="line">        &#125;</div><div class="line">        free(properties);</div><div class="line"></div><div class="line">        objc_property_t array = class_getProperty(cls, <span class="string">"array"</span>);</div><div class="line">        <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"property %s"</span>, property_getName(array));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 方法操作</span></div><div class="line">        Method *methods = class_copyMethodList(cls, &amp;outCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">            Method method = methods[i];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"method's signature: %s"</span>, method_getName(method));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        free(methods);</div><div class="line"></div><div class="line">        Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">        <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"method %s"</span>, method_getName(method1));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</div><div class="line">        <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"class method : %s"</span>, method_getName(classMethod));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsd to selector: method3WithArg1:arg2:"</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@""</span> : <span class="string">@" not"</span>);</div><div class="line"></div><div class="line">        IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">        imp();</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 协议</span></div><div class="line">        Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</div><div class="line">        Protocol * protocol;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">            protocol = protocols[i];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"protocol name: %s"</span>, protocol_getName(protocol));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsed to protocol %s"</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@""</span> : <span class="string">@" not"</span>, protocol_getName(protocol));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序的输出如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass</div><div class="line">2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding</div><div class="line">2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ==========================================================</div></pre></td></tr></table></figure>
<h3 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h3><p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h4 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h4><p>动态创建类涉及到以下几个函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes );</div><div class="line"></div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则<code>superclass</code>指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引<code>ivars</code>的字节数。</li>
</ul>
<p>为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>，<code>class_addIvar</code>等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
<ul>
<li><code>objc_disposeClassPair</code>函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</li>
</ul>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line"></div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line"></div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line"></div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div></pre></td></tr></table></figure>
<p>程序的输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div></pre></td></tr></table></figure>
<h4 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h4><p>动态创建对象的函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</div><div class="line"></div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</div><div class="line"></div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<ul>
<li><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</li>
</ul>
<p>调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"> </div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"></div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</div></pre></td></tr></table></figure>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认占位符类<code>__NSCFConstantString</code>。</p>
<ul>
<li><p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
</li>
<li><p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
</li>
</ul>
<h3 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h3><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<p>1.针对整个对象进行操作的函数，这类函数包含</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"></div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure>
<p>2.针对对象实例变量进行操作的函数，这类函数包含：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 修改类实例的实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"></div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"></div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"></div><div class="line"><span class="comment">// 返回对象中实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"></div><div class="line"><span class="comment">// 设置对象中实例变量的值</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div></pre></td></tr></table></figure>
<p>如果实例变量的<code>Ivar</code>已经知道，那么调用<code>object_getIvar</code>会比<code>object_getInstanceVariable</code>函数快，相同情况下，<code>object_setIvar</code>也比<code>object_setInstanceVariable</code>快。</p>
<p>3.针对对象的类进行操作的函数，这类函数包含：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"></div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"></div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure>
<h3 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h3><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用<code>objc_addClass</code>函数来注册它们。<code>runtime</code>提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"></div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<p>下面代码演示了该函数的用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> numClasses;</div><div class="line">Class * classes = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</div><div class="line">    classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</div><div class="line">    numClasses = objc_getClassList(classes, numClasses);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</div><div class="line"></div><div class="line">        Class cls = classes[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] number of classes: <span class="number">1282</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: DDTokenRegexp</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _PFRoutines</div><div class="line">......还有大量输出</div></pre></td></tr></table></figure>
<ul>
<li><p>获取类定义的方法有三个：<code>objc_lookUpClass</code>, <code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</p>
</li>
<li><p><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这一章中我们介绍了<code>Runtime</code>运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="http://www.cnblogs.com/whyandinside/archive/2013/02/26/2933552.html" target="_blank" rel="external">Objective-C Runtime的数据类型</a></li>
<li><a href="http://blog.csdn.net/windyitian/article/details/19810875" target="_blank" rel="external">详解Objective-C的meta-class</a></li>
<li><a href="http://stackoverflow.com/questions/16131172/what-are-class-setivarlayout-and-class-getivarlayout" target="_blank" rel="external">what are class_setIvarLayout and class_getIvarLayout?</a></li>
<li><a href="http://stackoverflow.com/questions/3805499/whats-the-difference-between-doing-alloc-and-class-createinstance" target="_blank" rel="external">What’s the difference between doing alloc and class_createInstance</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/19/instancetype/" itemprop="url">
                  instancetype
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-19T00:26:03+08:00" content="2014-10-19">
              2014-10-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：原文由Mattt <code>Thompson</code>发表于<code>nshipster</code>：<a href="http://nshipster.com/instancetype/" target="_blank" rel="external">instancetype</a>。<strong>文章是2012年写的，所以有些内容现在已不适用。</strong></p>
<p>在<code>Objective-C</code>中，约定(<code>conventions</code>)不仅仅是编码最佳实践的问题，同时对编译器来说，也是一种隐式说明。</p>
<p>例如，<code>alloc</code>和<code>init</code>两个方法都返回<code>id</code>类型，而在<code>Xcode</code>中，编译器会对它们进行类型检查。这是怎么做到的呢？</p>
<p>在<code>Cocoa</code>中，有一个这样的约定，命名为<code>alloc/init</code>的方法总是返回接收者类的实例。这些方法有一个相关的返回类型。</p>
<p>而类的构造方法(类方法)，虽然他们都是返回<code>id</code>类型，但没有从类型检查中获得好处，因为他们不遵循命名约定。</p>
<p>我们可以试试以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[[<span class="built_in">NSArray</span> alloc] init] mediaPlaybackAllowsAirPlay]; <span class="comment">// 报错： "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"</span></div><div class="line"></div><div class="line">[[<span class="built_in">NSArray</span> array] mediaPlaybackAllowsAirPlay]; <span class="comment">// (No error) 注：这个方法调用只在老的编译器上成立，新的编译器会报相同的错误。</span></div></pre></td></tr></table></figure>
<p>由于<code>alloc</code>和<code>init</code>遵循返回相关结果类型的约定，所以会对<code>NSArray</code>执行类型检查。然而等价的类构造方法<code>array</code>则不遵循这一约定，只解释为<code>id</code>类型。</p>
<p><code>id</code>类型在不需要确保类型安全时非常有用，但一旦需要时，就无法处理了。</p>
<p>而另一种方法，即显示声明返回类型(如前面例子中的(<code>NSArray *</code>))稍微改善了一些，但写起来有点麻烦，而且在继承体系中表现得不是很好。</p>
<p>这时编译器就需要去解决这种针对<code>Objective-C</code>类型系统的边界情况了:</p>
<p><code>instancetype</code>是一个上下文关键字，可用在返回类型中以表示方法返回一个相关的结果类型，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>使用<code>instancetype</code>，编译器可以正确地知道<code>personWithName:</code>的返回结果是一个<code>Person</code>实例。</p>
<p>我们现在看<code>Foundation</code>中的类构造器，可以发现大部分已经开始使用了<code>instancetype</code>了。新的<code>API</code>，如<code>UICollectionViewLayoutAttributes</code>，都是使用<code>instancetype</code>了。</p>
<p><em>注：<code>instancetype</code>与<code>id</code>不同的是，它只能用在方法声明的返回值中。</em></p>
<h4 id="更进一步的启示"><a href="#更进一步的启示" class="headerlink" title="更进一步的启示"></a>更进一步的启示</h4><p>语言特性是特别有趣的，因为它不清楚在软件设计的更高层次方面会带来什么样的影响。</p>
<p>虽然<code>instancetype</code>看上去非常一般，只是对编译器有用，但也可能被用于一些更聪明的目的。</p>
<p><code>Jonathan Sterling</code>的文章<a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html" target="_blank" rel="external">this quite interesting article</a>，详细描述了<code>instancetype</code>如何被用于编码静态类型集合，而不需要使用泛型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> &lt;MapCollection&gt; *sites = (<span class="keyword">id</span>)[<span class="built_in">NSURL</span> mapCollection];</div><div class="line">[sites put:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.jonmsterling.com/"</span>]</div><div class="line">        at:<span class="string">@"jon"</span>];</div><div class="line">[sites put:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.nshipster.com/"</span>]</div><div class="line">        at:<span class="string">@"nshipster"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *jonsSite = [sites at:<span class="string">@"jon"</span>]; <span class="comment">// =&gt; http://www.jonmsterling.com/</span></div></pre></td></tr></table></figure>
<p>静态类型集合使得API更有表现力，这样开发者将不再需要去确定集合中的参数可以使用使用类型的对象了。</p>
<p>不管这会不会成为<code>Objective-C</code>公认的约定，诸如<code>instancetype</code>这样一个低层特性可用于改变语言的形态已是非常棒的一件事了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/17/osatomic-operation/" itemprop="url">
                  OSAtomic原子操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-17T10:56:00+08:00" content="2014-10-17">
              2014-10-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发编程一个主要问题就是如何同步数据。同步数据的方式有很多种，这里我们介绍一下<code>libkern/OSAtomic.h</code>。这个头文件包含是大量关于原子操作和同步操作的函数，如果要对数据进行同步操作，这里面的函数可以作为我们的首选项。不同平台这些函数的实现是自定义的。另外，它们是线程安全的。</p>
<p>需要注意的是，传递给这些函数的所有地址都必须是“自然对齐”的，例如<code>int32_t *</code>指针必须是32位对齐的(地址的低位2个bit为0)，<code>int64_t *</code>指针必须是64位对齐的(低3位为0)。</p>
<p>这些原子函数的一些版本整合了内存屏障(memory barriers)，而另一些则没有。在诸如PPC这样的弱有序(weakly-ordered)架构中，Barriers严格限制了内存访问顺序。所有出现在barriers之前的加载和存储操作完成后，才会运行barriers之后的加载和存储操作。</p>
<p>在单处理器系统中，barriers操作通常是一个空操作。在多处理器系统中，barriers在某些平台上可能是相当昂贵的操作，如PPC。</p>
<p>大多数代码都应该使用barrier函数来确保在线程间共享的内存是正确同步的。例如，如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用<code>OSAtomicIncrement32Barrier</code>来确保数据结构的存储操作在变量自动增加前完成。</p>
<p>同样的，该数据结构的消费者也必须使用<code>OSAtomicIncrement32Barrier</code>，以确保在自动递增变量值之后再去加载这些数据。另一方面，如果我们只是简单地递增一个全局计数器，那么使用<code>OSAtomicIncrement32</code>会更安全且可能更快。</p>
<p>如果不能确保我们使用的是哪个版本，则使用barrier变量以保证是安全的。</p>
<p>另外，自旋锁和队列操作总是包含一个barrier。</p>
<p>这个头文件中的函数主要可以分为以下几类</p>
<h2 id="内存屏障-Memory-barriers"><a href="#内存屏障-Memory-barriers" class="headerlink" title="内存屏障(Memory barriers)"></a>内存屏障(Memory barriers)</h2><p>内存屏障的概念如上所述，它是一种屏障和指令类，可以让CPU或编译器强制将barrier之前和之后的内存操作分开。CPU采用了一些可能导致乱序执行的性能优化。在单个线程的执行中，内存操作的顺序一般是悄无声息的，但是在并发编程和设备驱动程序中就可能出现一些不可预知的行为，除非我们小心地去控制。排序约束的特性是依赖于硬件的，并由架构的内存顺序模型来定义。一些架构定义了多种barrier来执行不同的顺序约束。</p>
<p><code>OSMemoryBarrier()</code>函数就是用来设置内存屏障，它即可以用于读操作，也可以用于写操作。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码来自ReactiveCocoa:RACDisposable类</span></div><div class="line">	</div><div class="line">- (<span class="keyword">id</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]);</div><div class="line">    OSMemoryBarrier();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自旋锁-Spinlocks"><a href="#自旋锁-Spinlocks" class="headerlink" title="自旋锁(Spinlocks)"></a>自旋锁(Spinlocks)</h2><p>自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。</p>
<p><code>libkern/OSAtomic.h</code>中包含了三个关于自旋锁的函数：<code>OSSpinLockLock</code>, <code>OSSpinLockTry</code>, <code>OSSpinLockUnlock</code>。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码来自ReactiveCocoa:RACCompoundDisposable类</span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dispose &#123;</div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">    RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];</div><div class="line"><span class="meta">#endif</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFArrayRef</span> remainingDisposables = <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    OSSpinLockLock(&amp;_spinLock);</div><div class="line">    &#123;</div><div class="line">        _disposed = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</div><div class="line">            inlineCopy[i] = _inlineDisposables[i];</div><div class="line">            _inlineDisposables[i] = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">        </div><div class="line">        remainingDisposables = _disposables;</div><div class="line">        _disposables = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    OSSpinLockUnlock(&amp;_spinLock);</div><div class="line">    </div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">    <span class="comment">// Dispose outside of the lock in case the compound disposable is used</span></div><div class="line">    <span class="comment">// recursively.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</div><div class="line">        [inlineCopy[i] dispose];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (remainingDisposables == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(remainingDisposables);</div><div class="line">    <span class="built_in">CFArrayApplyFunction</span>(remainingDisposables, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, count), &amp;disposeEach, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CFRelease</span>(remainingDisposables);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原子队列操作"><a href="#原子队列操作" class="headerlink" title="原子队列操作"></a>原子队列操作</h2><p>队列操作主要包含两类：</p>
<ol>
<li>不加锁的FIFO入队和出队原子操作，包含<code>OSAtomicFifoDequeue</code>和<code>OSAtomicFifoEnqueue</code>两个函数</li>
<li>不加锁的LIFO入队和出队原子操作，包含<code>OSAtomicDequeue</code>和<code>OSAtomicEnqueue</code>两个函数。这两个函数是线程安全的，对有潜在精确要求的代码来说，这会是强大的构建方式。</li>
</ol>
<h2 id="比较和交换"><a href="#比较和交换" class="headerlink" title="比较和交换"></a>比较和交换</h2><p>这组函数可以细分为三组函数：</p>
<ol>
<li><code>OSAtomicCompareAndSwap**[Barrier](type __oldValue, type __newValue, volatile type *__theValue)</code>：这组函数用于比较<code>__oldValue</code>是否与<code>__theValue</code>指针指向的内存位置的值匹配，如果匹配，则将<code>__newValue</code>的值存储到<code>__theValue</code>指向的内存位置。可以根据需要使用barrier版本。</li>
<li><code>OSAtomicTestAndClear/OSAtomicTestAndClearBarrier(uint32_t __n, volatile void * __theAddress)</code>：这组函数用于测试<code>__theAddress</code>指向的值中由<code>__n</code>指定的bit位，如果该位未被清除，则清除它。需要注意的是最低bit位应该是1，而不是0。对于一个64-bit的值来说，如果要清除最高位的值，则<code>__n</code>应该是64。</li>
<li><code>OSAtomicTestAndSet/OSAtomicTestAndSetBarrier(uint32_t __n, volatile void * __theAddress)</code>：与<code>OSAtomicTestAndClear</code>相反，这组函数测试值后，如果指定位没有设置，则设置它。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> * sharedBuffer(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> * buffer;</div><div class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">void</span> * newBuffer = calloc(<span class="number">1</span>, <span class="number">1024</span>);</div><div class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, newBuffer, &amp;buffer)) &#123;</div><div class="line">            free(newBuffer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码的作用是如果没有缓冲区，我们将创建一个newBuffer，然后将其写到buffer中。</p>
<h2 id="布尔操作-AND-OR-XOR"><a href="#布尔操作-AND-OR-XOR" class="headerlink" title="布尔操作(AND, OR, XOR)"></a>布尔操作(AND, OR, XOR)</h2><p>这组函数可根据以下两个规则来分类：</p>
<ol>
<li>是否使用Barrier</li>
<li>返回值是原始值还是操作完成后的值</li>
</ol>
<p>以And为例，有4个函数：<code>OSAtomicAnd32</code>, <code>OSAtomicAnd32Barrier</code>, <code>OSAtomicAnd32Orig</code>, <code>OSAtomicAnd32OrigBarrier</code>。每个函数均带有两个参数：<code>__theMask(uint32_t)</code>和<code>__theValue(volatile uint32_t *)</code>。函数将<code>__theMask</code>与<code>__theValue</code>指向的值做AND操作。</p>
<p>类似，还有OR操作和XOR操作。</p>
<h2 id="数学操作"><a href="#数学操作" class="headerlink" title="数学操作"></a>数学操作</h2><p>这组函数主要包括：</p>
<ol>
<li>加操作：<code>OSAtomicAdd**</code>, <code>OSAtomicAdd**Barrier</code></li>
<li>递减操作：<code>OSAtomicDecrement**</code>, <code>OSAtomicDecrement**Barrier</code></li>
<li>递增操作：<code>OSAtomicIncrement**</code>, <code>OSAtomicIncrement**Barrier</code></li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码摘自ReactiveCocoa:RACDynamicSequence</span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">volatile</span> int32_t directDeallocCount = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (OSAtomicIncrement32(&amp;directDeallocCount) &gt;= DEALLOC_OVERFLOW_GUARD) &#123;</div><div class="line">		OSAtomicAdd32(-DEALLOC_OVERFLOW_GUARD, &amp;directDeallocCount);</div><div class="line">	</div><div class="line">		<span class="comment">// Put this sequence's tail onto the autorelease pool so we stop</span></div><div class="line">		<span class="comment">// recursing.</span></div><div class="line">		__autoreleasing RACSequence *tail __attribute__((unused)) = _tail;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	_tail = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>相较于<code>@synchronized</code>，OSAtomic原子操作更趋于数据的底层，从更深层次来对单例进行保护。同时，它没有阻断其它线程对函数的访问。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/mac/documentation/System/Reference/OSAtomic_header_reference/Reference/reference.html" target="_blank" rel="external">OSAtomic.h User-Space Reference</a></li>
<li><a href="http://blog.csdn.net/wzb56_earl/article/details/6634622" target="_blank" rel="external">Memory barrier</a></li>
<li><a href="http://www.cocoachina.com/industry/20130821/6842.html" target="_blank" rel="external">Objc的底层并发API</a></li>
<li><a href="http://blog.csdn.net/tuxiangqi/article/details/8076972" target="_blank" rel="external">OSATOMIC与synchronized加锁的对比</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/23/tutorial-performance-and-time/" itemprop="url">
                  Tutorial performance and time
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-23T23:55:35+08:00" content="2014-09-23">
              2014-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="http://www.macresearch.org/tutorial_performance_and_time" target="_blank" rel="external">Tutorial performance and time</a></p>
<p>在讨论性能之前，先讨论一个重要的话题：时间。为了理解代码中的变化如何影响性能，我们需要一个排序的指标。有许多方法用于时间例程，一些比另一些合适。在本教程中我们将讨论<code>Mach Absolute Time</code>。</p>
<h2 id="为什么是Mach"><a href="#为什么是Mach" class="headerlink" title="为什么是Mach?"></a>为什么是Mach?</h2><p>时间例程依赖于所需要测量的时间域。某些情况下使用诸如<code>clock()</code>或<code>getrusage()</code>函数来做些简单的数学运算就足够了。如果时间例程将用于实际的开发框架之外，可移植性就很重要了。我不使用这些。为什么？</p>
<p>对于我来说，调试代码的典型问题是：</p>
<ol>
<li>我只需要在即时测试时使用时间例程</li>
<li>我不喜欢依赖于多种函数来包含不同的时间域。它们的行为可能不一致</li>
<li>有时我需要一个高精度定时器</li>
</ol>
<h2 id="欢迎了解mach-absolute-time"><a href="#欢迎了解mach-absolute-time" class="headerlink" title="欢迎了解mach_absolute_time"></a>欢迎了解mach_absolute_time</h2><p><code>mach_absolute_time</code>是一个<code>CPU</code>/总线依赖函数，返回一个基于系统启动后的时钟”嘀嗒”数。它没有很好的文档定义，但这不应该成为使用它的障碍，因为在<code>MAC OS X</code>上可以确保它的行为，并且，它包含系统时钟包含的所有时间区域。那是否应该在产品代码中使用它呢？可能不应该。但是对于测试，它却恰到好处。</p>
<p>使用<code>mach_absolute_time</code>时需要考虑两个因素：</p>
<ol>
<li>如何获取当前的<code>Mach</code>绝对时间</li>
<li>如何将其转换为有意义的数字</li>
</ol>
<h2 id="获取mach-absolute-time"><a href="#获取mach-absolute-time" class="headerlink" title="获取mach_absolute_time"></a>获取mach_absolute_time</h2><p>这非常简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> </span></div><div class="line"><span class="keyword">uint64_t</span> start = mach_absolute_time();</div><div class="line"><span class="keyword">uint64_t</span> stop = mach_absolute_time();</div></pre></td></tr></table></figure>
<p>这样就可以了。我们通常获取两个值，以得到这两个时间的时间差。</p>
<h2 id="将mach-absolute-time时间差转换为秒数"><a href="#将mach-absolute-time时间差转换为秒数" class="headerlink" title="将mach_absolute_time时间差转换为秒数"></a>将mach_absolute_time时间差转换为秒数</h2><p>这稍微有点复杂，因为我们需要获取<code>mach_absolute_time</code>所基于的系统时间基准。如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mach/mach_time.h&gt;</span> </span></div><div class="line"><span class="comment">//Raw mach_absolute_times going in,difference in seconds out</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">subtractTimes</span><span class="params">( uint64_tendTime, <span class="keyword">uint64_t</span> startTime )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint64_t</span> difference = endTime - startTime;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">double</span> conversion = <span class="number">0.0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>( conversion == <span class="number">0.0</span> )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">mach_timebase_info_data_t</span> info;</div><div class="line">		<span class="keyword">kern_return_t</span> err =mach_timebase_info( &amp;info );</div><div class="line">		</div><div class="line">		<span class="comment">//Convert the timebase into seconds</span></div><div class="line">		<span class="keyword">if</span>( err == <span class="number">0</span>  )</div><div class="line">			conversion= <span class="number">1e-9</span> * (<span class="keyword">double</span>) info.numer / (<span class="keyword">double</span>) info.denom;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> conversion * (<span class="keyword">double</span>)difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最重要的是调用<code>mach_timebase_info</code>。我们传递一个结构体以返回时间基准值。最后，一旦我们获取到系统的心跳，我们便能生成一个转换因子。通常，转换是通过分子(<code>info.numer</code>)除以分母(<code>info.denom</code>)。这里我乘了一个<code>1e-9</code>来获取秒数。最后，我们获取两个时间的差值，并乘以转换因子，便得到真实的时间差。</p>
<p>现在我们可能会想，为什么这比用<code>clock</code>好？看起来做了更多的事情。确实是有点，这便是为什么它在一个函数中。我们只需要传递我们的值到函数中并取得答案。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们写个例子。下面是完整的代码清单(包括<code>mach</code>函数)。可以使用<code>gcc mach.c –o mach</code>来编译它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mach/mach_time.h&gt;</span> </span></div><div class="line"></div><div class="line"><span class="comment">//Raw mach_absolute_times going in,difference in seconds out</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">subtractTimes</span><span class="params">( uint64_tendTime, <span class="keyword">uint64_t</span> startTime )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint64_t</span> difference = endTime -startTime;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">double</span> conversion = <span class="number">0.0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>( conversion == <span class="number">0.0</span> )</div><div class="line">	&#123;        </div><div class="line">		mach_timebase_info_data_tinfo;        </div><div class="line">		kern_return_terr = mach_timebase_info( &amp;info );                       <span class="comment">//Convert the timebaseinto seconds        </span></div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(err == <span class="number">0</span>  )                       </div><div class="line">			conversion= <span class="number">1e-9</span> * (<span class="keyword">double</span>) info.numer / (<span class="keyword">double</span>) info.denom;    </div><div class="line">	&#125;</div><div class="line">	         </div><div class="line">	<span class="keyword">return</span> conversion * (<span class="keyword">double</span>)difference;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	inti, j, count;</div><div class="line">	<span class="keyword">uint64_t</span> start,stop;</div><div class="line">	doublecurrent = <span class="number">0.0</span>;</div><div class="line">	doubleanswer = <span class="number">0.0</span>;</div><div class="line">	doubleelapsed = <span class="number">0.0</span>;</div><div class="line">	intdim1 = <span class="number">256</span>;</div><div class="line">	intdim2 = <span class="number">256</span>;</div><div class="line">	intsize = <span class="number">4</span>*dim1*dim2;</div><div class="line">	</div><div class="line">	<span class="comment">//Allocatesome memory and warm it up</span></div><div class="line">	<span class="keyword">double</span> *<span class="built_in">array</span> =(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));       </div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)<span class="built_in">array</span> = (<span class="keyword">double</span>)i;</div><div class="line">	</div><div class="line">	count= <span class="number">5</span>;     </div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</div><div class="line">	&#123;              </div><div class="line">		start = mach_absolute_time();                                 </div><div class="line">		<span class="comment">//dosome work</span></div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)</div><div class="line">		&#123;</div><div class="line">			answer+= <span class="built_in">sqrt</span>(<span class="built_in">array</span>[j]);</div><div class="line">		&#125;</div><div class="line">		stop = mach_absolute_time();</div><div class="line">		current= subtractTimes(stop,start);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Timefor iteration: %1.12lf for answer: %1.12lf\n"</span>,current, answer);</div><div class="line">		elapsed+= current;</div><div class="line">	&#125; </div><div class="line">	      </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\nTotaltime in seconds = %1.12lf for answer: %1.12lf\n"</span>,elapsed/count,answer);</div><div class="line">	<span class="built_in">free</span>(<span class="built_in">array</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在这里做了什么？在这个例子中，我们有一个适当大小的<code>double</code>数组，当中存放了一些数字，然后获取这些数值的和的开方。为了测试，我们迭代了<code>5</code>次这个计算。每次迭代后我们打印花费的时间，并总结了计算所需的运行时间。在我的<code>PowerMac G5(2.5)</code>机器上，我获得如下结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[bigmac:~/misc] macresearch% gcc mach.c -omach</div><div class="line">[bigmac:~/misc] macresearch%./mach </div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006717496412f</span>or answer: <span class="number">89478229.125529855490</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.007274204955f</span>or answer: <span class="number">178956458.251062750816</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006669191332f</span>or answer: <span class="number">268434687.376589745283</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006953711252f</span>or answer: <span class="number">357912916.502135872841</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.007582157340f</span>or answer: <span class="number">447391145.627681851387</span> </div><div class="line">Average time in seconds =<span class="number">0.007039352258</span> <span class="keyword">for</span> answer: <span class="number">447391145.627681851387</span></div></pre></td></tr></table></figure>
<p>注意，在这里我没有进行优化，因为编译器有方法避开这样的无脑循环。另外，这只是一个例子。如果是真正的代码，我们会进行优化。</p>
<p>好了，这就是这个例子的两个目的。</p>
<p>首先，我使用的数组大小比我的缓存大。我这样做的目的是因为我们需要注意到数据溢出缓存的情况(正如这个例子一样，至少在我的系统中是这样。如果是在<code>MacPro</code>中，不会出现这种情况)。我们将在以后讨论缓存的事宜。当然，这是一个做作的例子，但有一些东西可供思考。其次，你注意到在内存分配之前我写了一句注释，这是什么意思呢？</p>
<p>这在实际情况下是不需要关心的事情，因为内存总是在需要时已准备好使用。但当做一些小测试时来测试函数的性能时，它却可能是会影响到测试结果的实际问题。</p>
<p>当动态分配内存时，第一次访问内存管理时会将其清<code>0</code>(在<code>OS X</code>中不管使用哪种动态分配函数:<code>malloc</code>, <code>calloc</code>…所有内存在用户使用前都会清<code>0</code>)。内存清零是一种安全预防措施(我们不需要递交一些包含安全信息的内容，如解密密钥)</p>
<p>清零过程产生一个副作用(被系统标记为零填充页面故障)。所以为了让我们的计时更精确些，我们在使用内存之前一次性填充数据，以确保我们不会获取到零填充页面故障的处理时间。</p>
<p>让我们来测试一下，注释下面这行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++) <span class="built_in">array</span> =(<span class="keyword">double</span>)i;</div></pre></td></tr></table></figure>
<p>为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for(i=0;i&lt;size;i++) array =(double)i;</span></div></pre></td></tr></table></figure>
<p>再次运行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[bigmac:~/misc] macresearch% ./mach</div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.009478866798f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004756880234f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004927868215f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.005227029674f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004891864428f</span>or answer: <span class="number">0.000000000000</span> </div><div class="line">Average time in seconds =<span class="number">0.005856501870</span> <span class="keyword">for</span> answer: <span class="number">0.000000000000</span></div></pre></td></tr></table></figure>
<p>注意第一次迭代的时间比后序的时间多了将近一倍。同时还需要注意所有的<code>answer</code>都是<code>0</code>。再次说明内存被清零了。如果我们从堆上获取了内存，我们获取到的是无意义的数值。</p>
<p>最后，但很重要的一点。不要依赖于内存的清零操作。很有可能获取到的内存是从一个静态分配区而来，那么可能会导致如下这样的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>在我的系统上的打印结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">-1.99844</span> <span class="number">-1.29321e-231</span> <span class="number">-1.99844</span></div><div class="line"><span class="number">-3.30953e-232</span> <span class="number">-5.31401e+303</span> <span class="number">0</span></div><div class="line"><span class="number">1.79209e-313</span> <span class="number">3.3146e-314</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>所以需要特别注意</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/21/binding-to-a-uitableview-from-a-reactivecocoa-viewmodel/" itemprop="url">
                  Binding To A UITableView From A ReactiveCocoa ViewModel
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-21T14:14:19+08:00" content="2014-09-21">
              2014-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>英文作者Colin Eberhardt，原文可查看<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html" target="_blank" rel="external">BINDING TO A UITABLEVIEW FROM A REACTIVECOCOA VIEWMODEL</a></p>
<p>这篇博客介绍了一个工具类，这个类将<code>ReactiveCocoa</code>中的<code>ViewModels</code>绑定到<code>UITableView</code>，而不需要通常的datasource和delegate。下面是这个辅助类的使用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个cell</span></div><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"CETweetTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line">	</div><div class="line"><span class="comment">// 将ViewModels的searchResults属性绑定到table view</span></div><div class="line">[CETableViewBindingHelper bindingHelperForTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">                        sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">                        templateCell:nib];</div></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我总是在不断的编写代码：在工作中，在家里，在火车上…如果我不写代码，我就会觉得不快乐！(注：这才是真正的程序员啊)</p>
<p>在过去的几个月中，我开始在我的工程中越来越多地使用ReactiveCocoa了。这个框架可以用来创建一些非常优雅的解决方案，但同时它非常具有挑战性，因为对于任何一个问题，都有许多可用的解决方案。对于像我这样的编码狂人来说，这再好不过了。</p>
<p>几个月之前，我在Ray Wenderlich的网站上发表了两篇关于ReactiveCocoa的文章(<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">第一部分</a>、<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">第二部分</a>)，以及一个<a href="http://www.raywenderlich.com/70598/reactivecocoa-tech-talk-video" target="_blank" rel="external">Tech Talk</a>视频。这些覆盖了ReactiveCocoa的基本用法，希望能让广大读者熟悉ReactiveCocoa。不过，我收到不少请求，希望能讨论一些使用ReactiveCocoa实现MVVM模式的高级话题。</p>
<p>正因此，我开始写这篇文章。不过，在我发布之前，我想先分享一个已纠缠我很久的问题…</p>
<p>如果将一个<code>UITableView</code>绑定到一个<code>ReactiveCocoa</code>的<code>ViewModel</code>中？</p>
<h2 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h2><p>我以一个简单的例子开头–一个允许我们搜索Twitter的<code>ViewModel</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A view model which provides a mechanism for searching twitter</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CETwitterSearchViewModel</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line"><span class="comment">/// The current search text</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *searchText;</div><div class="line">	</div><div class="line"><span class="comment">/// An array of CETweetViewModel instances which indicate</span></div><div class="line"><span class="comment">/// the current search results</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span> *searchResults;</div><div class="line">	</div><div class="line"><span class="comment">/// A command which when executed searches twitter using the current searchText</span></div><div class="line"><span class="keyword">@property</span> RACCommand *searchCommand;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个<code>ViewModel</code>的实现重用了我在<code>ReactiveCocoa</code>指南第二部分所创建的信号，所以我不在此重复。如果想要看详细的代码，可以在github上查找。</p>
<p>将<code>ViewModel</code>绑定到一个带有<code>UITextField</code>和<code>UIButton</code>的UI是使用<code>ReactiveCocoa</code>最普通不过工作了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bind the UITextField text updates to the view model</span></div><div class="line">RAC(<span class="keyword">self</span>.viewModel, searchText) = <span class="keyword">self</span>.searchTextField.rac_textSignal;</div><div class="line">	</div><div class="line"><span class="comment">// bind a button to the search command</span></div><div class="line"><span class="keyword">self</span>.searchButton.rac_command = <span class="keyword">self</span>.viewModel.searchCommand;</div><div class="line">	</div><div class="line"><span class="comment">// when the search executes hide the keyboard</span></div><div class="line">[<span class="keyword">self</span>.viewModel.searchCommand.executing subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">  [<span class="keyword">self</span>.searchTextField resignFirstResponder];</div><div class="line">&#125;];</div><div class="line">	</div><div class="line"><span class="comment">// show a network activity indicator when the search is being executed</span></div><div class="line">RAC([<span class="built_in">UIApplication</span> sharedApplication], networkActivityIndicatorVisible) =</div><div class="line">  <span class="keyword">self</span>.viewModel.searchCommand.executing;</div></pre></td></tr></table></figure>
<p>在上面的代码中，当点击go按钮时，我们处理了诸如隐藏键盘这样的操作，并将网络连接的<code>activity indicator</code>绑定到了<code>searchCommand.executing</code>信号。</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/UIBinding.png" alt="image"></p>
<p>这样就将<code>ViewModel</code>三个属性中的两个绑定到了UI，到目前为止，一切都还不错！</p>
<p>最后一个属性是<code>searchResults</code>；这个属性是一个数组，包含了搜索结果。我们可以通过<code>RACObserve</code>来观察这个属性的修改，<code>RACObserve</code>创建了一个信号，该信号会在每次更新时发出一个next事件。但不幸的是，我们不能只给<code>UITableView</code>一个对象的数组，并告诉它去渲染自己。</p>
<p>如果我们在StackOverflow上搜索相关帖子，或者查看别人的<code>ReactiveCocoa</code>实例，可以看到传统的方式似乎是我们需要自己去实现<code>table view</code>的代理和数据源。换句话说，我们之前优雅的只需要几行绑定代码的视图类代码会由于需要实现<code>table view</code>的各种逻辑而显示异常丑陋。</p>
<p>不过，我们有更好的方法。</p>
<h2 id="一个Table-View绑定辅助类"><a href="#一个Table-View绑定辅助类" class="headerlink" title="一个Table View绑定辅助类"></a>一个Table View绑定辅助类</h2><p>在MVVM模式中，每一个View都由一个<code>ViewModel</code>支撑着。一个视图可能占据整个屏幕(此时我们将一个视图控制器绑定到一个<code>ViewModel</code>)，或者只占据屏幕的一部分。</p>
<p>我们的顶层<code>ViewModel</code>的<code>searchResults</code>属性包含了一个对象数组，其中每一个元素都是一个<code>ViewModel</code>。为了解决这个问题，我们需要的是一个通用的机制来为每个视图创建一个<code>ViewModel</code>，并将这两者绑定在一起。</p>
<p>Nib提供了一种便捷的机制来定义可重用的视图。可以方便地使用nib来定义一个table view的单元格。</p>
<p>一个合理的table view绑定辅助类的接口如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A helper class for binding view models with NSArray properties</span></div><div class="line"><span class="comment">/// to a UITableView.</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CETableViewBindingHelper</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>) initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                      sourceSignal:(RACSignal *)source</div><div class="line">                      templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个绑定类使用提供的table view来渲染由源信号所提供的view model，另外templeteCell定义了视图。让我们来看看这个辅助类的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">＠interface CETableViewBindingHelper () &lt;<span class="built_in">UITableViewDataSource</span>&gt;</div><div class="line">	</div><div class="line">＠end</div><div class="line">	</div><div class="line">＠implementation CETableViewBindingHelper &#123;</div><div class="line">  <span class="built_in">UITableView</span> *_tableView;</div><div class="line">  <span class="built_in">NSArray</span> *_data;</div><div class="line">  <span class="built_in">UITableViewCell</span> *_templateCell;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>)initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                     sourceSignal:(RACSignal *)source</div><div class="line">                     templateCell:(<span class="built_in">UINib</span> *)templateCellNib &#123;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _tableView = tableView;</div><div class="line">    _data = [<span class="built_in">NSArray</span> array];</div><div class="line">    </div><div class="line">    <span class="comment">// each time the view model updates the array property, store the latest</span></div><div class="line">    <span class="comment">// value and reload the table view</span></div><div class="line">    [source subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      _data = x;</div><div class="line">      [_tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// create an instance of the template cell and register</span></div><div class="line">    <span class="comment">// with the table view</span></div><div class="line">    _templateCell = [[templateCellNib instantiateWithOwner:<span class="literal">nil</span></div><div class="line">                                          options:<span class="literal">nil</span>] firstObject];</div><div class="line">    [_tableView registerNib:templateCellNib</div><div class="line">              forCellReuseIdentifier:_templateCell.reuseIdentifier];</div><div class="line">    </div><div class="line">    <span class="comment">// use the template cell to set the row height</span></div><div class="line">    _tableView.rowHeight = _templateCell.bounds.size.height;</div><div class="line">    </div><div class="line">    _tableView.dataSource = <span class="keyword">self</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource implementation</span></div><div class="line">	</div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                       numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> _data.count;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                        cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="keyword">id</span>&lt;CEReactiveView&gt; cell = [tableView</div><div class="line">      dequeueReusableCellWithIdentifier:_templateCell.reuseIdentifier];</div><div class="line">  [cell bindViewModel:_data[indexPath.row]];</div><div class="line">  <span class="keyword">return</span> (<span class="built_in">UITableViewCell</span> *)cell;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">＠end</div></pre></td></tr></table></figure>
<p>注意，初始化方法是内在逻辑所在。在这里，<code>sourceSignal</code>添加了一个<code>subscriber</code>，这样每次<code>ViewModel</code>的数组属性变化时，当前属性值的引用都会被保存，而table view也会重新加载。同样，也会创建<code>templeteCell</code>实例，来确定单元格的高度。</p>
<p>最后，这个类实现了table view的数据源方法，并通过信号来获取数据。</p>
<p>其中，单元格Cell必须实现以下协议，该协议提供了一个信号方法来将Cell绑定到相应的<code>ViewModel</code>上。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A protocol which is adopted by views which are backed by view models.</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CEReactiveView</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">	</div><div class="line"><span class="comment">/// Binds the given view model to the view</span></div><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>将这个用于实际当中，现在只需要几行代码就可以将一个数组属性绑定到一个table view上了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a cell template</span></div><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"CETweetTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line">	</div><div class="line"><span class="comment">// bind the view models 'searchResults' property to a table view</span></div><div class="line">[[CETableViewBindingHelper alloc]</div><div class="line">      initWithTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">           sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">           templateCell:nib];</div></pre></td></tr></table></figure>
<p>注意，源信号是通过<code>RACObserver</code>宏来创建的。这个信号在每次属性通过setter来改变都会发出一个next事件。</p>
<p>cell的实现类似于视图控制器；它们的UI控件定义在一个nib文件中并连接到相应的outlet属性。下图是该示例程序中定义cell的nib：</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellNib.png" alt="image"></p>
<p>定义在<code>CEReactiveView</code>协议中的<code>ViewModel</code>绑定方法实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  </div><div class="line">  CETweetViewModel *tweet = (CETweetViewModel *)viewModel;</div><div class="line">  </div><div class="line">  <span class="comment">// set the tweet 'status' label, sizing it to fit the text</span></div><div class="line">  <span class="keyword">self</span>.titleTextField.frame =</div><div class="line">                 <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.titleBackgroundView.frame, <span class="number">5.0</span>f, <span class="number">5.0</span>f) ;</div><div class="line">  <span class="keyword">self</span>.titleTextField.text = tweet.status;</div><div class="line">  [<span class="keyword">self</span>.titleTextField sizeToFit];</div><div class="line">  </div><div class="line">  <span class="comment">// set the username</span></div><div class="line">  <span class="keyword">self</span>.usernameTextField.text = tweet.username;</div><div class="line">  </div><div class="line">  <span class="comment">// use signals to fetch the images for each image view</span></div><div class="line">  <span class="keyword">self</span>.profileImage.image = <span class="literal">nil</span>;</div><div class="line">  [[<span class="keyword">self</span> signalForImage:[<span class="built_in">NSURL</span> URLWithString:tweet.profileBannerUrl]]</div><div class="line">    subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      <span class="keyword">self</span>.ghostImageView.image = x;</div><div class="line">    &#125;];</div><div class="line">  </div><div class="line">  <span class="keyword">self</span>.ghostImageView.image = <span class="literal">nil</span>;</div><div class="line">  [[<span class="keyword">self</span> signalForImage:[<span class="built_in">NSURL</span> URLWithString:tweet.profileImageUrl]]</div><div class="line">    subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      <span class="keyword">self</span>.profileImage.image = x;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，由于<code>CETweetViewModel</code>的属性不会发生变化，因此它们的值直接被拷贝到相应的UI控件上。当然，如果它们的值会改变，我们也可以使用<code>ReactiveCocoa</code>来将两者绑定到一起。</p>
<p>cell的实现同样使用了<code>ReactiveCocoa</code>在后台加载图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// creates a signal that fetches an image in the background, delivering</span></div><div class="line"><span class="comment">// it on the UI thread. This signal 'cancels' itself if the cell is re-used before the</span></div><div class="line"><span class="comment">// image is downloaded.</span></div><div class="line">-(RACSignal *)signalForImage:(<span class="built_in">NSURL</span> *)imageUrl &#123;</div><div class="line">  </div><div class="line">  RACScheduler *scheduler = [RACScheduler </div><div class="line">                 schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line">  </div><div class="line">  RACSignal *imageDownloadSignal = [[RACSignal</div><div class="line">    createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">      <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">      <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">      [subscriber sendNext:image];</div><div class="line">      [subscriber sendCompleted];</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> [[imageDownloadSignal</div><div class="line">          takeUntil:<span class="keyword">self</span>.rac_prepareForReuseSignal]</div><div class="line">          deliverOn:[RACScheduler mainThreadScheduler]]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这种方式，我们就可以让我们的视图控制器保持少量的代码。看，是不是很整洁。</p>
<p>下面是完整的程序的实现效果：</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellBinding.png" alt="image"></p>
<h2 id="处理选中事件"><a href="#处理选中事件" class="headerlink" title="处理选中事件"></a>处理选中事件</h2><p>当前的绑定辅助类允许我们在一个table view中渲染<code>ViewModel</code>的数组，但如果我们需要处理选中事件呢？传统的方法是在视图控制器的手动处理，实现table view的代理方法，并执行相关的<code>ViewModel</code>的命令。</p>
<p>不过，这部分逻辑代码也可以放入到绑定辅助类中。</p>
<p>首先，我们在初始化方法中添加一个选择命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>) initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                      sourceSignal:(RACSignal *)source</div><div class="line">                  selectionCommand:(RACCommand *)selection                  </div><div class="line">                      templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>
<p>这个初始化方法的实现现在存储了这个命令的引用。辅助类同样也实现了table view的代理，即<code>tableView:didSelectRowAtIndexPath:</code>方法的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">               didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  [_selection execute:_data[indexPath.row]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即当命令被调用时，会将选择的<code>ViewModel</code>作为执行参数传入。</p>
<p>在顶层<code>ViewModel</code>中，我已经添加了一个命令，这个操作只是简单地记录一下日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create the tweet selected command, that simply logs</span></div><div class="line"><span class="keyword">self</span>.tweetSelectedCommand = [[RACCommand alloc]</div><div class="line">        initWithSignalBlock:^RACSignal *(CETweetViewModel *selected) &#123;</div><div class="line">	 <span class="built_in">NSLog</span>(selected.status);</div><div class="line">	 <span class="keyword">return</span> [RACSignal empty];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>希望这个table view绑定辅助类能够帮助那些使用<code>MVVM</code>和<code>ReactiveCocoa</code>来开发iOS应用的开发者们。所有的代码都在github上。如果您有任何意见、想法或建议，请让我知道。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/18/random-mac-in-ios8/" itemprop="url">
                  iOS8中扫描Wi-Fi时MAC地址的随机化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-18T15:51:54+08:00" content="2014-09-18">
              2014-09-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继在iOS6和iOS7系统中面向开发者关闭IP地址和MAC地址的获取后，苹果在iOS8中又出新招：在扫描Wi-Fi时使用随机的、本地管理的MAC地址。基于苹果保护用户隐私的一贯政策，这一步是必然的，它会封死所以获取用户隐私信息的通道。这对于苹果用户来说，当然是件好事。而对于想通过MAC地址来获取用户信息的商家们或黑客们，可能就得另想办法了。我们在此粗略地总结一下iOS对MAC地址所做的随机化处理。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>在当今基于OSI模型的七层网络系统中，所有有网络接口的设备至少都有一个MAC地址(Media Access Control)。MAC地址位于OSI模型的第二层中，用于帮助网络交换机(有机或无线)确定哪个设备正在传输包及哪个设备应该接收这些包。根据设计，MAC地址应该是唯一的，它被写入到设备的物理网络芯片中，两个不同的设备MAC地址是不一样的。由于像智能手机设备中的无线以太网适配器在广播MAC地址时，采用的的类似于“嘿，这里有没有Wi-Fi”这种形式，所以，我们可以很容易地通过记录这个唯一识别来跟踪用户是否到过某个公共区域。</p>
<h2 id="随机MAC地址的技术实现"><a href="#随机MAC地址的技术实现" class="headerlink" title="随机MAC地址的技术实现"></a>随机MAC地址的技术实现</h2><p>在WWDC 2014上，Frederic Jacobs在对iOS8新特性的介绍中，提到了如下一条:</p>
<p><img src="http://cdn.arstechnica.net/wp-content/uploads/2014/06/Screen-Shot-2014-06-09-at-10.15.22-AM-1280x551.png" alt="image"></p>
<p>其大意是在iOS8系统中，Wi-Fi扫描过程中将使用随机的、本地管理的MAC地址，这个MAC地址并不总是设备的真实的MAC地址。</p>
<p>首先需要注意的是MAC地址的随机化。</p>
<p>如果是主动扫描，手机的无线设备会广播一个Probe请求，它包含一个随机的MAC地址。然后手机会等待周围的无线访问接入点(AP)返回Probe响应。一般来说会扫描所有的信道channel1-channel13(或者channel1, 5, 13)，每个信道扫描10ms左右。当然，手机也可以通过点对点的方式将请求(Directed Probe)发送给特定的AP。我们一般隐藏一个无线路由的SSID的方法，就是让这个无线路由不响应广播的Probe，不主动发Beacon，只响应Directed Probe。</p>
<p>而如果是被动扫描，则手机不会广播任何Probe请求，只是周期性地在不同的信道上监听AP发出的beacon包。</p>
<p>另外一个需要注意的是这个随机化是发生在扫描过程中的。而在手机与无线接入点进行关联的过程以及数据传输的过程中，使用MAC地址仍然是设备真实的MAC地址。通常只有在关联阶段才是让AP记录手机MAC地址的阶段，这时候记录的MAC地址，才是将来作为数据传输的MAC地址。</p>
<p>更详细的介绍，可以参看<a href="http://www.zhihu.com/people/qiang-meta" target="_blank" rel="external">@Qiang Meta</a>在知乎上对《<a href="http://www.zhihu.com/question/24094236?sort=created" target="_blank" rel="external">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a>》的作答。</p>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>如果我们是在家中或者在办公区域，我们通常会自己去主动关联无线接入点，那么等到下次再进入这一区域时，我们的手机等设备就会自动去连接无线网络。由于这些Wi-Fi是受我们信任的，所以无所谓。但是当我们到达一个陌生区域或公共区域时，我们的设备就会去搜索可用的无线接入点。这时候就涉及到隐私的问题了。</p>
<p>现在，已经有一些公司已经开发了可以记住所扫描到的MAC地址的Wi-Fi集线器。这种设备可以记住我们的MAC地址，无论我们有没有连接它。这些公司已经在许多地方部署了这些设备，以便他们能在用户不知道的情况下了解用户的一些基本行为。</p>
<p>正如WWDC上所指出的一样，“诸如Euclid或其同行Turnstyle Solutions这样的公司，它们会使用MAC地址这样的数据来记录用户进出商店的一些信息，如人们何时走进一个商店，他们在某个区域停留多久，他们来商店的频率是多少”。而MAC地址的随机化正是为了规避这个问题。</p>
<p>这对于广告商和营销商来说无疑是个不小的打击，如果iOS8设备使用不断变化的MAC地址来广播Wi-Fi Probe请求，则不可能通过MAC地址来跟踪进出商店或其它场所的移动设备。这对于保护用户的隐私来说，又是更进了一步。</p>
<h2 id="苹果的替代方案"><a href="#苹果的替代方案" class="headerlink" title="苹果的替代方案"></a>苹果的替代方案</h2><p>不过苹果也没有完全关闭追踪用户并向用户推送广告的通道，它推出了另外一种方案–即基于位置服务的iBeacon。iBeacon已经内置在最近的iOS设备中了。不同于使用设备的MAC地址，iBeacon使用低功耗蓝牙技术来发现那边带有支持iBeacon功能的App的设备，以向这些设备发送广告或通知。iBeacon不同于基于MAC地址跟踪技术(iBeacon发射器不会从设备中获取数据)，它只是在匹配到带有基于iBeacon的应用时，才可以察看设备位置。这样就无法推测出一个用户的习惯，从而保护了用户的隐私了。</p>
<p>当然，苹果在随机化MAC地址时，也综合考虑了用户隐私的泄露与商家基于地理位置来发送广告的需求之间的平衡。那些不愿意使用iBeacon的iOS用户可以通过关闭蓝牙来禁用iBeacon感知功能。在iOS8之前，用户只能通过禁用Wi-Fi来避免自己的设备被通过MAC地址的方式跟踪到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>苹果这次对MAC地址的随机化处理，又一次展示了它对保护用户隐私的决定。相信以后类似的事情还会出现。而对于开发商或者开发者来说，在iOS设备上获取用户信息的渠道将会越来越少。我们改变不了苹果，或许也就只能另辟蹊径。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.zhihu.com/question/24094236" target="_blank" rel="external">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a></li>
<li><a href="http://arstechnica.com/apple/2014/06/ios8-to-stymie-trackers-and-marketers-with-mac-address-randomization/" target="_blank" rel="external">iOS 8 to stymie trackers and marketers with MAC address randomization</a></li>
<li><a href="http://www.tuicool.com/articles/rUv6Br" target="_blank" rel="external">Why iOS 8′s MAC address randomizing is a huge win for privacy</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/15/thinking-in-terms-of-ios-8-size-classes/" itemprop="url">
                  Thinking In Terms Of iOS 8 Size Classes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-15T17:25:53+08:00" content="2014-09-15">
              2014-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="http://carpeaqua.com/2014/06/14/thinking-in-terms-of-ios-8-size-classes/" target="_blank" rel="external">Thinking In Terms Of iOS 8 Size Classes</a></p>
<p>对于最新的<code>iOS8 SDK</code>来说，最性感也最重要的的特性也许莫过于<code>Size Classes</code>了。</p>
<p>在聊<code>Size Classes</code>之前，我们先来回顾下历史。</p>
<h2 id="一堂历史课"><a href="#一堂历史课" class="headerlink" title="一堂历史课"></a>一堂历史课</h2><p>最初，<code>iOS</code>推出时，我们只有一种设备：<code>iPhone</code>。它的屏幕大小是<code>320\*480</code>。不过即使如此，它也是同时支付横屏和竖屏。设计同时支持两个方向的<code>App</code>不是像<code>Mobile Safari</code>或<code>Messages</code>那样，简单地拉伸和重新设置视图的大小。在大多数情况下，我们需要移动按钮和其它控件来让其适应横屏(<code>480\*320</code>)。</p>
<p>几年后的现在，我们有了高清屏，<code>iPads</code>和大屏的<code>iPhone</code>。当然，所有这些设备都是支持横屏和竖屏的。解决这个适配问题的传统的方法是在视图控制器和自定义视图中监听设备方向的变化，同时使用多个<code>xib</code>或<code>storyboard</code>。</p>
<p>假设我已经构建了一个同时支持<code>iPhone</code>和<code>iPad</code>的的<code>Glassboard</code>工程。在<code>iOS7</code>和老的版本之前，我们需要针对<code>iPad</code>单独创建一个<code>storyboard</code>，这个<code>storyboard</code>包含重建的视图控制器，<code>outlet</code>属性和<code>target/action</code>。这相当于是重复工作了。任何程序员都知道这不是个好主意。需要在两个不同的地方做相同的改变真是件糟糕的事。</p>
<p>如果是使用代码，则我们需要在代码中检测屏幕方向及设备大小，以便我们能手动调整我们的约束或基于<code>frame</code>的布局。我们的代码会像下面这段代码一样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIDevice</span> *device = [<span class="built_in">UIDevice</span> currentDevice];</div><div class="line"><span class="built_in">UIDeviceOrientation</span> currentOrientation = device.orientation;</div><div class="line"><span class="built_in">BOOL</span> isPhone = (device.userInterfaceIdiom == <span class="built_in">UIUserInterfaceIdiomPhone</span>);</div><div class="line"><span class="built_in">BOOL</span> isTallPhone = ([[<span class="built_in">UIScreen</span> mainScreen] bounds].size.height == <span class="number">568.0</span>);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">UIDeviceOrientationIsPortrait</span>(currentOrientation) == <span class="literal">YES</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Do Portrait Things</span></div><div class="line">    <span class="keyword">if</span> (isPhone == <span class="literal">YES</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Portrait Phone Things</span></div><div class="line">        <span class="comment">// Don't deny you've done this at least once.</span></div><div class="line">        <span class="keyword">if</span> (isTallPhone)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// iPhone 5+</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// Old phones</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Portrait iPad things.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Do Landscape Things.</span></div><div class="line">    <span class="keyword">if</span> (isPhone == <span class="literal">YES</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Landscape Phone Things</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Landscape iPad things.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Size-Classes"><a href="#Size-Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>显然，上面的这些方案都不理想，而且随着苹果新设备的推出，这种情况会变得越来越糟。在今年的<code>WWDC</code>上，苹果除了介绍自动布局的新特性外，我们同样也看到了许多可变<code>iOS</code>模拟器的事例，以及一种处理所有这些问题和屏幕问题的新技术：<code>Size Classes</code>。</p>
<p><code>Size Classes</code>是<code>iOS</code>使用的一种新的技术，允许我们为给定的设备自定义我们的程序，而且是基于设备的方向和屏幕大小的。</p>
<p><code>Size Classes</code>有两个目的：</p>
<ol>
<li>让开发人员和设计人员跳出指定设备的范畴，而是以更广义的范畴来思考问题</li>
<li>为未来做准备</li>
</ol>
<p>第一个目的也引出了第二个目的。我们看到各种传说，说<code>iPhone 6, 7</code>将会是更大的设备。你也看到了苹果已经开发出了可穿戴设备(<code>Apple Watch</code>)。那么有什么方法可以让为这些设备开发变得更容易呢？那就是<code>Size Classes</code>。</p>
<p>目前从<code>XCode 6</code>上可以看到有四种类型的<code>Size Classes</code>：</p>
<p><img src="http://cdn.carpeaqua.com.s3.amazonaws.com/images/size-classes/size_class_chart.jpg" alt="image"></p>
<ol>
<li>宽紧凑(<code>Compact</code>)</li>
<li>长紧凑</li>
<li>宽正常(<code>Regular</code>)</li>
<li>长正常</li>
</ol>
<p>任意时刻，我们的设备都有一个水平方向的<code>Size Class</code>和一个竖直方向的<code>Size Class</code>。这两者都是用来定义布局属性与物征(<code>trait</code>)的集合，以在屏幕上显示内容给用户。</p>
<h2 id="特征-Traits"><a href="#特征-Traits" class="headerlink" title="特征(Traits)"></a>特征(Traits)</h2><p>水平和竖直的Size Class被认为是Traits。结合当前界面术语和显示比例，一起组成了一个特征集合。这不只是包含了指定的控制应该放在屏幕的什么地方。</p>
<p>特征(<code>Trait</code>)也可以用于诸如<code>image assets</code>的东西上(假设你正在使用<code>Asset Catalogs</code>)。在<code>asset</code>中，我们不仅可以包含<code>1x</code>和<code>2x</code>版本，我们还可以为不同的<code>size class</code>指定不同的<code>image asset</code>。在代码中，它看着仍然是相同的<code>UIImage</code>调用。<code>Asset Catalogs</code>负责基于当前的特征集合来渲染合适的图片。</p>
<h2 id="为Size-Classes设计"><a href="#为Size-Classes设计" class="headerlink" title="为Size Classes设计"></a>为Size Classes设计</h2><p><code>Size Classes</code>对于开发人员来讲是一个很好的扩展，因为当我们需要支持多种设备和方向时，它能简化我们的开发。通过简化我们的工作，苹果可以更容易地开发新的设备，并可以让开发者开发能用的应用，而不仅仅是只为<code>iPhone</code>开发程序。</p>
<p>对于开发者来说，最大的改变是我们需要再一次修改我们的关于不同方向的代码。大家已经习惯了吧，谁让我们是开发者呢。</p>
<p>对于设计者来说，特征集合意味着可以少考虑是为哪种设备来做设计，而可以更多的考虑设备的属性。现在，设计者最需要考虑的因素是物理屏幕大小。</p>
<p>由于不能确保每台设备的屏幕尺寸都与<code>Photoshop</code>或测试样机保持一致，所以单独为特定的场景做设计已经站不住脚了。相反，我们的目标是应该为一类设备做通用的设计，主要包括：</p>
<ol>
<li>手机上的肖像模式</li>
<li>平板上的肖像模式</li>
<li>手机上的景观模式</li>
<li>平板上的景观模式</li>
</ol>
<p>现在<code>iPhone 6</code>来了，它的屏幕也变大了，它拥有与<code>iPhone 4s</code>和<code>5</code>一样的特征集合。当然，<code>iPhone 6</code>的尺寸比原来的手机更大了，但是UI应该基于为指定特征集合定义的界面，来做自适应的处理。</p>
<p>这可能意味着设计者需要推翻自己以前的一些设计，但这就是事实。就像软件开发一样，软件设计需要符合这些约束。新的约束就是我们不能再活在只为特定屏幕尺寸做设计的世界里面了。我们不是要像<code>Android</code>一样，但这是苹果希望我们前进的方向。</p>
<h2 id="采用Size-Classes"><a href="#采用Size-Classes" class="headerlink" title="采用Size Classes"></a>采用Size Classes</h2><p>好消息是，<code>Interface Builder</code>可以让我们更好的使用<code>Size Classes</code>。更好的消息是，这些<code>Interface Builder</code>变化是向后兼容的，所以我们可以在合适的地方简化和合并<code>Storyboards</code>和<code>Xibs</code>，而不会落下任何用户。</p>
<p>不太好的消息是，如果需要在代码中使用特征集合，则只支持<code>iOS 8</code>。这是因为苹果很少为老的系统提供新的<code>API</code>接口。这就意味着我们需要在代码中添加一些新的分支来支持不同的系统。例如，为自定义的<code>UIView</code>调整<code>intrinsicContentSize</code>属性。如果系统是<code>iOS8</code>，我们可以使用竖直和水平的<code>size class</code>来确定这个值，但如果设备仍然是<code>iOS 7</code>或老版本，则已存在的代码仍然需要保留。</p>
<p>因为我使用并推荐<code>Interface Builder</code>，所以比起那些仍然活在“将一切写在代码”口号中的人们来说，我的工作明显地减少了。如果你仍然在那个阵营里面，我强烈建议你使用<code>iOS 8</code>, <code>XCode 6</code>和特征集合，并以此为契机加入到<code>Interface Builder</code>阵营中来。这样不仅能减少我们的代码量，同样可以通过提取大量的特征处理到一个视觉<code>UI</code>库来简化代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/12/mvvm-tutorial-with-reactivecocoa-2/" itemprop="url">
                  MVVM Tutorial with ReactiveCocoa: Part 2/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-12T21:12:20+08:00" content="2014-08-12">
              2014-08-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，原文可查看<a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>
<p>在第一部分中，我们介绍了<code>MVVM</code>，可以看到<code>ReactiveCocoa</code>如何将<code>ViewModel</code>绑定到各自对应的<code>View</code>上。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png" alt="image"></p>
<p>下图是我们程序实现的<code>Flickr</code>搜索功能</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image"></p>
<p>在这一部分中，我们来看看如何在程序的<code>ViewModel</code>中驱动视图间的导航操作。</p>
<p>目前我们的程序允许使用简单的搜索字符串来搜索<code>Flickr</code>。我们可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip" target="_blank" rel="external">这里</a>下载程序。<code>Model</code>层使用<code>ReactiveCocoa</code>来提供搜索结果，<code>ViewModel</code>只是简单地记录响应。</p>
<p>现在，我们来看看如何在结果页中进行导航。</p>
<h2 id="实现ViewModel导航"><a href="#实现ViewModel导航" class="headerlink" title="实现ViewModel导航"></a>实现ViewModel导航</h2><p>当一个<code>Flickr</code>成功返回需要的结果时，程序导航到一个新的视图控制器来显示搜索结果。当前的程序只有一个<code>ViewModel</code>，即<code>RWTFlickrSearchViewModel</code>类。为了实现需要的功能，我们将添加一个新的<code>ViewModel</code>来返回到搜索结果视图。添加新的继承自<code>NSObject</code>的<code>RWTSearchResultsViewModel</code>类到<code>ViewModel</code>分组中，并更新其头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchResults.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *searchResults;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上述代码添加了描述视图的两个属性，及一个初始化方法。打开<code>RWTSearchResultsViewModel.m</code>并实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _title = results.searchString;</div><div class="line">    _searchResults = results.photos;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回想一下第一部分，<code>ViewModel</code>在<code>View</code>驱动程序之前就已经生成了。下一步就是将<code>View</code>连接到对应的<code>ViewModel</code>上。</p>
<p>打开<code>RWTSearchResultsViewController.h</code>，导入<code>ViewModel</code>，并添加以下初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewModel.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>打开<code>RWTSearchResultsViewController.m</code>，在类的扩展中添加以下私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RWTSearchResultsViewModel *viewModel;</div></pre></td></tr></table></figure>
<p>在同一个文件下面，实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _viewModel = viewModel;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这一步中，我们将重点关注导航如何工作，回到视图控制器中将<code>ViewModel</code>绑定到<code>UI</code>中。</p>
<p>现在程序有两个<code>ViewModel</code>，但是现在将面临一个难题。如何从一个<code>ViewModel</code>导航到另一个<code>ViewModel</code>中，也就是在对应的视图控制器中导航。<code>ViewModel</code>不能直接引用视图，所示我们应该怎么做呢？</p>
<p>答案已经在<code>RWTViewModelServices</code>协议中给出来了。它获取了一个<code>Model</code>层的引用，我们将使用这个协议来允许<code>ViewModel</code>来初始化导航。打开<code>RWTViewModelServices.h</code>并添加以下方法来协议中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewModel:(<span class="keyword">id</span>)viewModel;</div></pre></td></tr></table></figure>
<p>理论上讲，是<code>ViewModel</code>层驱动程序，这一层中的逻辑决定了在<code>View</code>中显示什么，及何时进行导航。这个方法允许<code>ViewModel</code>层<code>push</code>一个<code>ViewModel</code>，该方式与<code>UINavigationController</code>方式类似。在更新协议实现前，我们将在<code>ViewModel</code>层先让这个机制工作。</p>
<p>打开<code>RWTFlickrSearchViewModel.m</code>并导入以下头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>同时在同一文件中更新<code>executeSearchSignal</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span>.services getFlickrSearchService]</div><div class="line">    flickrSearchSignal:<span class="keyword">self</span>.searchText]</div><div class="line">    doNext:^(<span class="keyword">id</span> result) &#123;</div><div class="line">      RWTSearchResultsViewModel *resultsViewModel =</div><div class="line">        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:<span class="keyword">self</span>.services];</div><div class="line">      [<span class="keyword">self</span>.services pushViewModel:resultsViewModel];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码添加一个<code>addNext</code>操作到搜索命令执行时创建的信号。<code>doNext</code>块创建一个新的<code>ViewModel</code>来显示搜索结果，然后通过<code>ViewModel</code>服务将它<code>push</code>进来。现在是时候更新协议的实现代码了。为了满足这个需求，代码需要一个导航控制器的引用。</p>
<p>打开<code>RWTViewModelServicesImpl.h</code>并添加以下的初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController;</div></pre></td></tr></table></figure>
<p>打开<code>RWTViewModelServicesImpl.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewController.h"</span></span></div></pre></td></tr></table></figure>
<p>然后添加一个私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UINavigationController</span> *navigationController;</div></pre></td></tr></table></figure>
<p>接下来实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _searchService = [RWTFlickrSearchImpl new];</div><div class="line">    _navigationController = navigationController;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这简单地更新了初始化方法来存储传入的导航控制器的引用。最后，添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  <span class="keyword">id</span> viewController;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) &#123;</div><div class="line">    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"an unknown ViewModel was pushed!"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法使用提供的<code>ViewModel</code>的类型来确定需要哪个视图。在上面的例子中，只有一个<code>ViewModel-View</code>对，不过我确信你可以看到如何扩展这个模式。导航控制器<code>push</code>了结果视图。</p>
<p>最后，打开<code>RWTAppDelegate.m</code>，定位到<code>createInitialViewController</code>方法的<code>RWTViewModelServicesImpl</code>实例创建的地方，用下面的代码替换创建操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:<span class="keyword">self</span>.navigationController];</div></pre></td></tr></table></figure>
<p>运行后，点击”<code>GO</code>“可以看到程序切换到新的<code>ViewModel/View</code>:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png" alt="image"></p>
<p>现在还是空的。别急，我们一步一步来。不过我们的程序现在有多个<code>ViewModel</code>，其中导航控制器通过<code>ViewModel</code>层来进行控制。我们先回来<code>UI</code>绑定上来。</p>
<h2 id="渲染结果页"><a href="#渲染结果页" class="headerlink" title="渲染结果页"></a>渲染结果页</h2><p>搜索结果的视图对应的<code>nib</code>文件中有一个<code>UITableView</code>。接下来，我们需要在这个<code>table</code>中渲染<code>ViewModel</code>的内容。打开<code>RWTSearchResultsViewController.m</code>并定位到类扩展。更新它以实现<code>UITableViewDataSource</code>协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> () &lt;<span class="title">UITableViewDataSource</span>&gt;</span></div></pre></td></tr></table></figure>
<p>重写<code>viewDidLoad</code>的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.searchResultsTable registerClass:<span class="built_in">UITableViewCell</span>.class</div><div class="line">                  forCellReuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">  <span class="keyword">self</span>.searchResultsTable.dataSource = <span class="keyword">self</span>;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span> bindViewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码执行<code>table view</code>的初始化并将其绑定到<code>view model</code>。先忘记硬编码的<code>cell</code>标识常量，我们会在后面将其移除。</p>
<p>继续在下面添加<code>bindViewModel</code>代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel &#123;</div><div class="line">  <span class="keyword">self</span>.title = <span class="keyword">self</span>.viewModel.title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ViewModel</code>有两个属性：上述代码处理的的标题，及渲染到<code>table</code>中的<code>searchResults</code>数组。那么我们该怎么样将数组绑定到<code>table view</code>呢？实际上，我们做不了。<code>ReactiveCocoa</code>可以绑定一些简单的UI控件，但是不能处理这种针对<code>table view</code>的复杂交互。但不需要担心，还有其它方法。卷起袖子开始做吧。</p>
<p>在同一文件中，添加以下两个数据源方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line"> numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.viewModel.searchResults.count;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">         cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">  cell.textLabel.text = [<span class="keyword">self</span>.viewModel.searchResults[indexPath.row] title];</div><div class="line">  <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就不用说了吧。运行后，效果如下：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png" alt="image"></p>
<h2 id="更好的TableView绑定方法"><a href="#更好的TableView绑定方法" class="headerlink" title="更好的TableView绑定方法"></a>更好的TableView绑定方法</h2><p><code>table view</code>绑定的缺失会很快导致视图控制器代码的增加。而手动绑定看上去又不太优雅。从概念上讲，在<code>ViewModel</code>的<code>searchResults</code>数组中的每一项是一个<code>ViewMode</code>，每个<code>cell</code>是对应一个<code>ViewModel</code>实例。在<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html" target="_blank" rel="external">这篇博客</a>中我创建了一个绑定帮助类<code>CETableViewBindingHelper</code>，允许我们定义用于子<code>ViewModel</code>的<code>View</code>，帮助类负责实现数据源协议。我们可以在当前工程的<code>Util</code>分组中找到这个帮助类。</p>
<p><code>CETableViewBindingHelper</code>的构造方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>) bindingHelperForTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                              sourceSignal:(RACSignal *)source</div><div class="line">                          selectionCommand:(RACCommand *)selection</div><div class="line">                              templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>
<p>为了将数组绑定到视图中，我们简单创建一个帮助类的实例。它的参数是：</p>
<ol>
<li>渲染<code>ViewModel</code>数组的<code>table view</code></li>
<li>处理数组变化的信号</li>
<li>可选的当某行被选中时的命令</li>
<li><code>cell</code>视图的<code>nib</code>文件</li>
</ol>
<p><code>nib</code>文件定义的<code>cell</code>必须实现<code>CEReactiveView</code>协议。工程已经包含了一个<code>table view cell</code>，我们可以用它来渲染搜索结果。打开<code>RWTSearchResultsTableViewCell.h</code>并导入协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CEReactiveView.h"</span></span></div></pre></td></tr></table></figure>
<p>采用协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsTableViewCell</span> : <span class="title">UITableViewCell</span> &lt;<span class="title">CEReactiveView</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下一步是实现协议。打开<code>RWTSearchResultsTableViewCell.m</code>并添加头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div></pre></td></tr></table></figure>
<p>添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  RWTFlickrPhoto *photo = viewModel;</div><div class="line">  <span class="keyword">self</span>.titleLabel.text = photo.title;</div><div class="line"> </div><div class="line">  <span class="keyword">self</span>.imageThumbnailView.contentMode = <span class="built_in">UIViewContentModeScaleToFill</span>;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.imageThumbnailView setImageWithURL:photo.url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RWTSearchResultsViewModel</code>的<code>searchResults</code>属性包含<code>RWTFlickrPhoto</code>实例的数组。它们被直接绑定到<code>View</code>，而不是在<code>ViewModel</code>中包装这些<code>Model</code>对象。</p>
<p><code>bindViewModel</code>方法使用了<code>SDWebImage</code>第三方库，它在后台线程下载并解码图片数据，大大提高了<code>scroll</code>的性能。</p>
<p>最后一步是使用绑定帮助类来渲染<code>table</code>。</p>
<p>打开<code>RWTSearchResultsViewController.m</code>并导入头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CETableViewBindingHelper.h"</span></span></div></pre></td></tr></table></figure>
<p>在该文件下面的代码中移除对<code>UITableDataSource</code>协议的实现，同时移除实现的方法。接下来，添加以下私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) CETableViewBindingHelper *bindingHelper;</div></pre></td></tr></table></figure>
<p>在<code>viewDidLoad</code>方法中移除<code>table view</code>的配置代码，回归来方法的最初形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; </div><div class="line">  [<span class="keyword">self</span> bindViewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们在<code>[self bindViewModel]</code>后面添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"RWTSearchResultsTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line"> </div><div class="line"><span class="keyword">self</span>.bindingHelper =</div><div class="line">  [CETableViewBindingHelper bindingHelperForTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">                                         sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">                                     selectionCommand:<span class="literal">nil</span></div><div class="line">                                         templateCell:nib];</div></pre></td></tr></table></figure>
<p>这从<code>nib</code>文件中创建了一个<code>UINib</code>实例并构建了一个绑定帮助类实例，<code>sourceSignal</code>是通过观察<code>ViewModel</code>的<code>searchResults</code>属性改变而创建的。</p>
<p>运行后，得到新的<code>UI</code>：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper-281x500.png" alt="image"></p>
<h2 id="一些UI特效"><a href="#一些UI特效" class="headerlink" title="一些UI特效"></a>一些UI特效</h2><p>到目前为止，本指南主要关注于根据MVVM模式来构建程序。接下来，我们做点别的吧：添加特效。</p>
<p><code>iOS7</code>已经发布一年多了，“运动设计(<code>motion design</code>)”获取了更多的青睐，很多设计者现在都喜欢用这种微妙的对话和流体行为。</p>
<p>在这一步中，我们将添加一个图片滑动的特效，很不错的。</p>
<p>打开<code>RWTSearchResultsTableViewCell.h</code>并添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setParallax:(<span class="built_in">CGFloat</span>)value;</div></pre></td></tr></table></figure>
<p><code>table view</code>将使用这个方法来为每个<code>cell</code>提供视差补偿。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>并实现这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setParallax:(<span class="built_in">CGFloat</span>)value &#123;</div><div class="line">  <span class="keyword">self</span>.imageThumbnailView.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很不错，这只是个简单的变换。</p>
<p>打开<code>RWTSearchResultsViewController.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsTableViewCell.h"</span></span></div></pre></td></tr></table></figure>
<p>然后在类扩展中采用<code>UITableViewDelegate</code>协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> () &lt;<span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们只是添加一个绑定辅助类来将将它自己设置为<code>table view</code>的代理，以便其可以响应行的选择。然而，它也转发代理方法调用到它所有的代理属性，这样我们仍然可以添加自定义行为。</p>
<p>在<code>bindViewModel</code>方法中，设置绑定辅助类代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.bindingHelper.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>
<p>在同一文件下面，添加<code>scrollViewDidScroll</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</div><div class="line">  <span class="built_in">NSArray</span> *cells = [<span class="keyword">self</span>.searchResultsTable visibleCells];</div><div class="line">  <span class="keyword">for</span> (RWTSearchResultsTableViewCell *cell <span class="keyword">in</span> cells) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> value = <span class="number">-40</span> + (cell.frame.origin.y - <span class="keyword">self</span>.searchResultsTable.contentOffset.y) / <span class="number">5</span>;</div><div class="line">    [cell setParallax:value];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>table view</code>每次滚动时，调用这个方法。它迭代所有的可见<code>cell</code>，计算用于视差效果的偏移值。这个偏移值依赖于<code>cell</code>在<code>table view</code>中可见部分的位置。</p>
<p>运行后，可得到以下效果</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif" alt="image"></p>
<p>现在我们回到业务的<code>View</code>和<code>ViewModel</code>。</p>
<h2 id="查询评论及收藏计数"><a href="#查询评论及收藏计数" class="headerlink" title="查询评论及收藏计数"></a>查询评论及收藏计数</h2><p>我们应该在列表界面中每幅图片的右下方显示评论的数量和收藏的数量。当前我们只在<code>nib</code>文件中显示一个假数据’<code>123</code>‘。我们在使用真值来替换这些值前，需要在<code>Model</code>层添加这些功能。添加表示查询<code>Flickr</code> <code>API</code>结果的<code>Model</code>对象的步骤跟前面一样。</p>
<p>在<code>Model</code>分组中添加<code>RWTFlickrPhotoMetadata</code>类，打开<code>RWTFlickrPhotoMetadata.h</code>并添加以下属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> favorites;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> comments;</div></pre></td></tr></table></figure>
<p>打开<code>RWTFlickrPhotoMetadata.m</code>并添加<code>description</code>的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)description &#123;</div><div class="line">  <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"metadata: comments=%lU, faves=%lU"</span>,</div><div class="line">          <span class="keyword">self</span>.comments, <span class="keyword">self</span>.favorites];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来打开<code>RWTFlickrSearch.h</code>并添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrImageMetadata:(<span class="built_in">NSString</span> *)photoId;</div></pre></td></tr></table></figure>
<p><code>ViewModel</code>将使用这个方法来请求给定图片的元数据，如评论和收藏。</p>
<p>接下来打开<code>RWTFlickrSearchImpl.m</code>并添加以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhotoMetadata.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>接下来实现<code>flickrImageMetadata</code>方法。不幸的是，这里有些小问题：为了获取图片相关的评论数，我们需要调用<code>flickr.photos.getinfo</code>方法；为了获取收藏数，需要调用<code>flickr.photos.getFavorites</code>方法。这让事件变得有点复杂，因为<code>flickrImageMetadata</code>方法需要调用两个接口请求以获取需要的数据。不过，<code>ReactiveCocoa</code>已经为我们解决了这个问题。</p>
<p>添加以下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrImageMetadata:(<span class="built_in">NSString</span> *)photoId &#123;</div><div class="line"> </div><div class="line">  RACSignal *favorites = [<span class="keyword">self</span> signalFromAPIMethod:<span class="string">@"flickr.photos.getFavorites"</span></div><div class="line">                                          arguments:@&#123;<span class="string">@"photo_id"</span>: photoId&#125;</div><div class="line">                                          transform:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *response) &#123;</div><div class="line">                                            <span class="built_in">NSString</span> *total = [response valueForKeyPath:<span class="string">@"photo.total"</span>];</div><div class="line">                                            <span class="keyword">return</span> total;</div><div class="line">                                          &#125;];</div><div class="line"> </div><div class="line">  RACSignal *comments = [<span class="keyword">self</span> signalFromAPIMethod:<span class="string">@"flickr.photos.getInfo"</span></div><div class="line">                                        arguments:@&#123;<span class="string">@"photo_id"</span>: photoId&#125;</div><div class="line">                                        transform:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *response) &#123;</div><div class="line">                                          <span class="built_in">NSString</span> *total = [response valueForKeyPath:<span class="string">@"photo.comments._text"</span>];</div><div class="line">                                          <span class="keyword">return</span> total;</div><div class="line">                                        &#125;];</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> [RACSignal combineLatest:@[favorites, comments] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *favs, <span class="built_in">NSString</span> *coms)&#123;</div><div class="line">    RWTFlickrPhotoMetadata *meta = [RWTFlickrPhotoMetadata new];</div><div class="line">    meta.comments = [coms integerValue];</div><div class="line">    meta.favorites = [favs integerValue];</div><div class="line">    <span class="keyword">return</span>  meta;</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码使用<code>signalFromAPIMethod:arguments:transform:</code>来从底层的基于<code>ObjectiveFLickr</code>的接口创建信号。上面的代码创建了一个信号对，一个用于获取收藏的数量，一个用于获取评论的数量。</p>
<p>一旦创建了两个信号，<code>combineLatest:reduce:</code>方法生成一个新的信号来组合两者。</p>
<p>这个方法等待源信号的一个<code>next</code>事件。<code>reduce</code>块使用它们的内容来调用，其结果变成联合信号的<code>next</code>事件。</p>
<p>简单明了吧！</p>
<p>不过在庆祝前，我们回到<code>signalFromAPIMethod:arguments:transform:</code>方法来修复之前提到的一个错误。你注意到了么？这个方法为每个请求创建一个新的<code>OFFlickrAPIRequest</code>实例。然后，每个请求的结果是通过代理对象来返回的，而这种情况下，其代理是它自己。结果是，在并发请求的情况下，没有办法指明哪个<code>flickrAPIRequest:didCompleteWithResponse:</code>调用用来响应哪个请求。不过，<code>ObjectiveFlickr</code>代理方法签名在第一个参数中包含了相应请求，所以这个问题很好解决。</p>
<p>在<code>signalFromAPIMethod:arguments:transform:</code>中，使用下面的代码来替换处理<code>successSignal</code>的管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@weakify(flickrRequest)</div><div class="line">[[[[successSignal</div><div class="line">  filter:^<span class="built_in">BOOL</span>(RACTuple *tuple) &#123;</div><div class="line">    @strongify(flickrRequest)</div><div class="line">    <span class="keyword">return</span> tuple.first == flickrRequest;</div><div class="line">  &#125;]</div><div class="line">  map:^<span class="keyword">id</span>(RACTuple *tuple) &#123;</div><div class="line">    <span class="keyword">return</span> tuple.second;</div><div class="line">  &#125;]</div><div class="line">  map:block]</div><div class="line">  subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    [subscriber sendNext:x];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>这只是简单地添加一个<code>filter</code>操作来移除任何与请求相关的代理方法调用，而不是生成当前的信号。</p>
<p>最后一步是在<code>ViewModel</code>层中使用信号。</p>
<p>打开<code>RWTSearchResultsViewModel.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div></pre></td></tr></table></figure>
<p>在同一文件中的初始化的末尾添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RWTFlickrPhoto *photo = results.photos.firstObject;</div><div class="line">RACSignal *metaDataSignal = [[services getFlickrSearchService]</div><div class="line">                            flickrImageMetadata:photo.identifier];</div><div class="line">    [metaDataSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>这段代码测试了新添加的方法，该方法从返回的结果中的第一幅图片获取图片元数据。运行程序后，会在控制台输出以下信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-06</span><span class="number">-04</span> <span class="number">07</span>:<span class="number">27</span>:<span class="number">26.813</span> RWTFlickrSearch[<span class="number">76828</span>:<span class="number">70</span>b] metadata: comments=<span class="number">120</span>, faves=<span class="number">434</span></div></pre></td></tr></table></figure>
<h2 id="获取可见cell的元数据"><a href="#获取可见cell的元数据" class="headerlink" title="获取可见cell的元数据"></a>获取可见cell的元数据</h2><p>我们可以扩展当前代码来获取所有搜索结果的元数据。然而，如果我们有<code>100</code>条结果，则需要立即发起<code>200</code>个请求，每幅图片<code>2</code>个请求。大多数<code>API</code>都有些限制，这种调用方式会阻塞我们的请求调用，至少是临时的。</p>
<p>在一个<code>table</code>中，我们只需要获取当前显示的单元格所对象的结果的元数据。所以，如何实现这个行为呢？当然，我们需要一个<code>ViewModel</code>来表示这些数据。当前<code>RWTSearchResultsViewModel</code>暴露了一个绑定到<code>View</code>的<code>RWTFlickrPhoto</code>实例的数组，它们的暴露给<code>View</code>的<code>Model</code>层对象。为了添加这种可见性，我们将给<code>ViewModel</code>中的<code>model</code>对象添加<code>view-centric</code>状态。</p>
<p>在<code>ViewModel</code>分组中添加<code>RWTSearchResultsItemViewModel</code>类，打开头文件并各以下代码更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsItemViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>) initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> isVisible;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *favorites;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *comments;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>看看初始化方法，这个<code>ViewModel</code>封装了一个<code>RWTFlickrPhoto</code>模型对象的实例。这个<code>ViewModel</code>包含以下几类属性：</p>
<ol>
<li>表示底层<code>Model</code>属性的属性<code>(title, url)</code></li>
<li>当获取到元数据时动态更新的属性<code>(favorites, comments)</code></li>
<li><code>isVisible</code>，用于表示<code>ViewModel</code>是否可见</li>
</ol>
<p>打开<code>RWTSearchResultsItemViewModel.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhotoMetadata.h"</span></span></div></pre></td></tr></table></figure>
<p>接下来添加几个私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsItemViewModel</span> ()</span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span>&lt;RWTViewModelServices&gt; services;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RWTFlickrPhoto *photo;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    _title = photo.title;</div><div class="line">    _url = photo.url;</div><div class="line">    _services = services;</div><div class="line">    _photo = photo;</div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> initialize];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>  <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这基于<code>Model</code>对象的<code>title</code>和<code>url</code>属性，然后通过私有属性来存储服务和图片的引用。</p>
<p>接下来添加<code>initialize</code>方法。准备好，这里有些有趣的事情会发生。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initialize &#123;</div><div class="line">  RACSignal *fetchMetadata =</div><div class="line">    [RACObserve(<span class="keyword">self</span>, isVisible)</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *visible) &#123;</div><div class="line">       <span class="keyword">return</span> [visible boolValue];</div><div class="line">     &#125;];</div><div class="line"> </div><div class="line">  @weakify(<span class="keyword">self</span>)</div><div class="line">  [fetchMetadata subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>)</div><div class="line">    [[[<span class="keyword">self</span>.services getFlickrSearchService] flickrImageMetadata:<span class="keyword">self</span>.photo.identifier]</div><div class="line">     subscribeNext:^(RWTFlickrPhotoMetadata *x) &#123;</div><div class="line">       <span class="keyword">self</span>.favorites = @(x.favorites);</div><div class="line">       <span class="keyword">self</span>.comments = @(x.comments);</div><div class="line">     &#125;];</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的第一部分通过监听<code>isVisible</code>属性和过滤<code>true</code>值来创建一个名为<code>fetchMetadata</code>的信号。结果，信号在<code>isVisible</code>属性设置为<code>true</code>时发出<code>next</code>事件。第二部分订阅这个信号以初始化到<code>flickrImageMetadata</code>方法的请求。当这个嵌套的信号发送<code>next</code>事件时，<code>favorite</code>和<code>comment</code>属性使用这个结果来更新值。</p>
<p>总的来说，当<code>isVisible</code>设置为<code>true</code>时，发送<code>Flickr API</code>请求，并在将来某个时刻更新<code>comments</code>和<code>favorites</code>属性。</p>
<p>为了使用新的<code>ViewModel</code>，打开<code>RWTSearchResultsViewModel.m</code>并导入头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsItemViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>在初始化方法中，移除当前设置<code>_searchResults</code>的代码，并使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_searchResults =</div><div class="line">  [results.photos linq_select:^<span class="keyword">id</span>(RWTFlickrPhoto *photo) &#123;</div><div class="line">    <span class="keyword">return</span> [[RWTSearchResultsItemViewModel alloc]</div><div class="line">              initWithPhoto:photo services:services];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>这只是简单地使用一个<code>ViewModel</code>来包装每一个<code>Model</code>对象。</p>
<p>最后一步是通过视图来设置<code>isVisible</code>对象，并使用这些新的属性。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsItemViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>然后在下面的<code>bindViewModel</code>方法的第一行添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RWTSearchResultsItemViewModel *photo = viewModel;</div></pre></td></tr></table></figure>
<p>并在访方法中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[RACObserve(photo, favorites) subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">  <span class="keyword">self</span>.favouritesLabel.text = [x stringValue];</div><div class="line">  <span class="keyword">self</span>.favouritesIcon.hidden = (x == <span class="literal">nil</span>);</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">[RACObserve(photo, comments) subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">  <span class="keyword">self</span>.commentsLabel.text = [x stringValue];</div><div class="line">  <span class="keyword">self</span>.commentsIcon.hidden = (x == <span class="literal">nil</span>);</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">photo.isVisible = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>这个代码监听了新的<code>comments</code>和<code>favorites</code>属性，当它们更新<code>lable</code>和<code>image</code>时会更新。最后，<code>ModelView</code>的<code>isVisible</code>属性被设置成<code>YES</code>。<code>table view</code>绑定辅助类只绑定可见的单元格，所以只有少部分<code>ViewModel</code>去请求元数据。</p>
<p>运行后，以看到以下效果：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/WithMetadata-333x500.png" alt="image"></p>
<p>是不是很酷？</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>慢着，还有一个问题没有解决。当我们快速地滚动滑动栏，如果不做特殊，会同时加载大量的元数据和图片，这将明显地降低我们程序的性能。为了解决这个问题，程序应该只在照片显示在界面上的的时候去初始化元数据请求。现在<code>ViewModel</code>的<code>isVisible</code>属性被设置为<code>YES</code>，但不会被设置成<code>NO</code>。我们现在来处理这个问题。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>，然后修改刚才添加到<code>bindViewModel:</code>的代码，以设置<code>isVisible</code>属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">photo.isVisible = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.rac_prepareForReuseSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">  photo.isVisible = <span class="literal">NO</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>当<code>ViewModel</code>绑定到<code>View</code>时，<code>isVisible</code>属性会被设置成<code>YES</code>。但是当<code>cell</code>被移出<code>table view</code>进行重用时会被设置成<code>NO</code>。我们通过<code>rac_prepareForReuseSignal</code>信号来实现这步操作。</p>
<p>返回到<code>RWTSearchResultsItemViewModel</code>中。<code>ViewModel</code>需要监听<code>isVisible</code>属性的修改，当属性被设置成<code>YES</code>后一秒钟，将发送一个元数据的请求。</p>
<p>在<code>RWTSearchResultsItemViewModel.m</code>中，更新<code>initialize</code>方法，移除<code>fetchMetadata</code>信号的创建。使用以下代码来替换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 通过监听isVisible属性来创建信号。该信号发出的第一个next事件将包含这个属性的初始状态。</span></div><div class="line"><span class="comment">// 因为我们只关心这个值的改变，所以在第一个事件上调用skip操作。</span></div><div class="line">RACSignal *visibleStateChanged = [RACObserve(<span class="keyword">self</span>, isVisible) skip:<span class="number">1</span>];</div><div class="line"> </div><div class="line"><span class="comment">// 2. 通过过滤visibleStateChanged信号来创建一个信号对，一个标识从可见到隐藏的转换，另一个标识从隐藏到可见的转换</span></div><div class="line">RACSignal *visibleSignal = [visibleStateChanged filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">  <span class="keyword">return</span> [value boolValue];</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">RACSignal *hiddenSignal = [visibleStateChanged filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">  <span class="keyword">return</span> ![value boolValue];</div><div class="line">&#125;];</div><div class="line"> </div><div class="line"><span class="comment">// 3. 这里是最神奇的地方。通过延迟visibleSignal信号1秒钟来创建fetchMetadata信号，在获取元数据之前暂停一会。</span></div><div class="line"><span class="comment">// takeUntil操作确保如果cell在1秒的时间间隔内又一次隐藏时，来自visibleSignal的next事件被挂起且不获取元数据。</span></div><div class="line">RACSignal *fetchMetadata = [[visibleSignal delay:<span class="number">1.0</span>f]</div><div class="line">                           takeUntil:hiddenSignal];</div></pre></td></tr></table></figure>
<p>你可以想像一下如果没有<code>ReactiveCocoa</code>，这会有多复杂。</p>
<p>运行程序，现在我们和滑动显示平滑多了。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当前搜索<code>Flickr</code>的代码只处理了<code>OFFlickrAPIRequestDelegate</code>协议中的<code>flickrAPIRequest:didCompleteWithResponse:</code>方法。不过，这样网络请求由于多种原因会出错。一个好的应用程序必须处理这些错误，以给用户一个良好的用户体验。代理同时定义了<code>flickrAPIRequest:didFailWithError:</code>方法，这个方法在请求出错时调用。我们将用这个方法来处理错误并显示一个提示框给用户。</p>
<p>我们之前讲过信号会发出<code>next</code>，<code>completed</code>和错误事件。其结果是，我们并不需要做太多的事情。</p>
<p>打开<code>RWTFlickrSearchImpl.m</code>，并定位到<code>signalFromAPIMethod:arguments:transform:</code>方法。在这个方法中，在创建<code>successSignal</code>变量前添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *errorSignal =</div><div class="line">  [<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(flickrAPIRequest:didFailWithError:)</div><div class="line">                 fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">OFFlickrAPIRequestDelegate</span>)];</span></div><div class="line"> </div><div class="line">[errorSignal subscribeNext:^(RACTuple *tuple) &#123;</div><div class="line">  [subscriber sendError:tuple.second];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码从代理方法中创建了一个信号，订阅了该信号，如果发生错误则发送一个错误。传递给<code>subscribeNext</code>块的元组包含传递给<code>flickrAPIRequest:didFailWithError:</code>方法的变量。结果是，<code>tuple.second</code>获取源错误并使用它来为错误事件服务。这是一个很好的解决方案，你觉得呢？不是所有的<code>API</code>请求都有内建的错误处理。接下来我们使用它。</p>
<p><code>RWTFlickrSearchViewModel</code>不直接暴露信号给视图。相反它暴露一个状态和一个命令。我们需要扩展接口来提供错误报告。</p>
<p>打开<code>RWTFlickrSearchViewModel.h</code>并添加以下属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RACSignal *connectionErrors;</div></pre></td></tr></table></figure>
<p>打开<code>RWTFlickrSearchViewModel.m</code>并添加以下代码到<code>initialize</code>实现的最后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.connectionErrors = <span class="keyword">self</span>.executeSearch.errors;</div></pre></td></tr></table></figure>
<p><code>executeSearch</code>属性是一个<code>ReactiveCococa</code>框架的<code>RACCommand</code>对象。<code>RACCommand</code>类有一个<code>errors</code>属性，用于发送命令执行时产生的任何错误。</p>
<p>为了处理这些错误，打开<code>RWTFlickrSearchViewController.m</code>并添加以下的代码到<code>initWithViewModel:</code>方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[_viewModel.connectionErrors subscribeNext:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">  <span class="built_in">UIAlertView</span> *alert =</div><div class="line">  [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Connection Error"</span></div><div class="line">                             message:<span class="string">@"There was a problem reaching Flickr."</span></div><div class="line">                            delegate:<span class="literal">nil</span></div><div class="line">                   cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                   otherButtonTitles:<span class="literal">nil</span>];</div><div class="line">  [alert show];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行后，处理错误的效果如下：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/ErrorMessages-281x500.png" alt="image"></p>
<p>想知道为什么获取收藏和评论的请求不报告错误么？这是由设计决定的，主要是这些不会影响程序的可用性。</p>
<h2 id="添加最近搜索列表"><a href="#添加最近搜索列表" class="headerlink" title="添加最近搜索列表"></a>添加最近搜索列表</h2><p>用户可能会回去查看一些重复的图片。所以，我们可以做些简化操作。回想一下本文的开头，最后的程序在搜索输入框下面有一个显示最近搜索结果的列表。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image"></p>
<p>现在我们只需要添加上这个功能，这次我要向你发起一个挑战了。我将这一部分的实现留给读者您来处理，来练习练习<code>MVVM</code>技能吧。</p>
<p>在开始之前，我在这些做些总结：</p>
<ol>
<li>我将创建一个<code>ViewModel</code>来表示每个先前的搜索，它包含一些属性，这些属性包括搜索文本，匹配的数量和第一个匹配的图片</li>
<li>我将修改<code>RWTFlickrSearchViewModel</code>来暴露这些新的<code>ViewModel</code>对象的数组做为一个属性。</li>
<li>使用<code>CETableViewBindingHelper</code>可以非常简单地渲染<code>ViewModel</code>的数组，我已经添加了一个合适的<code>cell(RWTRecentSearchItemTableViewCell</code>)到工程中。</li>
</ol>
<h2 id="接下来何去何从？"><a href="#接下来何去何从？" class="headerlink" title="接下来何去何从？"></a>接下来何去何从？</h2><p>在<a href="https://github.com/ColinEberhardt/ReactiveFlickrSearch" target="_blank" rel="external">这里</a>可以下载最终的程序。这两部分的内容已经包含了很多内容，这里我们可以好好回顾一下主要点：</p>
<ol>
<li><code>MVVM</code>是<code>MVC</code>模式的一个变种，它正逐渐流行起来</li>
<li><code>MVVM</code>模式让<code>View</code>层代码变得更清晰，更易于测试</li>
<li>严格遵守<code>View=&gt;ViewModel=&gt;Model</code>这样一个引用层次，然后通过绑定来将<code>ViewModel</code>的更新反映到<code>View</code>层上。</li>
<li><code>ViewModel</code>层决不应该维护<code>View</code>的引用</li>
<li><code>ViewModel</code>层可以看作是视图的模型(<code>model-of-the-view</code>)，它暴露属性，以直接反映视图的状态，以及执行用户交互相关的命令。</li>
<li><code>Model</code>层暴露服务。</li>
<li>针对<code>MVVM</code>程序的测试可以在没有<code>UI</code>的情况下运行。</li>
<li><code>ReactiveCocoa</code>框架提供强大的机制来将<code>ViewModel</code>绑定到<code>View</code>。它同时也广泛地使用在<code>ViewModel</code>和<code>Model</code>层中。</li>
</ol>
<p>怎么样，下次创建程序的时候，是不是试试<code>MVVM</code>？试试吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
