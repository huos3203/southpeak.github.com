<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/4/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/4/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/31/cocoa-foundation-nsobject-class/" itemprop="url">
                  Foundation: NSObject Class
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-31T22:37:32+08:00" content="2015-01-31">
              2015-01-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em><code>Objective-C</code>中有两个<code>NSObject</code>，一个是<code>NSObject</code>类，另一个是<code>NSObject</code>协议。而其中<code>NSObject</code>类采用了<code>NSObject</code>协议。在本文中，我们主要整理一下<code>NSObject</code>类的使用。</em></p>
<p>说到<code>NSObject</code>类，写<code>Objective-C</code>的人都应该知道它。它是大部分<code>Objective-C</code>类继承体系的根类。这个类提供了一些通用的方法，对象通过继承<code>NSObject</code>，可以从其中继承访问运行时的接口，并让对象具备<code>Objective-C</code>对象的基本能力。以下我们就来看看<code>NSObejct</code>提供给我们的一些基础功能。</p>
<h2 id="load与-initialize"><a href="#load与-initialize" class="headerlink" title="+load与+initialize"></a>+load与+initialize</h2><p>这两个方法可能平时用得比较少，但很有用。在我们的程序编译后，类相关的数据结构会保留在目标文件中，在程序运行后会被解析和使用，此时类的信息会经历加载和初始化两个过程。在这两个过程中，会分别调用类的<code>load</code>方法和<code>initialize</code>方法，在这两个方法中，我们可以适当地做一些定制处理。不当是类本身，类的分类也会经历这两个过程。对于一个类，我们可以在类的定义中重写这两个方法，也可以在分类中重写它们，或者同时重写。</p>
<h3 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h3><p>对于<code>load</code>方法，当<code>Objective-C</code>运行时加载类或分类时，会调用这个方法；通常如果我们有一些类级别的操作需要在加载类时处理，就可以放在这里面，如为一个类执行<code>Swizzling Method</code>操作。</p>
<p><code>load</code>消息会被发送到动态加载和静态链接的类和分类里面。不过，只有当我们在类或分类里面实现这个方法时，类/分类才会去调用这个方法。</p>
<p>在类继承体系中，<code>load</code>方法的调用顺序如下：</p>
<ol>
<li>一个类的<code>load</code>方法会在其所有父类的<code>load</code>方法之后调用</li>
<li>分类的<code>load</code>方法会在对应类的<code>load</code>方法之后调用</li>
</ol>
<p>在<code>load</code>的实现中，如果使用同一库中的另外一个类，则可能是不安全的，因为可能存在的情况是另外一个类的<code>load</code>方法还没有运行，即另一个类可能尚未被加载。另外，在<code>load</code>方法里面，我们不需要显示地去调用<code>[super load]</code>，因为父类的<code>load</code>方法会自动被调用，且在子类之前。</p>
<p>在有依赖关系的两个库中，被依赖的库中的类其<code>load</code>方法会优先调用。但在库内部，各个类的<code>load</code>方法的调用顺序是不确定的。</p>
<h3 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h3><p>当我们在程序中向类或其任何子类发送第一条消息前，<code>runtime</code>会向该类发送<code>initialize</code>消息。<code>runtime</code>会以线程安全的方式来向类发起<code>initialize</code>消息。父类会在子类之前收到这条消息。父类的<code>initialize</code>实现可能在下面两种情况下被调用：</p>
<ol>
<li>子类没有实现<code>initialize</code>方法，<code>runtime</code>将会调用继承而来的实现</li>
<li>子类的实现中显示的调用了<code>[super initialize]</code></li>
</ol>
<p>如果我们不想让某个类中的<code>initialize</code>被调用多次，则可以像如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)initialize &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</div><div class="line">    <span class="comment">// ... do the initialization ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>initialize</code>是以线程安全的方式调用的，且在不同的类中<code>initialize</code>被调用的顺序是不确定的，所以在<code>initialize</code>方法中，我们应该做少量的必须的工作。特别需要注意是，如果我们<code>initialize</code>方法中的代码使用了锁，则可能会导致死锁。因此，我们不应该在<code>initialize</code>方法中实现复杂的初始化工作，而应该在类的初始化方法(如<code>-init</code>)中来初始化。</p>
<p>另外，每个类的<code>initialize</code>只会被调用一次。所以，如果我们想要为类和类的分类实现单独的初始化操作，则应该实现<code>load</code>方法。</p>
<p>如果想详细地了解这两个方法的使用，可以查看<code>《Effectiveobjc 2.0》</code>的第51条，里面有非常详细的说明。如果想更深入地了解这两个方法的调用，则可以参考<code>objc</code>库的源码，另外，<a href="http://www.cocoachina.com/ios/20150104/10826.html" target="_blank" rel="external">NSObject的load和initialize方法</a>一文从源码层面为我们简单介绍了这两个方法。</p>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p>一说到对象的创建，我们会立即想到<code>[[NSObject alloc] init]</code>这种经典的两段式构造。对于这种两段式构造，唐巧大神在他的”<a href="http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa/" target="_blank" rel="external">谈ObjC对象的两段构造模式</a>“一文中作了详细描述，大家可以参考一下。</p>
<p>本小节我们主要介绍一下与对象生命周期相关的一些方法。</p>
<h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p><code>NSObject</code>提供的对象分配的方法有<code>alloc</code>和<code>allocWithZone:</code>，它们都是类方法。这两个方法负责创建对象并为其分配内存空间，返回一个新的对象实例。新的对象的<code>isa</code>实例变量使用一个数据结构来初始化，这个数据结构描述了对象的信息；创建完成后，对象的其它实例变量被初始化为0。</p>
<p><code>alloc</code>方法的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)alloc</div></pre></td></tr></table></figure>
<p>而<code>allocWithZone:</code>方法的存在是由历史原因造成的，它的调用基本上和<code>alloc</code>是一样的。既然是历史原因，我们就不说了，官方文档只给了一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This method exists for historical reasons; memory zones are no longer used byobjc.</div></pre></td></tr></table></figure>
<p>我们只需要知道<code>alloc</code>方法的实现调用了<code>allocWithZone:</code>方法。</p>
<h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>我们一般不去自己重写<code>alloc</code>或<code>allocWithZone:</code>方法，不用去关心对象是如何创建、如何为其分配内存空间的；我们更关心的是如何去初始化这个对象。上面提到了，对象创建后，<code>isa</code>以外的实例变量都默认初始化为0。通常，我们希望将这些实例变量初始化为我们期望的值，这就是<code>init</code>方法的工作了。</p>
<p><code>NSObject</code>类默认提供了一个<code>init</code>方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div></pre></td></tr></table></figure>
<p>正常情况下，它会初始化对象，如果由于某些原因无法完成对象的创建，则会返回nil。注意，对象在使用之前必须被初始化，否则无法使用。不过，<code>NSObject</code>中定义的<code>init</code>方法不做任何初始化操作，只是简单地返回<code>self</code>。</p>
<p>当然，我们定义自己的类时，可以提供自定义的初始化方法，以满足我们自己的初始化需求。需要注意的就是子类的初始化方法需要去调用父类的相应的初始化方法，以保证初始化的正确性。</p>
<p>讲完两段式构造的两个部分，有必要来讲讲<code>NSObject</code>类的<code>new</code>方法了。</p>
<p><code>new</code>方法实际上是集<code>alloc</code>和<code>init</code>于一身，它创建了对象并初始化了对象。它的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)new &#123;</div><div class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>new</code>方法更多的是一个历史遗留产物，它源于<code>NeXT</code>时代。如果我们的初始化操作只是调用<code>[[self alloc] init]</code>时，就可以直接用<code>new</code>来代替。不过如果我们需要使用自定义的初始化方法时，通常就使用两段式构造方式。</p>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>说到拷贝，相信大家都很熟悉。拷贝可以分为“深拷贝”和“浅拷贝”。深拷贝拷贝的是对象的值，两个对象相互不影响，而浅拷贝拷贝的是对象的引用，修改一个对象时会影响到另一个对象。</p>
<p>在<code>Objective-C</code>中，如果一个类想要支持拷贝操作，则需要实现<code>NSCopying</code>协议，并实现<code>copyWithZone:</code>【注意：<code>NSObject</code>类本身并没有实现这个协议】。如果一个类不是直接继承自<code>NSObject</code>，则在实现copyWithZone:方法时需要调用父类的实现。</p>
<p>虽然<code>NSObject</code>自身没有实现拷贝协议，不过它提供了两个拷贝方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span></div></pre></td></tr></table></figure>
<p>这个是拷贝操作的便捷方法。它的返回值是<code>NSCopying</code>协议的<code>copyWithZone:</code>方法的返回值。如果我们的类没有实现这个方法，则会抛出一个异常。</p>
<p>与<code>copy</code>对应的还有一个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)mutableCopy</div></pre></td></tr></table></figure>
<p>从字面意义来讲，<code>copy</code>可以理解为不可变拷贝操作，而<code>mutableCopy</code>可以理解为可变操作。这便引出了拷贝的另一个特性，即可变性。</p>
<p>顾名思义，不可变拷贝即拷贝后的对象具有不可变属性，可变拷贝后的对象具有可变属性。这对于数组、字典、字符串、URL这种分可变和不可变的对象来说是很有意义的。我们来看如下示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="built_in">NSMutableArray</span> *array = [mutableArray <span class="keyword">copy</span>];</div><div class="line">[array addObject:<span class="string">@"test1"</span>];</div></pre></td></tr></table></figure>
<p>实际上，这段代码是会崩溃的，我们来看看崩溃日志：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x100107070</div><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x100107070'</div></pre></td></tr></table></figure>
<p>从中可以看出，经过<code>copy</code>操作，我们的<code>array</code>实际上已经变成不可变的了，其底层元类是<code>__NSArrayI</code>。这个类是不支持<code>addObject:</code>方法的。</p>
<p>偶尔在代码中，也会看到类似于下面的情况：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *array;</div></pre></td></tr></table></figure>
<p>这种属性的声明方式是有问题的，即上面提到的可变性问题。使用<code>self.array = **</code>赋值后，数组其实是不可变的，所以需要特别注意。</p>
<p><code>mutableCopy</code>的使用也挺有意思的，具体的还请大家自己去试验一下。</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>当一个对象的引用计数为0时，系统就会将这个对象释放。此时<code>runtime</code>会自动调用对象的<code>dealloc</code>方法。在<code>ARC</code>环境下，我们不再需要在此方法中去调用<code>[super dealloc]</code>了。我们重写这个方法主要是为了释放对象中用到的一些资源，如我们通过C方法分配的内存空间。<code>dealloc</code>方法的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div></pre></td></tr></table></figure>
<p>需要注意的是，我们不应该直接去调用这个方法。这些事都让<code>runtime</code>去做吧。</p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p><code>Objective-C</code>中对方法的调用并不是像C++里面那样直接调用，而是通过消息分发机制来实现的。这个机制核心的方法是<code>objc_msgSend</code>函数。消息机制的具体实现我们在此不做讨论，可以参考<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a>。</p>
<p>对于消息的发送，除了使用<code>[obj method]</code>这种机制之外，<code>NSObject</code>类还提供了一系列的<code>performSelector**</code>方法。这些方法可以让我们更加灵活地控制方法的调用。接下来我们就来看看这些方法的使用。</p>
<h3 id="在线程中调用方法"><a href="#在线程中调用方法" class="headerlink" title="在线程中调用方法"></a>在线程中调用方法</h3><p>如果我们想在当前线程中调用一个方法，则可以使用以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span> *)modes</div></pre></td></tr></table></figure>
<p>这两个方法会在当前线程的<code>Run loop</code>中设置一个定时器，以在<code>delay</code>指定的时间之后执行<code>aSelector</code>。如果我们希望定时器运行在默认模式(<code>NSDefaultRunLoopMode</code>)下，可以使用前一个方法；如果想自己指定<code>Run loop</code>模式，则可以使用后一个方法。</p>
<p>当定时器启动时，线程会从<code>Run loop</code>的队列中获取到消息，并执行相应的<code>selector</code>。如果<code>Run loop</code>运行在指定的模式下，则方法会成功调用；否则，定时器会处于等待状态，直到<code>Run loop</code>运行在指定模式下。</p>
<p>需要注意的是，调用这些方法时，<code>Run loop</code>会保留方法接收者及相关的参数的引用(即对这些对象做<code>retain</code>操作)，这样在执行时才不至于丢失这些对象。当方法调用完成后，<code>Run loop</code>会调用这些对象的<code>release</code>方法，减少对象的引用计数。</p>
<p>如果我们想在主线程上执行某个对象的方法，则可以使用以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> *)array</div></pre></td></tr></table></figure>
<p>我们都知道，iOS中所有的UI操作都需要在主线程中处理。如果想在某个二级线程的操作完成之后做UI操作，就可以使用这两个方法。</p>
<p>这两个方法会将消息放到主线程<code>Run loop</code>的队列中，前一个方法使用的是<code>NSRunLoopCommonModes</code>运行时模式；如果想自己指定运行模式，则使用后一个方法。方法的执行与之前的两个<code>performSelector</code>方法是类似的。当在一个线程中多次调用这个方法将不同的消息放入队列时，消息的分发顺序与入队顺序是一致的。</p>
<p>方法中的<code>wait</code>参数指定当前线程在指定的<code>selector</code>在主线程执行完成之后，是否被阻塞住。如果设置为YES，则当前线程被阻塞。如果当前线程是主线程，而该参数也被设置为YES，则消息会被立即发送并处理。</p>
<p>另外，这两个方法分发的消息不能被取消。</p>
<p>如果我们想在指定的线程中分发某个消息，则可以使用以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thread withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thread withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="built_in">NSArray</span> *)array</div></pre></td></tr></table></figure>
<p>这两个方法基本上与在主线程的方法差不多。在此就不再讨论。</p>
<p>如果想在后台线程中调用接收者的方法，可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg</div></pre></td></tr></table></figure>
<p>这个方法会在程序中创建一个新的线程。由<code>aSelector</code>表示的方法必须像程序中的其它新线程一样去设置它的线程环境。</p>
<p>当然，我们经常看到的<code>performSelector</code>系列方法中还有几个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anObject</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anObject withObject:(<span class="keyword">id</span>)anotherObject</div></pre></td></tr></table></figure>
<p>不过这几个方法是在<code>NSObject</code>协议中定义的，<code>NSObject</code>类实现了这个协议，也就定义了相应的实现。这个我们将在<code>NSObject</code>协议中来介绍。</p>
<h3 id="取消方法调用请求"><a href="#取消方法调用请求" class="headerlink" title="取消方法调用请求"></a>取消方法调用请求</h3><p>对于使用<code>performSelector:withObject:afterDelay:</code>方法(仅限于此方法)注册的执行请求，在调用发生前，我们可以使用以下两个方法来取消：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">id</span>)anArgument</div></pre></td></tr></table></figure>
<p>前一个方法会取消所以接收者为<code>aTarget</code>的执行请求，不过仅限于当前<code>run loop</code>，而不是所有的。</p>
<p>后一个方法则会取消由<code>aTarget</code>、<code>aSelector</code>和<code>anArgument</code>三个参数指定的执行请求。同样仅限于当前<code>run loop</code>。</p>
<h2 id="消息转发及动态解析方法"><a href="#消息转发及动态解析方法" class="headerlink" title="消息转发及动态解析方法"></a>消息转发及动态解析方法</h2><p>当一个对象能接收一个消息时，会走正常的方法调用流程。但如果一个对象无法接收一个消息时，就会走消息转发机制。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>具体流程可参考<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a>，<code>《Effectiveobjc 2.0》</code>一书的第12小节也有详细描述。在此我们只介绍一下<code>NSObject</code>类为实现消息转发提供的方法。</p>
<p>首先，对于动态方法解析，<code>NSObject</code>提供了以下两个方法来处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)name</div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)name</div></pre></td></tr></table></figure>
<p>从方法名我们可以看出，<code>resolveClassMethod:</code>是用于动态解析一个类方法；而<code>resolveInstanceMethod:</code>是用于动态解析一个实例方法。</p>
<p>我们知道，一个<code>Objective-C</code>方法是其实是一个C函数，它至少带有两个参数，即<code>self</code>和<code>_cmd</code>。我们使用<code>class_addMethod</code>函数，可以给类添加一个方法。我们以<code>resolveInstanceMethod:</code>为例，如果要给对象动态添加一个实例方法，则可以如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>) resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically))</div><div class="line">    &#123;</div><div class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其次，对于备用接收者，<code>NSObject</code>提供了以下方法来处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>该方法返回未被接收消息最先被转发到的对象。如果一个对象实现了这个方法，并返回一个非空的对象(且非对象本身)，则这个被返回的对象成为消息的新接收者。另外如果在非根类里面实现这个方法，如果对于给定的<code>selector</code>，我们没有可用的对象可以返回，则应该调用父类的方法实现，并返回其结果。</p>
<p>最后，对于完整转发，<code>NSObject</code>提供了以下方法来处理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div></pre></td></tr></table></figure>
<p>当前面两步都无法处理消息时，运行时系统便会给接收者最后一个机会，将其转发给其它代理对象来处理。这主要是通过创建一个表示消息的<code>NSInvocation</code>对象并将这个对象当作参数传递给<code>forwardInvocation:</code>方法。我们在<code>forwardInvocation:</code>方法中可以选择将消息转发给其它对象。</p>
<p>在这个方法中，主要是需要做两件事：</p>
<ol>
<li>找到一个能处理<code>anInvocation</code>调用的对象。</li>
<li>将消息以<code>anInvocation</code>的形式发送给对象。<code>anInvocation</code>将维护调用的结果，而运行时则会将这个结果返回给消息的原始发送者。</li>
</ol>
<p>这一过程如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</div><div class="line">&#123;</div><div class="line">    SEL aSelector = [invocation selector];</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ([friend respondsToSelector:aSelector])</div><div class="line">        [invocation invokeWithTarget:friend];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [<span class="keyword">super</span> forwardInvocation:invocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，对于一个非根类，如果还是无法处理消息，则应该调用父类的实现。而NSObject类对于这个方法的实现，只是简单地调用了<code>doesNotRecognizeSelector:</code>。它不再转发任何消息，而是抛出一个异常。<code>doesNotRecognizeSelector:</code>的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>运行时系统在对象无法处理或转发一个消息时会调用这个方法。这个方法引发一个<code>NSInvalidArgumentException</code>异常并生成一个错误消息。</p>
<p>任何<code>doesNotRecognizeSelector:</code>消息通常都是由运行时系统来发送的。不过，它们可以用于阻止一个方法被继承。例如，一个<code>NSObject</code>的子类可以按以下方式来重写<code>copy</code>或<code>init</code>方法以阻止继承：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span></div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:_cmd];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码阻止子类的实例响应<code>copy</code>消息或阻止父类转发<code>copy</code>消息–虽然<code>respondsToSelector:</code>仍然报告接收者可以访问<code>copy</code>方法。</p>
<p>当然，如果我们要重写<code>doesNotRecognizeSelector:</code>方法，必须调用<code>super</code>的实现，或者在实现的最后引发一个<code>NSInvalidArgumentException</code>异常。它代表对象不能响应消息，所以总是应该引发一个异常。</p>
<h2 id="获取方法信息"><a href="#获取方法信息" class="headerlink" title="获取方法信息"></a>获取方法信息</h2><p>在消息转发的最后一步中，<code>forwardInvocation:</code>参数是一个<code>NSInvocation</code>对象，这个对象需要获取方法签名的信息，而这个签名信息就是从<code>methodSignatureForSelector:</code>方法中获取的。</p>
<p>该方法的声明如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>这个方法返回包含方法描述信息的<code>NSMethodSignature</code>对象，如果找不到方法，则返回nil。如果我们的对象包含一个代理或者对象能够处理它没有直接实现的消息，则我们需要重写这个方法来返回一个合适的方法签名。</p>
<p>对应于实例方法，当然还有一个处理类方法的相应方法，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>另外，<code>NSObject</code>类提供了两个方法来获取一个<code>selector</code>对应的方法实现的地址，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (IMP)methodForSelector:(SEL)aSelector</div><div class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>获取到了方法实现的地址，我们就可以直接将<code>IMP</code>以函数形式来调用。</p>
<p>对于<code>methodForSelector:</code>方法，如果接收者是一个对象，则<code>aSelector</code>应该是一个实例方法；如果接收者是一个类，则<code>aSelector</code>应该是一个类方法。</p>
<p>对于<code>instanceMethodForSelector:</code>方法，其只是向类对象索取实例方法的实现。如果接收者的实例无法响应<code>aSelector</code>消息，则产生一个错误。</p>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>对于类的测试，在<code>NSObject</code>类中定义了两个方法，其中类方法<code>instancesRespondToSelector:</code>用于测试接收者的实例是否响应指定的消息，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)instancesRespondToSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>如果<code>aSelector</code>消息被转发到其它对象，则类的实例可以接收这个消息而不会引发错误，即使该方法返回NO。</p>
<p>为了询问类是否能响应特定消息(注意：不是类的实例)，则使用这个方法，而不使用NSObject协议的实例方法<code>respondsToSelector:</code>。</p>
<p><code>NSObject</code>还提供了一个方法来查看类是否采用了某个协议，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol</div></pre></td></tr></table></figure>
<p>如果一个类直接或间接地采用了一个协议，则我们可以说这个类实现了该协议。我们可以看看以下这个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AffiliationRequests</span> &lt;<span class="title">Joining</span>&gt;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">AffiliationRequests</span>, <span class="title">Normalization</span>&gt;</span></div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> canJoin = [MyClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">Joining</span>)];</span></div></pre></td></tr></table></figure>
<p>通过继承体系，<code>MyClass</code>类实现了<code>Joining</code>协议。</p>
<p>不过，这个方法并不检查类是否实现了协议的方法，这应该是程序员自己的职责了。</p>
<h2 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h2><p><code>NSObject</code>类提供了几个类方法来识别一个类，首先是我们常用的<code>class</code>类方法，该方法声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (Class)<span class="keyword">class</span></div></pre></td></tr></table></figure>
<p>该方法返回类对象。当类是消息的接收者时，我们只通过类的名称来引用一个类。在其它情况下，类的对象必须通过这个方法类似的方法(<code>-class</code>实例方法)来获取。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> test = [<span class="keyword">self</span> isKindOfClass:[SomeClass <span class="keyword">class</span>]];</div></pre></td></tr></table></figure>
<p><code>NSObject</code>还提供了<code>superclass</code>类方法来获取接收者的父类，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (Class)superclass</div></pre></td></tr></table></figure>
<p>另外，我们还可以使用<code>isSubclassOfClass:</code>类方法查看一个类是否是另一个类的子类，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)isSubclassOfClass:(Class)aClass</div></pre></td></tr></table></figure>
<h2 id="描述类"><a href="#描述类" class="headerlink" title="描述类"></a>描述类</h2><p>描述类是使用<code>description</code>方法，它返回一个表示类的内容的字符串。其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span> *)description</div></pre></td></tr></table></figure>
<p>我们在<code>LLDB</code>调试器中打印类的信息时，使用的就是这个方法。</p>
<p>当然，如果想打印类的实例的描述时，使用的是<code>NSObject</code>协议中的实例方法<code>description</code>，我们在此不多描述。</p>
<p>​    </p>
<h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><p>一说到归档操作，你会首先想到什么呢？我想到的是<code>NSCoding</code>协议以及它的两个方法：</p>
<p><code>initWithCoder:</code>和<code>encodeWithCoder:</code>。如果我们的对象需要支持归档操作，则应该采用这个协议并提供两个方法的具体实现。</p>
<p>在编码与解码的过程中，一个编码器会调用一些方法，这些方法允许将对象编码以替代一个更换类或实例本身。这样，就可以使得归档在不同类层次结构或类的不同版本的实现中被共享。例如，类簇能有效地利用这一特性。这一特性也允许每个类在解码时应该只维护单一的实例来执行这一策略。</p>
<p><code>NSObject</code>类虽然没有采用<code>NSCoding</code>协议，但却提供了一些替代方法，以支持上述策略。这些方法分为两类，即通用和专用的。</p>
<p>通用方法由<code>NSCoder</code>对象调用，主要有如下几个方法和属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) Class classForCoder</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)replacementObjectForCoder:(<span class="built_in">NSCoder</span> *)aCoder</div><div class="line">- (<span class="keyword">id</span>)awakeAfterUsingCoder:(<span class="built_in">NSCoder</span> *)aDecoder</div></pre></td></tr></table></figure>
<p>专用的方法主要是针对<code>NSKeyedArchiver</code>对象的，主要有如下几个方法和属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) Class classForKeyedArchiver</div><div class="line"></div><div class="line">+ (<span class="built_in">NSArray</span> *)classFallbacksForKeyedArchiver</div><div class="line">+ (Class)classForKeyedUnarchiver</div><div class="line">- (<span class="keyword">id</span>)replacementObjectForKeyedArchiver:(<span class="built_in">NSKeyedArchiver</span> *)archiver</div></pre></td></tr></table></figure>
<p>子类在归档的过程中如果有特殊的需求，可以重写这些方法。这些方法的具体描述，可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class" target="_blank" rel="external">官方文档</a>。</p>
<p>在解码或解档过程中，有一点需要考虑的就是对象所属类的版本号，这样能确保老版本的对象能被正确地解析。<code>NSObject</code>类对此提供了两个方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)setVersion:(<span class="built_in">NSInteger</span>)aVersion</div><div class="line">+ (<span class="built_in">NSInteger</span>)version</div></pre></td></tr></table></figure>
<p>它们都是类方法。默认情况下，如果没有设置版本号，则默认是0.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>NSObject</code>类是<code>Objective-C</code>中大部分类层次结构中的根类，并为我们提供了很多功能。了解这些功能更让我们更好地发挥<code>Objective-C</code>的特性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class" target="_blank" rel="external">NSObject Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html" target="_blank" rel="external">Archives and Serializations Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/ios/20150104/10826.html" target="_blank" rel="external">NSObject的load和initialize方法</a></li>
<li><a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a></li>
<li>《Effectiveobjc 2.0》</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/25/tool-lldb/" itemprop="url">
                  LLDB调试器使用简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-25T21:33:25+08:00" content="2015-01-25">
              2015-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着<code>Xcode 5</code>的发布，<code>LLDB</code>调试器已经取代了<code>GDB</code>，成为了<code>Xcode</code>工程中默认的调试器。它与<code>LLVM</code>编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。<code>LLDB</code>为<code>Xcode</code>提供了底层调试环境，其中包括内嵌在Xcode IDE中的位于调试区域的控制面板，在这里我们可以直接调用<code>LLDB</code>命令。如图1所示：</p>
<p>图1：位于<code>Xcode</code>调试区域的控制台</p>
<p><img src="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/art/lldb_in_xc5_command_window_2x.png" alt="image"></p>
<p>在本文中，我们主要整理一下<code>LLDB</code>调试器提供给我们的调试命令，更详细的内容可以查看<a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="external">The LLDB Debugger</a>。</p>
<h2 id="LLDB命令结构"><a href="#LLDB命令结构" class="headerlink" title="LLDB命令结构"></a>LLDB命令结构</h2><p>在使用<code>LLDB</code>前，我们需要了解一下<code>LLDB</code>的命令结构及语法，这样可以尽可能地挖掘<code>LLDB</code>的潜能，以帮助我们更充分地利用它。</p>
<p>LLDB命令的语法有其通用结构，通常是以下形式的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</div></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li><code>&lt;command&gt;</code>(命令)和<code>&lt;subcommand&gt;</code>(子命令)：<code>LLDB</code>调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</li>
<li><code>&lt;action&gt;</code>：我们想在前面的命令序列的上下文中执行的一些操作。</li>
<li><code>&lt;options&gt;</code>：行为修改器(<code>action modifiers</code>)。通常带有一些值。</li>
<li><code>&lt;argument&gt;</code>：根据使用的命令的上下文来表示各种不同的东西。</li>
</ol>
<p><code>LLBD</code>命令行的解析操作在执行命令之前完成。上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;</div><div class="line">(lldb) command [subcommand] -option &apos;some &quot;quoted&quot; string&apos;</div></pre></td></tr></table></figure>
<p>这种命令解析设计规范了<code>LLDB</code>命令语法，并对所有命令做了个统一。</p>
<h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p><code>LLDB</code>中的命令选项有规范形式和缩写形式两种格式。以设置断点的命令<code>breakpoint set</code>为例，以下列表了其部分选项的格式，其中括号中的是规范形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">breakpoint set</div><div class="line">   -M &lt;method&gt; ( --method &lt;method&gt; )</div><div class="line">   -S &lt;selector&gt; ( --selector &lt;selector&gt; )</div><div class="line">   -b &lt;function-name&gt; ( --basename &lt;function-name&gt; )</div><div class="line">   -f &lt;filename&gt; ( --file &lt;filename&gt; )</div><div class="line">   -l &lt;linenum&gt; ( --line &lt;linenum&gt; )</div><div class="line">   -n &lt;function-name&gt; ( --name &lt;function-name&gt; )</div><div class="line">…</div></pre></td></tr></table></figure>
<p>各选项的顺序是任意的。如果后面的参数是以”-“开头的，则在选项后面添加”–”作为选项的终止信号，以告诉LLDB我们处理的选项的正确位置。如下命令所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) process launch --stop-at-entry -- -program_arg_1 value -program_arg_2 value</div></pre></td></tr></table></figure>
<p>如上所示，命令的选项是<code>--stop-at-entry</code>，参数是<code>-program_arg_1</code>和<code>-program_arg_2</code>，我们使用”–”将选项与参数作一下区分。</p>
<h3 id="原始命令"><a href="#原始命令" class="headerlink" title="原始命令"></a>原始命令</h3><p><code>LLDB</code>命令解析器支持”原始(raw)”命令，即没有命令选项，命令字符串的剩余部分未经解析就传递给命令。例如，<code>expression</code>就是一个原始命令。</p>
<p>不过原始命令也可以有选项，如果命令字符串中有虚线，则在命令名与命令字符串之间放置一个选项结束符(–)来表明没有命令标记。</p>
<p>我们可以通过help命令的输出来查看一个命令是否是原始命令。</p>
<h3 id="命令补全-Command-Completion"><a href="#命令补全-Command-Completion" class="headerlink" title="命令补全(Command Completion)"></a>命令补全(Command Completion)</h3><p><code>LLDB</code>支持源文件名，符号名，文件名，等等的命令补全(<code>Commmand Completion</code>)。终端窗口中的补全是通过在命令行中输入一个制表符来初始化的。<code>Xcode</code>控制台中的补全与在源码编辑器中的补全方式是一样的：补全会在第三个字符被键入时自动弹出，或者通过<code>Esc</code>键手动弹出。</p>
<p>一个命令中的私有选项可以有不同的完成者(<code>completers</code>)。如<code>breakpoint</code>中的<code>--file &lt;path&gt;</code>选项作为源文件的完成者，<code>--shlib &lt;path&gt;</code>选项作为当前加载的库的完成者，等等。这些行为是特定的，例如，如果指定<code>--shlib &lt;path&gt;</code>，且以<code>--file &lt;path&gt;</code>结尾，则<code>LLDB</code>只会列出由<code>--shlib &lt;path&gt;</code>指定的共享类库。</p>
<h3 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h3><p>对于高级用户来说，<code>LLDB</code>有一个内置的<code>Python</code>解析器，可以通过脚本命令来访问。调试器中的所有特性在<code>Python</code>解析器中都可以作为类来访问。这样，我们就可以使用<code>LLDB-Python</code>库来写<code>Python</code>函数，并通过脚本将其加载到运行会话中，以执行一些更复杂的调试操作。</p>
<h2 id="在命令行中调试程序"><a href="#在命令行中调试程序" class="headerlink" title="在命令行中调试程序"></a>在命令行中调试程序</h2><p>通常我们都是在<code>Xcode</code>中直接使用<code>LLDB</code>调试器，<code>Xcode</code>会帮我们完成很多操作。当然，如果我们想让自己看着更<code>Bigger</code>，或者想了解下调试器具体的一些流程，就可以试试直接在终端使用<code>LLDB</code>命令来调试程序。在终端中使用<code>LLDB</code>调试器，我们需要了解以下内容：</p>
<ol>
<li>加载程序以备调试</li>
<li>将一个运行的程序绑定到<code>LLDB</code></li>
<li>设置断点和观察点</li>
<li>控制程序的执行</li>
<li>在调试的程序中导航</li>
<li>检查状态和值的变量</li>
<li>执行替代代码</li>
</ol>
<p>了解在终端中这些操作是如何进行的，可以帮助我们更深入的了解调试器在<code>Xcode</code>中是如何运作的。下面我们分步来介绍一下。</p>
<h3 id="指定需要调试的程序"><a href="#指定需要调试的程序" class="headerlink" title="指定需要调试的程序"></a>指定需要调试的程序</h3><p>首先我们需要设置需要调试的程序。我们可以使用如下命令做到这一点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ lldb /Projects/Sketch/build/Debug/Sketch.app </div><div class="line">Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).</div></pre></td></tr></table></figure>
<p>或者在运行<code>lldb</code>后，使用<code>file</code>命令来处理，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lldb </div><div class="line">(lldb) file /Projects/Sketch/build/Debug/Sketch.app </div><div class="line">Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).</div></pre></td></tr></table></figure>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>在设置完程序后，我们可能想设置一点断点来调试程序。此时我们可以使用<code>breakpoint set</code>命令来设置断点，这个命令简单、直观，且有智能补全，接下来我们看看它的具体操作。</p>
<p>如果想在某个文件中的某行设置一个断点，可使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --file foo.c --line <span class="number">12</span></div></pre></td></tr></table></figure>
<p>如果想给某个函数设置断点，可使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --name foo</div></pre></td></tr></table></figure>
<p>如果想给C++中所有命名为<code>foo</code>的方法设置断点，可以使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --method foo</div></pre></td></tr></table></figure>
<p>如果想给<code>Objective-C</code>中所有命名为<code>alignLeftEdges:</code>的选择器设置断点，则可以使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --selector alignLeftEdges:</div></pre></td></tr></table></figure>
<p>我们可以使用<code>--shlib &lt;path&gt;</code>来将断点限定在一个特定的可执行库中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --shlib foo.dylib --name foo</div></pre></td></tr></table></figure>
<p>看吧，断点设置命令还是很强大的。</p>
<p>如果我们想查看程序中所有的断点，则可以使用<code>breakpoint list</code>命令，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint list</div><div class="line">Current breakpoints:</div><div class="line">1: name = 'alignLeftEdges:', locations = 1, resolved = 1</div><div class="line">  1.1: where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405, address = 0x0000000100010d5b, resolved, hit count = 0</div></pre></td></tr></table></figure>
<p>从上面的输出结果可以看出，一个断点一般有两部分：</p>
<ol>
<li>断点的逻辑规范，这一部分是用户提供给<code>breakpoint set</code>命令的。</li>
<li>与规范匹配的断点的位置。</li>
</ol>
<p>如上所示，通过<code>&quot;breakpoint set --selector alignLeftEdges:&quot;</code>设置的断点，其信息中会显示出所有<code>alignLeftEdges:</code>方法的位置。</p>
<p><code>breakpoint list</code>命令输出列表显示每个逻辑断点都有一个整数标识，如上所示断点标识为1。而每个位置也会有一个标识，如上所示的1.1。</p>
<p>输出列表中另一个信息是断点位置是否是已解析的(<code>resolved</code>)。这个标识表示当与之相关的文件地址被加载到程序进行调试时，其位置是已解析的。例如，如果在共享库中设置的断点之后被卸载了，则断点的位置还会保留，但其不能再被解析。</p>
<p>不管是逻辑断点产生的所有位置，还是逻辑断点解析的任何特定位置，我们都可以使用断点触发命令来对其进行删除、禁用、设置条件或忽略计数操作。例如，如果我们想添加一个命令，以在LLDB命中断点1.1时打印跟踪栈，则可以执行以下命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint command add 1.1</div><div class="line">Enter your debugger command(s). Type 'DONE' to end.</div><div class="line">&gt; bt</div><div class="line">&gt; DONE</div></pre></td></tr></table></figure>
<p>如果想更详细地了解<code>&quot;breakpoint command add&quot;</code>命令的使用，可以使用<code>help</code>帮助系统来查看。</p>
<h3 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h3><p>作为断点的补充，<code>LLDB</code>支持观察点以在不中断程序运行的情况下监测一些变量。例如，我们可以使用以下命令来监测名为<code>global</code>的变量的写操作，并在(<code>global==5</code>)为真时停止监测：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">(lldb) watch set var global</div><div class="line">Watchpoint created: Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w</div><div class="line">   declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'</div><div class="line">(lldb) watch modify -c '(global==5)'</div><div class="line">(lldb) watch list</div><div class="line">Current watchpoints:</div><div class="line">Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w</div><div class="line">    declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'</div><div class="line">    condition = '(global==5)'</div><div class="line">(lldb) c</div><div class="line">Process 15562 resuming</div><div class="line">(lldb) about to write to 'global'...</div><div class="line">Process 15562 stopped and was programmatically restarted.</div><div class="line">Process 15562 stopped and was programmatically restarted.</div><div class="line">Process 15562 stopped and was programmatically restarted.</div><div class="line">Process 15562 stopped and was programmatically restarted.</div><div class="line">Process 15562 stopped</div><div class="line">* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1</div><div class="line">    frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16</div><div class="line">   13</div><div class="line">   14      static void modify(int32_t &amp;var) &#123;</div><div class="line">   15          ++var;</div><div class="line">-&gt; 16      &#125;</div><div class="line">   17</div><div class="line">   18      int main(int argc, char** argv) &#123;</div><div class="line">   19          int local = 0;</div><div class="line">(lldb) bt</div><div class="line">* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1</div><div class="line">    frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16</div><div class="line">    frame #1: 0x0000000100000eac a.out`main + 108 at main.cpp:25</div><div class="line">    frame #2: 0x00007fff8ac9c7e1 libdyld.dylib`start + 1</div><div class="line">(lldb) frame var global</div><div class="line">(int32_t) global = 5</div><div class="line">(lldb) watch list -v</div><div class="line">Current watchpoints:</div><div class="line">Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w</div><div class="line">    declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'</div><div class="line">    condition = '(global==5)'</div><div class="line">    hw_index = 0  hit_count = 5     ignore_count = 0</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>可以使用<code>help watchpoint</code>来查看该命令的使用。</p>
<h3 id="使用LLDB来启动程序"><a href="#使用LLDB来启动程序" class="headerlink" title="使用LLDB来启动程序"></a>使用LLDB来启动程序</h3><p>一旦指定了调试哪个程序，并为其设置了一些断点后，就可以开始运行程序了。我们可以使用以下命令来启动程序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) process launch</div><div class="line">(lldb) run</div><div class="line">(lldb) r</div></pre></td></tr></table></figure>
<p>我们同样可以使用进程ID或进程名来连接一个已经运行的程序。当使用名称来连接一个程序时，<code>LLDB</code>支持<code>--waitfor</code>选项。这个选项告诉<code>LLDB</code>等待下一个名称为指定名称的程序出现，然后连接它。例如，下面3个命令都是用于连接<code>Sketch</code>程序(假定其进程ID为123)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) process attach --pid 123</div><div class="line">(lldb) process attach --name Sketch</div><div class="line">(lldb) process attach --name Sketch --waitfor</div></pre></td></tr></table></figure>
<p>启动或连接程序后，进程可能由于某些原因而停止，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) process attach -p <span class="number">12345</span></div><div class="line">Process <span class="number">46915</span> Attaching</div><div class="line">Process <span class="number">46915</span> Stopped</div><div class="line"><span class="number">1</span> of <span class="number">3</span> threads stopped with reasons:</div><div class="line">* thread <span class="meta">#1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10,</span></div><div class="line">stop reason = signal = SIGSTOP, queue = com.apple.main-thread</div></pre></td></tr></table></figure>
<p>注意<code>“1 of 3 threads stopped with reasons:”</code>及其下面一行。在多线程环境下，在内核实际返回控制权给调试器前，可能会有多个线程命中同一个断点。在这种情况下，我们可以在停止信息中看到所有因此而停止的线程。</p>
<h3 id="控制程序"><a href="#控制程序" class="headerlink" title="控制程序"></a>控制程序</h3><p>启动程序后，<code>LLDB</code>允许程序在到达断点前继续运行。<code>LLDB</code>中流程控制的命令都在<code>thread</code>命令层级中。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) thread <span class="keyword">continue</span></div><div class="line">Resuming thread <span class="number">0x2c03</span> <span class="keyword">in</span> process <span class="number">46915</span></div><div class="line">Resuming process <span class="number">46915</span></div></pre></td></tr></table></figure>
<p>另外，还有以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(lldb) thread step-<span class="keyword">in</span> <span class="comment">// The same as "step" or "s" in GDB.</span></div><div class="line">(lldb) thread step-over <span class="comment">// The same as "next" or "n" in GDB.</span></div><div class="line">(lldb) thread step-<span class="keyword">out</span> <span class="comment">// The same as "finish" or "f" in GDB.</span></div><div class="line">(lldb) thread step-inst <span class="comment">// The same as "stepi" / "si" in GDB.</span></div><div class="line">(lldb) thread step-over-inst <span class="comment">// The same as "nexti" / "ni" in GDB.</span></div></pre></td></tr></table></figure>
<p><code>LLDB</code>还提供了<code>run until line</code>按步调度模式，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lldb) thread until <span class="number">100</span></div></pre></td></tr></table></figure>
<p>这条命令会运行线程，直到当前<code>frame</code>到达<code>100</code>行。如果代码在运行的过程中跳过了<code>100</code>行，则当<code>frame</code>被弹出栈后终止执行。</p>
<h3 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h3><p>在进程停止后，LLDB会选择一个当前线程和线程中当前帧(frame)。很多检测状态的命令可以用于这个线程或帧。</p>
<p>为了检测进程的当前状态，可以从以下命令开始：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(lldb) thread list</div><div class="line">Process <span class="number">46915</span> state is Stopped</div><div class="line">* thread <span class="meta">#1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10, stop reason = signal = SIGSTOP, queue = com.apple.main-thread</span></div><div class="line">  thread <span class="meta">#2: tid = 0x2e03, 0x00007fff85cbb08a, where = libSystem.B.dylib`kevent + 10, queue = com.apple.libdispatch-manager</span></div><div class="line">  thread <span class="meta">#3: tid = 0x2f03, 0x00007fff85cbbeaa, where = libSystem.B.dylib`__workq_kernreturn + 10</span></div></pre></td></tr></table></figure>
<p>星号(*)表示<code>thread #1</code>为当前线程。为了获取线程的跟踪栈，可以使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(lldb) thread backtrace</div><div class="line"> </div><div class="line">thread <span class="meta">#1: tid = 0x2c03, stop reason = breakpoint 1.1, queue = com.apple.main-thread</span></div><div class="line"> frame <span class="meta">#0: 0x0000000100010d5b, where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405</span></div><div class="line"> frame <span class="meta">#1: 0x00007fff8602d152, where = AppKit`-[NSApplication sendAction:to:from:] + 95</span></div><div class="line"> frame <span class="meta">#2: 0x00007fff860516be, where = AppKit`-[NSMenuItem _corePerformAction] + 365</span></div><div class="line"> frame <span class="meta">#3: 0x00007fff86051428, where = AppKit`-[NSCarbonMenuImpl performActionWithHighlightingForItemAtIndex:] + 121</span></div><div class="line"> frame <span class="meta">#4: 0x00007fff860370c1, where = AppKit`-[NSMenu performKeyEquivalent:] + 272</span></div><div class="line"> frame <span class="meta">#5: 0x00007fff86035e69, where = AppKit`-[NSApplication _handleKeyEquivalent:] + 559</span></div><div class="line"> frame <span class="meta">#6: 0x00007fff85f06aa1, where = AppKit`-[NSApplication sendEvent:] + 3630</span></div><div class="line"> frame <span class="meta">#7: 0x00007fff85e9d922, where = AppKit`-[NSApplication run] + 474</span></div><div class="line"> frame <span class="meta">#8: 0x00007fff85e965f8, where = AppKit`NSApplicationMain + 364</span></div><div class="line"> frame <span class="meta">#9: 0x0000000100015ae3, where = Sketch`main + 33 at /Projects/Sketch/SKTMain.m:11</span></div><div class="line"> frame <span class="meta">#10: 0x0000000100000f20, where = Sketch`start + 52</span></div></pre></td></tr></table></figure>
<p>如果想查看所有线程的调用栈，则可以使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) thread backtrace all</div></pre></td></tr></table></figure>
<h3 id="查看调用栈状态"><a href="#查看调用栈状态" class="headerlink" title="查看调用栈状态"></a>查看调用栈状态</h3><p>检查帧参数和本地变量的最简便的方式是使用<code>frame variable</code>命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) frame variable</div><div class="line"><span class="keyword">self</span> = (<span class="built_in">SKTGraphicView</span> *) <span class="number">0x0000000100208b40</span></div><div class="line">_cmd = (<span class="keyword">struct</span> objc_selector *) <span class="number">0x000000010001bae1</span></div><div class="line">sender = (<span class="keyword">id</span>) <span class="number">0x00000001001264e0</span></div><div class="line">selection = (<span class="built_in">NSArray</span> *) <span class="number">0x00000001001264e0</span></div><div class="line">i = (<span class="built_in">NSUInteger</span>) <span class="number">0x00000001001264e0</span></div><div class="line">c = (<span class="built_in">NSUInteger</span>) <span class="number">0x00000001001253b0</span></div></pre></td></tr></table></figure>
<p>如果没有指定任何变量名，则会显示所有参数和本地变量。如果指定参数名或变量名，则只打印指定的值。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) frame variable <span class="keyword">self</span></div><div class="line">(<span class="built_in">SKTGraphicView</span> *) <span class="keyword">self</span> = <span class="number">0x0000000100208b40</span></div></pre></td></tr></table></figure>
<p><code>frame variable</code>命令不是一个完全的表达式解析器，但它支持一些简单的操作符，如<code>&amp;,*,-&gt;,[]</code>。这个数组括号可用于指针，以将指针作为数组处理。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(lldb) frame variable *<span class="keyword">self</span></div><div class="line">(<span class="built_in">SKTGraphicView</span> *) <span class="keyword">self</span> = <span class="number">0x0000000100208b40</span></div><div class="line">(<span class="built_in">NSView</span>) <span class="built_in">NSView</span> = &#123;</div><div class="line">(<span class="built_in">NSResponder</span>) <span class="built_in">NSResponder</span> = &#123;</div><div class="line">...</div><div class="line"> </div><div class="line">(lldb) frame variable &amp;<span class="keyword">self</span></div><div class="line">(<span class="built_in">SKTGraphicView</span> **) &amp;<span class="keyword">self</span> = <span class="number">0x0000000100304ab</span></div><div class="line"> </div><div class="line">(lldb) frame variable argv[<span class="number">0</span>]</div><div class="line">(<span class="keyword">char</span> <span class="keyword">const</span> *) argv[<span class="number">0</span>] = <span class="number">0x00007fff5fbffaf8</span> <span class="string">"/Projects/Sketch/build/Debug/Sketch.app/Contents/MacOS/Sketch"</span></div></pre></td></tr></table></figure>
<p><code>frame variable</code>命令会在变量上执行”对象打印”操作。目前，<code>LLDB</code>只支持<code>Objective-C</code>打印，使用的是对象的<code>description</code>方法。</p>
<p>如果想查看另外一帧，可以使用<code>frame select</code>命令，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) frame select <span class="number">9</span></div><div class="line">frame <span class="meta">#9: 0x0000000100015ae3, where = Sketch`function1 + 33 at /Projects/Sketch/SKTFunctions.m:11</span></div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上所介绍的命令可以让我们在终端中直接调试程序。当然，很多命令也可以在<code>Xcode</code>中直接使用。这些命令可以让我们了解程序运行的状态，当然有些状态可以在<code>Xcode</code>中了解到。建议在调试过程中，可以多使用这些命令。</p>
<p>如果想了解这一过程中使用的各种命令，可以查看<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">苹果的官方文档</a>。</p>
<h2 id="在Xcode中调试程序"><a href="#在Xcode中调试程序" class="headerlink" title="在Xcode中调试程序"></a>在Xcode中调试程序</h2><p>对于我们日常的开发工作来说，更多的时候是在<code>Xcode</code>中进行调试工作。因此上面所描述的流程，其实<code>Xcode</code>已经帮我们完成了大部分的工作，而且很多东西也可以在<code>Xcode</code>里面看到。因此，我们可以把精力都集中在代码层面上。</p>
<p>在<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">苹果的官方文档</a>中列出了我们在调试中能用到的一些命令，我们在这重点讲一些常用的命令。</p>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>打印变量的值可以使用<code>print</code>命令，该命令如果打印的是简单类型，则会列出简单类型的类型和值。如果是对象，还会打印出对象指针地址，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(lldb) print a</div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">0</span> = <span class="number">0</span></div><div class="line">(lldb) print b</div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">1</span> = <span class="number">0</span></div><div class="line">(lldb) print str</div><div class="line">(<span class="built_in">NSString</span> *) $<span class="number">2</span> = <span class="number">0x0000000100001048</span> <span class="string">@"abc"</span></div><div class="line">(lldb) print url</div><div class="line">(<span class="built_in">NSURL</span> *) $<span class="number">3</span> = <span class="number">0x0000000100206cc0</span> <span class="string">@"abc"</span></div></pre></td></tr></table></figure>
<p>在输出结果中我们还能看到类似于$0,$1这样的符号，我们可以将其看作是指向对象的一个引用，我们在控制面板中可以直接使用这个符号来操作对应的对象，这些东西存在于<code>LLDB</code>的全名空间中，目的是为了辅助调试。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) exp $<span class="number">0</span> = <span class="number">100</span></div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">9</span> = <span class="number">100</span></div><div class="line">(lldb) p a</div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">10</span> = <span class="number">100</span></div></pre></td></tr></table></figure>
<p>另外$后面的数值是递增的，每打印一个与对象相关的命令，这个值都会加1。</p>
<p>上面的<code>print</code>命令会打印出对象的很多信息，如果我们只想查看对象的值的信息，则可以使用<code>po</code>(<code>print object</code>的缩写)命令，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) po str</div><div class="line">abc</div></pre></td></tr></table></figure>
<p>当然，<code>po</code>命令是<code>&quot;exp -O --&quot;</code>命令的别名，使用<code>&quot;exp -O --&quot;</code>能达到同样的效果。</p>
<p>对于简单类型，我们还可以为其指定不同的打印格式，其命令格式是<code>print/</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p/x a</div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">13</span> = <span class="number">0x0000000000000064</span></div></pre></td></tr></table></figure>
<p>格式的完整清单可以参考<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="external">Output Formats</a>。</p>
<h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p>在开发中，我们经常会遇到这样一种情况：我们设置一个视图的背景颜色，运行后发现颜色不好看。嗯，好吧，在代码里面修改一下，再编译运行一下，嗯，还是不好看，然后再修改吧～～这样无形中浪费了我们大把的时间。在这种情况下，<code>expression</code>命令强大的功能就能体现出来了，它不仅会改变调试器中的值，还改变了程序中的实际值。我们先来看看实际效果，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(lldb) exp a = <span class="number">10</span></div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">0</span> = <span class="number">10</span></div><div class="line">(lldb) exp b = <span class="number">100</span></div><div class="line">(<span class="built_in">NSInteger</span>) $<span class="number">1</span> = <span class="number">100</span></div><div class="line"><span class="number">2015</span><span class="number">-01</span><span class="number">-25</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">41.313</span> test[<span class="number">18064</span>:<span class="number">71466</span>] a + b = <span class="number">110</span>, abc</div></pre></td></tr></table></figure>
<p><code>expression</code>命令的功能不仅于此，正如上面的<code>po</code>命令，其实际也是<code>&quot;expression -O --&quot;</code>命令的别名。更详细使用可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">Evaluating Expressions</a>。</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p><code>image</code>命令的用法也挺多，首先可以用它来查看工程中使用的库，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(lldb) image list</div><div class="line">[  <span class="number">0</span>] <span class="number">432</span>A6EBF-B9D2<span class="number">-3850</span>-BCB2<span class="number">-821</span>B9E62B1E0 <span class="number">0x0000000100000000</span> /Users<span class="comment">/**/</span>Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test </div><div class="line">[  <span class="number">1</span>] <span class="number">65</span>DCCB06<span class="number">-339</span>C<span class="number">-3E25</span><span class="number">-9702</span><span class="number">-600</span>A28291D0E <span class="number">0x00007fff5fc00000</span> /usr/lib/dyld </div><div class="line">[  <span class="number">2</span>] E3746EDD-DFB1<span class="number">-3</span>ECB<span class="number">-88</span>ED-A91AC0EF3AAA <span class="number">0x00007fff8d324000</span> /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation </div><div class="line">[  <span class="number">3</span>] <span class="number">759E155</span>D-BC42<span class="number">-3</span>D4E<span class="number">-869</span>B<span class="number">-6</span>F57D477177C <span class="number">0x00007fff8869f000</span> /usr/lib/libobjc.A.dylib </div><div class="line">[  <span class="number">4</span>] <span class="number">5</span>C161F1A<span class="number">-93</span>BA<span class="number">-3221</span>-A31D-F86222005B1B <span class="number">0x00007fff8c75c000</span> /usr/lib/libSystem.B.dylib </div><div class="line">[  <span class="number">5</span>] CBD1591C<span class="number">-405E-376</span>E<span class="number">-87E9</span>-B264610EBF49 <span class="number">0x00007fff8df0d000</span> /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation </div><div class="line">[  <span class="number">6</span>] A260789B-D4D8<span class="number">-316</span>A<span class="number">-9490</span><span class="number">-254767</span>B8A5F1 <span class="number">0x00007fff8de36000</span> /usr/lib/libauto.dylib </div><div class="line">......</div></pre></td></tr></table></figure>
<p>我们还可以用它来查找可执行文件或共享库的原始地址，这一点还是很有用的，当我们的程序崩溃时，我们可以使用这条命令来查找崩溃所在的具体位置，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"item 3: %@"</span>, array[<span class="number">2</span>]);</div></pre></td></tr></table></figure>
<p>这段代码在运行后会抛出如下异常：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2015-01-25 14:12:01.007 test[18122:76474] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]'</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">	0   CoreFoundation                      0x00007fff8e06f66c __exceptionPreprocess + 172</div><div class="line">	1   libobjc.A.dylib                     0x00007fff886ad76e objc_exception_throw + 43</div><div class="line">	2   CoreFoundation                      0x00007fff8df487de -[__NSArrayI objectAtIndex:] + 190</div><div class="line">	3   test                                0x0000000100000de0 main + 384</div><div class="line">	4   libdyld.dylib                       0x00007fff8f1b65c9 start + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div></pre></td></tr></table></figure>
<p>根据以上信息，我们可以判断崩溃位置是在<code>main.m</code>文件中，要想知道具体在哪一行，可以使用以下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) image lookup --address <span class="number">0x0000000100000de0</span></div><div class="line">      Address: test[<span class="number">0x0000000100000de0</span>] (test.__TEXT.__text + <span class="number">384</span>)</div><div class="line">      Summary: test`main + <span class="number">384</span> at main.m:<span class="number">23</span></div></pre></td></tr></table></figure>
<p>可以看到，最后定位到了<code>main.m</code>文件的第<code>23</code>行，正是我们代码所在的位置。</p>
<p>我们还可以使用<code>image lookup</code>命令来查看具体的类型，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(lldb) image lookup --type NSURL</div><div class="line">Best match found in /Users/**/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test:</div><div class="line">id = &#123;0x100000157&#125;, name = "NSURL", byte-size = 40, decl = NSURL.h:17, clang_type = "@interface NSURL : NSObject&#123;</div><div class="line">    NSString * _urlString;</div><div class="line">    NSURL * _baseURL;</div><div class="line">    void * _clients;</div><div class="line">    void * _reserved;</div><div class="line">&#125;</div><div class="line">@property ( readonly,getter = absoluteString,setter = &lt;null selector&gt;,nonatomic ) NSString * absoluteString;</div><div class="line">@property ( readonly,getter = relativeString,setter = &lt;null selector&gt;,nonatomic ) NSString * relativeString;</div><div class="line">@property ( readonly,getter = baseURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * baseURL;</div><div class="line">@property ( readonly,getter = absoluteURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * absoluteURL;</div><div class="line">@property ( readonly,getter = scheme,setter = &lt;null selector&gt;,nonatomic ) NSString * scheme;</div><div class="line">@property ( readonly,getter = resourceSpecifier,setter = &lt;null selector&gt;,nonatomic ) NSString * resourceSpecifier;</div><div class="line">@property ( readonly,getter = host,setter = &lt;null selector&gt;,nonatomic ) NSString * host;</div><div class="line">@property ( readonly,getter = port,setter = &lt;null selector&gt;,nonatomic ) NSNumber * port;</div><div class="line">@property ( readonly,getter = user,setter = &lt;null selector&gt;,nonatomic ) NSString * user;</div><div class="line">@property ( readonly,getter = password,setter = &lt;null selector&gt;,nonatomic ) NSString * password;</div><div class="line">@property ( readonly,getter = path,setter = &lt;null selector&gt;,nonatomic ) NSString * path;</div><div class="line">@property ( readonly,getter = fragment,setter = &lt;null selector&gt;,nonatomic ) NSString * fragment;</div><div class="line">@property ( readonly,getter = parameterString,setter = &lt;null selector&gt;,nonatomic ) NSString * parameterString;</div><div class="line">@property ( readonly,getter = query,setter = &lt;null selector&gt;,nonatomic ) NSString * query;</div><div class="line">@property ( readonly,getter = relativePath,setter = &lt;null selector&gt;,nonatomic ) NSString * relativePath;</div><div class="line">@property ( readonly,getter = fileSystemRepresentation,setter = &lt;null selector&gt; ) const char * fileSystemRepresentation;</div><div class="line">@property ( readonly,getter = isFileURL,setter = &lt;null selector&gt;,readwrite ) BOOL fileURL;</div><div class="line">@property ( readonly,getter = standardizedURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * standardizedURL;</div><div class="line">@property ( readonly,getter = filePathURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * filePathURL;</div><div class="line">@end"</div></pre></td></tr></table></figure>
<p>可以看到，输出结果中列出了<code>NSURL</code>的一些成员变量及属性信息。</p>
<p><code>image</code>命令还有许多其它功能，具体可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">Executable and Shared Library Query Commands</a>。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>流程控制的命令实际上我们在上一小节已经讲过了，在<code>Xcode</code>的控制面板中同样可以使用这些命令，在此不在重复。</p>
<h2 id="命令别名及帮助系统"><a href="#命令别名及帮助系统" class="headerlink" title="命令别名及帮助系统"></a>命令别名及帮助系统</h2><p><code>LLDB</code>有两个非常有用的特性，即命令别名及帮助。</p>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>我们可以使用LLDB的别名机制来为常用的命令创建一个别名，以方便我们的使用，如下命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --file foo.c --line <span class="number">12</span></div></pre></td></tr></table></figure>
<p>如果在我们的调试中需要经常用到这条命令，则每次输入这么一长串的字符一定会很让人抓狂。此时，我们就可以为这条命令创建一个别名，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) command alias bfl breakpoint set -f %<span class="number">1</span> -l %<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这样，我们只需要按如下方式来使用它即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) bfl foo.c <span class="number">12</span></div></pre></td></tr></table></figure>
<p>是不是简单多了？</p>
<p>我们可以自由地创建<code>LLDB</code>命令的别名集合。<code>LLDB</code>在启动时会读取<code>~/.lldbinit</code>文件。这个文件中存储了command alias命令创建的别名。<code>LLDB</code>帮助系统会读取这个初始化文件并会列出这些别名，以让我们了解自己所设置的别名。我们可以使用<code>&quot;help -a&quot;</code>命令并在输出的后面来查看这边别名，其以下面这行开始：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">The following is a list of your current command abbreviations (see 'help command alias' for more info): ...</div></pre></td></tr></table></figure>
<p>如果我们不喜欢已有命令的别名，则可以使用以下命令来取消这个别名：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) command unalias b</div></pre></td></tr></table></figure>
<h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><p><code>LLDB</code>帮助系统让我们可以了解<code>LLDB</code>提供了哪些功能，并可以查看<code>LLDB</code>命令结构的详细信息。熟悉帮助系统可以让我们访问帮助系统中中命令文档。</p>
<p>我们可以简单地调用<code>help</code>命令来列出<code>LLDB</code>所有的顶层命令。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(lldb) help</div><div class="line">The following is a list of built-in, permanent debugger commands:</div><div class="line"> </div><div class="line">_regexp-attach    -- Attach to a process id if in decimal, otherwise treat the</div><div class="line">                     argument as a process name to attach to.</div><div class="line">_regexp-break     -- Set a breakpoint using a regular expression to specify the</div><div class="line">                     location, where &lt;linenum&gt; is in decimal and &lt;address&gt; is</div><div class="line">                     in hex.</div><div class="line">_regexp-bt        -- Show a backtrace.  An optional argument is accepted; if</div><div class="line">                     that argument is a number, it specifies the number of</div><div class="line">                     frames to display.  If that argument is 'all', full</div><div class="line">                     backtraces of all threads are displayed.</div><div class="line"> … and so forth …</div></pre></td></tr></table></figure>
<p>如果<code>help</code>后面跟着某个特定的命令，则会列出该命令相关的所有信息，我们以<code>breakpoint set</code>为例，输出信息如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) help breakpoint set</div><div class="line">     Sets a breakpoint or set of breakpoints <span class="keyword">in</span> the executable.</div><div class="line">     </div><div class="line">Syntax: breakpoint set &lt;cmd-options&gt;</div><div class="line"></div><div class="line">Command Options Usage:</div><div class="line">  breakpoint set [-Ho] -l &lt;linenum&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-<span class="keyword">id</span>&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;]</div><div class="line">  breakpoint set [-Ho] -a &lt;address-expression&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-<span class="keyword">id</span>&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;]</div><div class="line">  breakpoint set [-Ho] -n &lt;function-name&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-<span class="keyword">id</span>&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;] [-L &lt;language&gt;]</div><div class="line">  breakpoint set [-Ho] -F &lt;fullname&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-<span class="keyword">id</span>&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;]</div><div class="line">  </div><div class="line"> … and so forth …</div></pre></td></tr></table></figure>
<p>还有一种更直接的方式来查看<code>LLDB</code>有哪些功能，即使用<code>apropos</code>命令：它会根据关键字来搜索<code>LLDB</code>帮助文档，并为每个命令选取一个帮助字符串，我们以<code>apropos file</code>为例，其输出如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(lldb) apropos file</div><div class="line">The following commands may relate to 'file':</div><div class="line">…</div><div class="line">log enable                     -- Enable logging for a single log channel.</div><div class="line">memory read                    -- Read from the memory of the process being</div><div class="line">                                  debugged.</div><div class="line">memory write                   -- Write to the memory of the process being</div><div class="line">                                  debugged.</div><div class="line">platform process launch        -- Launch a new process on a remote platform.</div><div class="line">platform select                -- Create a platform if needed and select it as</div><div class="line">                                  the current platform.</div><div class="line">plugin load                    -- Import a dylib that implements an LLDB</div><div class="line">                                  plugin.</div><div class="line">process launch                 -- Launch the executable in the debugger.</div><div class="line">process load                   -- Load a shared library into the current</div><div class="line">                                  process.</div><div class="line">source                         -- A set of commands for accessing source file</div><div class="line">                                  information</div><div class="line">… and so forth …</div></pre></td></tr></table></figure>
<p>我们还可以使用<code>help</code>来了解一个命令别名的构成。如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) help b</div><div class="line">…</div><div class="line">'b' is an abbreviation for '_regexp-break'</div></pre></td></tr></table></figure>
<p><code>help</code>命令的另一个特性是可以查看某个具体参数的使用，我们以<code>&quot;break command add&quot;</code>命令为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(lldb) help break command add</div><div class="line">Add a set of commands to a breakpoint, to be executed whenever the breakpoint is hit.</div><div class="line"> </div><div class="line">Syntax: breakpoint command add &lt;cmd-options&gt; &lt;breakpt-id&gt;</div><div class="line">etc...</div></pre></td></tr></table></figure>
<p>如果想了解以上输出的参数<code>&lt;breakpt-id&gt;</code>的作用，我们可以在<code>help</code>后面直接指定这个参数(将其放在尖括号内)来查询它的详细信息，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) help &lt;breakpt-<span class="keyword">id</span>&gt;</div><div class="line"> </div><div class="line">&lt;breakpt-<span class="keyword">id</span>&gt; -- Breakpoint IDs consist major and minor numbers; the major</div><div class="line">etc...</div></pre></td></tr></table></figure>
<p>帮助系统能让我们快速地了解一个<code>LLDB</code>命令的使用方法。经常使用它，可以让我们更快地熟悉<code>LLDB</code>的各项功能，所以建议多使用它。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LLDB</code>带给我们强大的调试功能，在调试过程中充分地利用它可以帮助我们极大地提高调试效率。我们可以不用写那么多的<code>NSLog</code>来打印一大堆的日志。所以建议在日常工作中多去使用它。当然，上面的命令只是<code>LLDB</code>的冰山一角，更多的使用还需要大家自己去发掘，在此只是抛砖引玉，做了一些整理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="external">The LLDB Debugger</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html" target="_blank" rel="external">LLDB Quick Start Guide</a></li>
<li><a href="http://www.cocoachina.com/ios/20141219/10709.html" target="_blank" rel="external">与调试器共舞 - LLDB 的华尔兹</a></li>
<li><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/" target="_blank" rel="external">LLDB调试命令初探</a></li>
<li><a href="http://www.cocoachina.com/ios/20140530/8619.html" target="_blank" rel="external">NSLog效率低下的原因及尝试lldb断点打印Log</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/11/sourcecode-mantle/" itemprop="url">
                  Mantle实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-11T22:01:00+08:00" content="2015-01-11">
              2015-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Mantle</code>是一个用于简化<code>Cocoa</code>或<code>Cocoa Touch</code>程序中<code>model</code>层的第三方库。通常我们的应该中都会定义大量的<code>model</code>来表示各种数据结构，而这些<code>model</code>的初始化和编码解码都需要写大量的代码。而<code>Mantle</code>的优点在于能够大大地简化这些代码。</p>
<p><code>Mantle</code>源码中最主要的内容包括：</p>
<ol>
<li><code>MTLModel</code>类：通常是作为我们的<code>Model</code>的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li><code>MTLJSONAdapter</code>类：用于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，相当于是一个适配器。</li>
<li><code>MTLJSONSerializing</code>协议：需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。</li>
</ol>
<p>在此就以这三者作为我们的分析点。</p>
<h2 id="基类MTLModel"><a href="#基类MTLModel" class="headerlink" title="基类MTLModel"></a>基类MTLModel</h2><p><code>MTLModel</code>是一个抽象类，它主要提供了一些默认的行为来处理对象的初始化和归档操作。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>MTLModel</code>默认的初始化方法<code>-init</code>并没有做什么事情，只是调用了下<code>[super init]</code>。而同时，它提供了一个另一个初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionaryValue error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<p>其中参数<code>dictionaryValue</code>是一个字典，它包含了用于初始化对象的<code>key-value</code>对。我们来看下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">	...</div><div class="line">    </div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> dictionary) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 1. 将value标记为__autoreleasing，这是因为在MTLValidateAndSetValue函数中，</span></div><div class="line">		<span class="comment">//	  可以会返回一个新的对象存在在该变量中</span></div><div class="line">		__autoreleasing <span class="keyword">id</span> value = [dictionary objectForKey:key];</div><div class="line">		</div><div class="line">		<span class="comment">// 2. value如果为NSNull.null，会在使用前将其转换为nil</span></div><div class="line">		<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">		<span class="comment">// 3. MTLValidateAndSetValue函数利用KVC机制来验证value的值对于key是否有效，</span></div><div class="line">		<span class="comment">//	  如果无效，则使用使用默认值来设置key的值。</span></div><div class="line">		<span class="comment">//	  这里同样使用了对象的KVC特性来将value值赋值给model对应于key的属性。</span></div><div class="line">		<span class="comment">//	  有关MTLValidateAndSetValue的实现可参考源码，在此不做详细说明。</span></div><div class="line">		<span class="built_in">BOOL</span> success = <span class="built_in">MTLValidateAndSetValue</span>(<span class="keyword">self</span>, key, value, <span class="literal">YES</span>, error);</div><div class="line">		<span class="keyword">if</span> (!success) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类可以重写该方法，以在设置完对象的属性后做进一步的处理或初始化工作，不过需要记住的是：应该通过<code>super</code>来调用父类的实现。</p>
<h3 id="获取属性的键-key-、值-value"><a href="#获取属性的键-key-、值-value" class="headerlink" title="获取属性的键(key)、值(value)"></a>获取属性的键(key)、值(value)</h3><p><code>MTLModel</code>类提供了一个类方法<code>+propertyKeys</code>，该方法返回所有<code>@property</code>声明的属性所对应的名称字符串的一个集合，但不包括只读属性和<code>MTLModel</code>自身的属性。在这个类方法会去遍历<code>model</code>的所有属性，如果属性是非只读且其<code>ivar</code>值不为<code>NULL</code>，则获取到表示属性名的字符串，并将其放入到集合中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)propertyKeys &#123;</div><div class="line">	<span class="comment">// 1. 如果对象中已有缓存的属性名的集合，则直接返回缓存。该缓存是放在一个关联对象中。</span></div><div class="line">    <span class="built_in">NSSet</span> *cachedKeys = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">MTLModelCachedPropertyKeysKey</span>);</div><div class="line">    <span class="keyword">if</span> (cachedKeys != <span class="literal">nil</span>) <span class="keyword">return</span> cachedKeys;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableSet</span> *keys = [<span class="built_in">NSMutableSet</span> set];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 遍历对象所有的属性</span></div><div class="line">    <span class="comment">//	  enumeratePropertiesUsingBlock方法会沿着superclass链一直向上遍历到MTLModel，</span></div><div class="line">    <span class="comment">//	  查找当前model所对应类的继承体系中所有的属性(不包括MTLModel)，并对该属性执行block中的操作。</span></div><div class="line">    <span class="comment">//	  有关enumeratePropertiesUsingBlock的实现可参考源码，在此不做详细说明。</span></div><div class="line">    [<span class="keyword">self</span> enumeratePropertiesUsingBlock:^(objc_property_t property, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);</div><div class="line">        @onExit &#123;</div><div class="line">            free(attributes);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 过滤只读属性和ivar为NULL的属性</span></div><div class="line">        <span class="keyword">if</span> (attributes-&gt;<span class="keyword">readonly</span> &amp;&amp; attributes-&gt;ivar == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 4. 获取属性名字符串，并存储到集合中</span></div><div class="line">        <span class="built_in">NSString</span> *key = @(property_getName(property));</div><div class="line">        [keys addObject:key];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// 5. 将集合缓存到关联对象中。</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">MTLModelCachedPropertyKeysKey</span>, keys, OBJC_ASSOCIATION_COPY);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> keys;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面这个类方法，要想获取到对象中所有属性及其对应的值就方法了。为此<code>MTLModel</code>提供了一个只读属性<code>dictionaryValue</code>来取一个包含当前<code>model</code>所有属性及其值的字典。如果属性值为<code>nil</code>，则会用<code>NSNull</code>来代替。另外该属性不会为<code>nil</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span> *dictionaryValue;</div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line">- (<span class="built_in">NSDictionary</span> *)dictionaryValue &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dictionaryWithValuesForKeys:<span class="keyword">self</span>.class.propertyKeys.allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><p>合并对象是指将两个<code>MTLModel</code>对象按照自定义的方法将其对应的属性值进行合并。为此，在<code>MTLModel</code>定义了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValueForKey:(<span class="built_in">NSString</span> *)key fromModel:(<span class="built_in">MTLModel</span> *)model;</div></pre></td></tr></table></figure>
<p>该方法将当前对象指定的<code>key</code>属性的值与<code>model</code>参数对应的属性值按照指定的规则来进行合并，这种规则由我们自定义的<code>-merge&lt;Key&gt;FromModel:</code>方法来确定。如果我们的子类中实现了<code>-merge&lt;Key&gt;FromModel:</code>方法，则会调用它；如果没有找到，且<code>model</code>不为<code>nil</code>，则会用<code>model</code>的属性的值来替代当前对象的属性的值。具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValueForKey:(<span class="built_in">NSString</span> *)key fromModel:(<span class="built_in">MTLModel</span> *)model &#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(key != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 1. 根据传入的key拼接"merge&lt;Key&gt;FromModel:"字符串，并从该字符串中获取到对应的selector</span></div><div class="line">    <span class="comment">//	  如果当前对象没有实现-merge&lt;Key&gt;FromModel:方法，且model不为nil，则用model的属性值</span></div><div class="line">    <span class="comment">//	  替代当前对象的属性值</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// 	  MTLSelectorWithCapitalizedKeyPattern函数以C语言的方式来拼接方法字符串，具体实现请</span></div><div class="line">    <span class="comment">//	  参数源码，在此不详细说明</span></div><div class="line">    SEL selector = <span class="built_in">MTLSelectorWithCapitalizedKeyPattern</span>(<span class="string">"merge"</span>, key, <span class="string">"FromModel:"</span>);</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector]) &#123;</div><div class="line">        <span class="keyword">if</span> (model != <span class="literal">nil</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> setValue:[model valueForKey:key] forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 2. 通过NSInvocation方式来调用对应的-merge&lt;Key&gt;FromModel:方法。</span></div><div class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</div><div class="line">    invocation.target = <span class="keyword">self</span>;</div><div class="line">    invocation.selector = selector;</div><div class="line"></div><div class="line">    [invocation setArgument:&amp;model atIndex:<span class="number">2</span>];</div><div class="line">    [invocation invoke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，<code>MTLModel</code>还提供了另一个方法来合并两个对象所有的属性值，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValuesForKeysFromModel:(<span class="built_in">MTLModel</span> *)model;</div></pre></td></tr></table></figure>
<p>需要注意的是<code>model</code>必须是当前对象所属类或其子类。</p>
<h3 id="归档对象-Archive"><a href="#归档对象-Archive" class="headerlink" title="归档对象(Archive)"></a>归档对象(Archive)</h3><p><code>Mantle</code>将对<code>MTLModel</code>的编码解码处理都放在了<code>MTLModel</code>的<code>NSCoding</code>分类中进行处理了，该分类及相关的定义都放在<code>MTLModel+NSCoding</code>文件中。</p>
<p>对于不同的属性，在编码解码过程中可能需要区别对待，为此<code>Mentle</code>定义了枚举<code>MTLModelEncodingBehavior</code>来确定一个<code>MTLModel</code>属性被编码到一个归档中的行为。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorExcluded</span> = <span class="number">0</span>,			<span class="comment">// 属性绝不应该被编码</span></div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorUnconditional</span>,			<span class="comment">// 属性总是应该被编码</span></div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorConditional</span>,			<span class="comment">// 对象只有在其它地方被无条件编码时才应该被编码。这只适用于对象属性</span></div><div class="line">&#125; <span class="built_in">MTLModelEncodingBehavior</span>;</div></pre></td></tr></table></figure>
<p>具体每个属性的归档行为我们可以在<code>+encodingBehaviorsByPropertyKey</code>类方法中设置。<code>MTLModel</code>类为我们提供了一个默认实现，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)encodingBehaviorsByPropertyKey &#123;</div><div class="line">	<span class="comment">// 1. 获取所有属性键值</span></div><div class="line">    <span class="built_in">NSSet</span> *propertyKeys = <span class="keyword">self</span>.propertyKeys;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *behaviors = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:propertyKeys.count];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 对每一个属性进行处理</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> propertyKeys) &#123;</div><div class="line">        objc_property_t property = class_getProperty(<span class="keyword">self</span>, key.UTF8String);</div><div class="line">        <span class="built_in">NSAssert</span>(property != <span class="literal">NULL</span>, <span class="string">@"Could not find property \"%@\" on %@"</span>, key, <span class="keyword">self</span>);</div><div class="line"></div><div class="line">        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);</div><div class="line">        @onExit &#123;</div><div class="line">            free(attributes);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 当属性为weak时，默认设置为MTLModelEncodingBehaviorConditional，否则默认为MTLModelEncodingBehaviorUnconditional，设置完后，将其封装在NSNumber中并放入字典中。</span></div><div class="line">        <span class="built_in">MTLModelEncodingBehavior</span> behavior = (attributes-&gt;<span class="keyword">weak</span> ? <span class="built_in">MTLModelEncodingBehaviorConditional</span> : <span class="built_in">MTLModelEncodingBehaviorUnconditional</span>);</div><div class="line">        behaviors[key] = @(behavior);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> behaviors;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何不在该返回字典中的属性都不会被归档。子类可以根据自己的需要来指定各属性的归档行为。但在实际时应该通过super来调用父类的实现。</p>
<p>而为了从归档中解码指定的属性，<code>Mantle</code>提供了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)decodeValueForKey:(<span class="built_in">NSString</span> *)key withCoder:(<span class="built_in">NSCoder</span> *)coder modelVersion:(<span class="built_in">NSUInteger</span>)modelVersion;</div></pre></td></tr></table></figure>
<p>默认情况下，该方法会查找当前对象中类似于<strong><code>-decode&lt;Key&gt;WithCoder:modelVersion:</code></strong>的方法，如果找到便会调用相应方法，并按照自定义的方式来处理属性的解码。如果我们没有实现自定义的方法或者<code>coder</code>不需要安全编码，则会对指定的key调用<code>-[NSCoder decodeObjectForKey:]</code>方法。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)decodeValueForKey:(<span class="built_in">NSString</span> *)key withCoder:(<span class="built_in">NSCoder</span> *)coder modelVersion:(<span class="built_in">NSUInteger</span>)modelVersion &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    SEL selector = <span class="built_in">MTLSelectorWithCapitalizedKeyPattern</span>(<span class="string">"decode"</span>, key, <span class="string">"WithCoder:modelVersion:"</span>);</div><div class="line">    <span class="comment">// 1. 如果自定义了-decode&lt;Key&gt;WithCoder:modelVersion:方法，则通过NSInvocation来调用方法</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:selector]) &#123;</div><div class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</div><div class="line">        invocation.target = <span class="keyword">self</span>;</div><div class="line">        invocation.selector = selector;</div><div class="line">        [invocation setArgument:&amp;coder atIndex:<span class="number">2</span>];</div><div class="line">        [invocation setArgument:&amp;modelVersion atIndex:<span class="number">3</span>];</div><div class="line">        [invocation invoke];</div><div class="line"></div><div class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> result = <span class="literal">nil</span>;</div><div class="line">        [invocation getReturnValue:&amp;result];</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">    	<span class="comment">// 2. 如果没有找到自定义的-decode&lt;Key&gt;WithCoder:modelVersion:方法，</span></div><div class="line">    	<span class="comment">// 	  则走以下流程。</span></div><div class="line">    	<span class="comment">//</span></div><div class="line">    	<span class="comment">// coderRequiresSecureCoding方法的具体实现请参数源码</span></div><div class="line">        <span class="keyword">if</span> (coderRequiresSecureCoding(coder)) &#123;</div><div class="line">        	<span class="comment">// 3. 如果coder要求安全编码，则会从需要安全编码的字典中取出属性所对象的类型，然后根据指定</span></div><div class="line">        	<span class="comment">//	  类型来对属性进行解码操作。</span></div><div class="line">        	<span class="comment">//	  为此，MTLModel提供了类方法allowedSecureCodingClassesByPropertyKey，来获取</span></div><div class="line">        	<span class="comment">//	  类的对象包含的所有需要安全编码的属性及其对应的类的字典。该方法首先会查看是否已有</span></div><div class="line">        	<span class="comment">//	  缓存的字典，如果没有则遍历类的所有属性。首先过滤掉那些不需要编码的属性，</span></div><div class="line">        	<span class="comment">//	  然后遍历剩下的属性，如果是非对象类型或类类型，则其对应的类型设定为NSValue，</span></div><div class="line">        	<span class="comment">//	  如果是这两者，则对应的类型即为相应类型。</span></div><div class="line">        	<span class="comment">//	  该方法的具体实现请参考源代码。</span></div><div class="line">            <span class="built_in">NSArray</span> *allowedClasses = <span class="keyword">self</span>.class.allowedSecureCodingClassesByPropertyKey[key];</div><div class="line">            <span class="built_in">NSAssert</span>(allowedClasses != <span class="literal">nil</span>, <span class="string">@"No allowed classes specified for securely decoding key \"%@\" on %@"</span>, key, <span class="keyword">self</span>.class);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> [coder decodeObjectOfClasses:[<span class="built_in">NSSet</span> setWithArray:allowedClasses] forKey:key];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        	<span class="comment">// 4. 不需要安全编码</span></div><div class="line">            <span class="keyword">return</span> [coder decodeObjectForKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，所有的编码解码工作还得需要我们实现<code>-initWithCoder:</code>和<code>-encodeWithCoder:</code>两个方法来完成。我们在定义<code>MTLModel</code>的子类时，可以根据自己的需要来对特定的属性进行处理，不过最好调用<code>super</code>的实现来执行父类的操作。<code>MTLModel</code>对这两个方法的实现请参考源码，在此不多作说明。</p>
<h2 id="适配器MTLJSONApadter"><a href="#适配器MTLJSONApadter" class="headerlink" title="适配器MTLJSONApadter"></a>适配器MTLJSONApadter</h2><p>为了便于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，<code>Mantle</code>提供了类<code>MTLJSONApadter</code>，作为这两者之间的一个适配器。</p>
<h3 id="MTLJSONSerializing协议"><a href="#MTLJSONSerializing协议" class="headerlink" title="MTLJSONSerializing协议"></a>MTLJSONSerializing协议</h3><p><code>Mantle</code>定义了一个协议<code>MTLJSONSerializing</code>，那些需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。这个协议中定义了三个方法，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MTLJSONSerializing</span></span></div><div class="line"><span class="keyword">@required</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">  </div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)JSONTransformerForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">+ (Class)classForParsingJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这三个方法都是类方法。其中<code>+JSONKeyPathsByPropertyKey</code>是必须实现的，它返回的字典指定了如何将对象的属性映射到<code>JSON</code>中不同的<code>key path</code>(字符串值或<code>NSNull</code>)中。任何不在此字典中的属性被认为是与<code>JSON</code>中使用的<code>key</code>值相匹配。而映射到<code>NSNull</code>的属性在<code>JSON</code>序列化过程中将不进行处理。</p>
<p><code>+JSONTransformerForKey:</code>方法指定了如何将一个<code>JSON</code>值转换为指定的属性值。反过来，转换器也用于将属性值转换成<code>JSON</code>值。如果转换器实现了<code>+&lt;key&gt;JSONTransformer</code>方法，则<code>MTLJSONAdapter</code>会使用这个具体的方法，而不使用<code>+JSONTransformerForKey:</code>方法。另外，如果不需要执行自定义的转换，则返回nil。</p>
<p>重写<code>+classForParsingJSONDictionary:</code>方法可以将当前<code>Model</code>解析为一个不同的类对象。这对象类簇是非常有用的，其中抽象基类将被传递给<code>-[MTLJSONAdapter initWithJSONDictionary:modelClass:]</code>方法，而实例化的则是子类。</p>
<p>如果我们希望<code>MTLModel</code>的一个子类能使用<code>MTLJSONApadter</code>来进行转换，则需要实现这个协议，并实现相应的方法。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p><code>MTLJSONApadter</code>对象有一个只读属性，该属性即为适配器需要处理的<code>MTLModel</code>对象，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *model;</div></pre></td></tr></table></figure>
<p>可见该对象必须是实现了<code>MTLJSONSerializing</code>协议的<code>MTLModel</code>对象。该属性是只读的，因此它只能通过初始化方法来初始化。</p>
<p><code>MTLJSONApadter</code>对象不能通过<code>-init</code>来初始化，这个方法会直接断言。而是需要通过类提供的两个初始化方法来初始化，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary modelClass:(Class)modelClass error:(<span class="built_in">NSError</span> **)error;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithModel:(<span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *)model;</div></pre></td></tr></table></figure>
<p>其中<code>-(id)initWithJSONDictionary:modelClass:error:</code>是使用一个字典和需要转换的类来进行初始化。字典<code>JSONDictionary</code>表示一个<code>JSON</code>数据，这个字典需要符合<code>NSJSONSerialization</code>返回的格式。如果该参数为空，则方法返回<code>nil</code>，且返回带有<code>MTLJSONAdapterErrorInvalidJSONDictionary</code>码的<code>error</code>对象。该方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary modelClass:(Class)modelClass error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (JSONDictionary == <span class="literal">nil</span> || ![JSONDictionary isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</div><div class="line">		...</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="keyword">if</span> ([modelClass respondsToSelector:<span class="keyword">@selector</span>(classForParsingJSONDictionary:)]) &#123;</div><div class="line">		modelClass = [modelClass classForParsingJSONDictionary:JSONDictionary];</div><div class="line">		<span class="keyword">if</span> (modelClass == <span class="literal">nil</span>) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">	_modelClass = modelClass;</div><div class="line">	_JSONKeyPathsByPropertyKey = [[modelClass JSONKeyPathsByPropertyKey] <span class="keyword">copy</span>];</div><div class="line">    </div><div class="line">	<span class="built_in">NSMutableDictionary</span> *dictionaryValue = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:JSONDictionary.count];</div><div class="line">    </div><div class="line">	<span class="built_in">NSSet</span> *propertyKeys = [<span class="keyword">self</span>.modelClass propertyKeys];</div><div class="line">    </div><div class="line">	<span class="comment">// 1. 检验model的+JSONKeyPathsByPropertyKey中字典key-value对的有效性</span></div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *mappedPropertyKey <span class="keyword">in</span> <span class="keyword">self</span>.JSONKeyPathsByPropertyKey) &#123;</div><div class="line">		<span class="comment">// 2. 如果model对象的属性不包含+JSONKeyPathsByPropertyKey返回的字典中的某个属性键值</span></div><div class="line">		<span class="comment">//	  则返回nil。即+JSONKeyPathsByPropertyKey中指定的属性键值必须是model对象所包含</span></div><div class="line">		<span class="comment">// 	  的属性。</span></div><div class="line">		<span class="keyword">if</span> (![propertyKeys containsObject:mappedPropertyKey]) &#123;</div><div class="line">			...</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="keyword">id</span> value = <span class="keyword">self</span>.JSONKeyPathsByPropertyKey[mappedPropertyKey];</div><div class="line">        </div><div class="line">		<span class="comment">// 3. 如果属性不是映射到一个JSON关键路径或者是NSNull，也返回nil。</span></div><div class="line">		<span class="keyword">if</span> (![value isKindOfClass:<span class="built_in">NSString</span>.class] &amp;&amp; value != <span class="built_in">NSNull</span>.null) &#123;</div><div class="line">			...</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *propertyKey <span class="keyword">in</span> propertyKeys) &#123;</div><div class="line">		<span class="built_in">NSString</span> *JSONKeyPath = [<span class="keyword">self</span> JSONKeyPathForPropertyKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> (JSONKeyPath == <span class="literal">nil</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">		<span class="keyword">id</span> value;</div><div class="line">		<span class="keyword">@try</span> &#123;</div><div class="line">			value = [JSONDictionary valueForKeyPath:JSONKeyPath];</div><div class="line">		&#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *ex) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="keyword">if</span> (value == <span class="literal">nil</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">		<span class="keyword">@try</span> &#123;</div><div class="line">			<span class="comment">// 4. 获取一个转换器，</span></div><div class="line">			<span class="comment">//	  如上所述，+JSONTransformerForKey:会先去查看是否有+&lt;key&gt;JSONTransformer方法，</span></div><div class="line">			<span class="comment">//    如果有则会使用这个具体的方法，如果没有，则调用相应的+JSONTransformerForKey:方法</span></div><div class="line">			<span class="comment">//	  该方法具体实现请参考源码</span></div><div class="line">			<span class="built_in">NSValueTransformer</span> *transformer = [<span class="keyword">self</span> JSONTransformerForKey:propertyKey];</div><div class="line">			<span class="keyword">if</span> (transformer != <span class="literal">nil</span>) &#123;</div><div class="line">				</div><div class="line">				<span class="comment">// 5. 获取转换器转换生的值</span></div><div class="line">				<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">				value = [transformer transformedValue:value] ?: <span class="built_in">NSNull</span>.null;</div><div class="line">			&#125;</div><div class="line">            </div><div class="line">			dictionaryValue[propertyKey] = value;</div><div class="line">		&#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *ex) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="comment">// 6. 初始化_model</span></div><div class="line">	_model = [<span class="keyword">self</span>.modelClass modelWithDictionary:dictionaryValue error:error];</div><div class="line">	<span class="keyword">if</span> (_model == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，<code>MTLJSONApadter</code>还提供了几个类方法来创建一个<code>MTLJSONApadter</code>对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error;</div><div class="line"></div><div class="line">+ (NSArray *)modelsOfClass:(Class)modelClass fromJSONArray:(NSArray *)JSONArray error:(NSError **)error;</div><div class="line"></div><div class="line">+ (NSDictionary *)JSONDictionaryFromModel:(MTLModel&lt;MTLJSONSerializing&gt; *)model;</div></pre></td></tr></table></figure>
<p>具体实现可参考源码。</p>
<h3 id="从对象中获取JSON数据"><a href="#从对象中获取JSON数据" class="headerlink" title="从对象中获取JSON数据"></a>从对象中获取JSON数据</h3><p>从<code>MTLModel</code>对象中获取<code>JSON</code>数据是上述初始化过程中的一个逆过程。该过程由<code>-JSONDictionary</code>方法来实现，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSDictionary</span> *)JSONDictionary &#123;</div><div class="line">	<span class="built_in">NSDictionary</span> *dictionaryValue = <span class="keyword">self</span>.model.dictionaryValue;</div><div class="line">	<span class="built_in">NSMutableDictionary</span> *JSONDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:dictionaryValue.count];</div><div class="line">    </div><div class="line">	[dictionaryValue enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyKey, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">		<span class="built_in">NSString</span> *JSONKeyPath = [<span class="keyword">self</span> JSONKeyPathForPropertyKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> (JSONKeyPath == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">		<span class="comment">// 1. 获取属性的值</span></div><div class="line">		<span class="built_in">NSValueTransformer</span> *transformer = [<span class="keyword">self</span> JSONTransformerForKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> ([transformer.class allowsReverseTransformation]) &#123;</div><div class="line">			<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">			value = [transformer reverseTransformedValue:value] ?: <span class="built_in">NSNull</span>.null;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="built_in">NSArray</span> *keyPathComponents = [JSONKeyPath componentsSeparatedByString:<span class="string">@"."</span>];</div><div class="line">        </div><div class="line">		<span class="comment">// 2. 对于嵌套属性值的设置，会先从keypath中获取每一层属性，</span></div><div class="line">		<span class="comment">//	  如果当前层级的obj中没有该属性，则为其设置一个空字典；然后再进入下一层级，依此类推</span></div><div class="line">		<span class="comment">//	  最后设置如下形式的字典: @&#123;@"nested": @&#123;@"name": @"foo"&#125;&#125;</span></div><div class="line">		<span class="keyword">id</span> obj = JSONDictionary;</div><div class="line">		<span class="keyword">for</span> (<span class="built_in">NSString</span> *component <span class="keyword">in</span> keyPathComponents) &#123;</div><div class="line">			<span class="keyword">if</span> ([obj valueForKey:component] == <span class="literal">nil</span>) &#123;</div><div class="line">				[obj setValue:[<span class="built_in">NSMutableDictionary</span> dictionary] forKey:component];</div><div class="line">			&#125;</div><div class="line">            </div><div class="line">			obj = [obj valueForKey:component];</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		[JSONDictionary setValue:value forKeyPath:JSONKeyPath];</div><div class="line">	&#125;];</div><div class="line">    </div><div class="line">	<span class="keyword">return</span> JSONDictionary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上可以看出，该方法实际上最终获得的是一个字典。而获得字典后，再将其序列化为<code>JSON</code>串就容易了。</p>
<p><code>MTLJSONApadter</code>也提供了一个简便的方法，来从一个<code>model</code>中获取一个<code>JSON</code>字典，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONDictionaryFromModel:(<span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *)model;</div></pre></td></tr></table></figure>
<h3 id="MTLManagedObjectAdapter"><a href="#MTLManagedObjectAdapter" class="headerlink" title="MTLManagedObjectAdapter"></a>MTLManagedObjectAdapter</h3><p>为了适应<code>Core Data</code>，<code>Mantle</code>专门定义了<code>MTLManagedObjectAdapter</code>类。该类用作<code>MTLModel</code>对象与<code>NSManagedObject</code>对象之前的转换。具体的我们在此不详细描述。</p>
<h2 id="技术点总结"><a href="#技术点总结" class="headerlink" title="技术点总结"></a>技术点总结</h2><p><code>Mantle</code>的功能主要是进行对象间数据的转换：即如何在一个<code>MTLModel</code>和一个<code>JSON</code>字典中进行数据的转换。因此，所使用的技术大都是<code>Cocoa Foundation</code>提供的功能。除了对于<code>Core Data</code>的处理之外，主要用到的技术的有如下几条：</p>
<ol>
<li><code>KVC</code>的应用：这主要体现在对<code>MTLModel</code>子类的属性赋值中，通过<code>KVC</code>机制来验证值的有效性并为属性赋值。</li>
<li><code>NSValueTransform</code>：这主要用于对<code>JSON</code>值转换为属性值的处理，我们可以自定义转换器来满足我们自己的转换需求。</li>
<li><code>NSInvocation</code>：这主要用于统一处理针对特定<code>key</code>值的一些方法的调用。比如<code>-merge&lt;Key&gt;FromModel:</code>这一类方法。</li>
<li><code>Run time</code>函数的使用：这主要用于对从一个字符串中获取到方法对应的字符串，然后通过<code>sel_registerName</code>函数来注册一个<code>selector</code>。</li>
</ol>
<p>当然在<code>Mantle</code>中还会涉及到其它的一些技术点，在此不多做叙述。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle工程</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/11/tool-mantle/" itemprop="url">
                  工具篇：Mantle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-11T21:55:03+08:00" content="2015-01-11">
              2015-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">https://github.com/Mantle/Mantle</a></p>
<p>版本：1.5.3</p>
<blockquote>
<p>Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application.</p>
</blockquote>
<p>由上面这句话可知，<code>Mantle</code>的目的是让我们能简化<code>Cocoa</code>和<code>Cocoa Touch</code>应用的<code>model</code>层。那先来看看通常我们是怎么处理<code>model</code>层的吧。</p>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在我们写代码时，总要面对不同的数据来源。这些数据可能是来自网络服务器、本地数据库或者是内存中。通常我们需要将这些数据存储到一个<code>Model</code>中。一般情况下，我们会怎么去定义一个<code>Model</code>呢？以<code>Mantle</code>官方的例子为例，可能是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    GHIssueStateOpen,</div><div class="line">    GHIssueStateClosed</div><div class="line">&#125; GHIssueState;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GHIssue</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *URL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *HTMLURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSNumber</span> *number;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) GHIssueState state;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *reporterLogin;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *updatedAt;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) GHUser *assignee;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *retrievedAt;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *body;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>假定我们从网络服务器上获取了一组<code>GHIssue</code>对应的<code>JSON</code>数据，并已经将其转换为字典后，我们便可以用这个字典对<code>GHIssue</code>对象进行初始化了，<code>-initWithDictionary:</code>的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _URL = [<span class="built_in">NSURL</span> URLWithString:dictionary[<span class="string">@"url"</span>]];</div><div class="line">    _HTMLURL = [<span class="built_in">NSURL</span> URLWithString:dictionary[<span class="string">@"html_url"</span>]];</div><div class="line">    _number = dictionary[<span class="string">@"number"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([dictionary[<span class="string">@"state"</span>] isEqualToString:<span class="string">@"open"</span>]) &#123;</div><div class="line">        _state = GHIssueStateOpen;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([dictionary[<span class="string">@"state"</span>] isEqualToString:<span class="string">@"closed"</span>]) &#123;</div><div class="line">        _state = GHIssueStateClosed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _title = [dictionary[<span class="string">@"title"</span>] <span class="keyword">copy</span>];</div><div class="line">    _retrievedAt = [<span class="built_in">NSDate</span> date];</div><div class="line">    _body = [dictionary[<span class="string">@"body"</span>] <span class="keyword">copy</span>];</div><div class="line">    _reporterLogin = [dictionary[<span class="string">@"user"</span>][<span class="string">@"login"</span>] <span class="keyword">copy</span>];</div><div class="line">    _assignee = [[GHUser alloc] initWithDictionary:dictionary[<span class="string">@"assignee"</span>]];</div><div class="line">    </div><div class="line">    _updatedAt = [<span class="keyword">self</span>.class.dateFormatter dateFromString:dictionary[<span class="string">@"updated_at"</span>]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>GHIssue</code>对象有归档需求，则还需要实现以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _URL = [coder decodeObjectForKey:<span class="string">@"URL"</span>];</div><div class="line">    _HTMLURL = [coder decodeObjectForKey:<span class="string">@"HTMLURL"</span>];</div><div class="line">    _number = [coder decodeObjectForKey:<span class="string">@"number"</span>];</div><div class="line">    _state = [coder decodeUnsignedIntegerForKey:<span class="string">@"state"</span>];</div><div class="line">    _title = [coder decodeObjectForKey:<span class="string">@"title"</span>];</div><div class="line">    _retrievedAt = [<span class="built_in">NSDate</span> date];</div><div class="line">    _body = [coder decodeObjectForKey:<span class="string">@"body"</span>];</div><div class="line">    _reporterLogin = [coder decodeObjectForKey:<span class="string">@"reporterLogin"</span>];</div><div class="line">    _assignee = [coder decodeObjectForKey:<span class="string">@"assignee"</span>];</div><div class="line">    _updatedAt = [coder decodeObjectForKey:<span class="string">@"updatedAt"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.URL != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.URL forKey:<span class="string">@"URL"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.HTMLURL != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.HTMLURL forKey:<span class="string">@"HTMLURL"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.number != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.number forKey:<span class="string">@"number"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.title != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.title forKey:<span class="string">@"title"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.body != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.body forKey:<span class="string">@"body"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.reporterLogin != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.reporterLogin forKey:<span class="string">@"reporterLogin"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assignee != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.assignee forKey:<span class="string">@"assignee"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updatedAt != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.updatedAt forKey:<span class="string">@"updatedAt"</span>];</div><div class="line">    </div><div class="line">    [coder encodeUnsignedInteger:<span class="keyword">self</span>.state forKey:<span class="string">@"state"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>额，好多代码。嗯，说实话，以前也经常写这种代码，真可谓又臭又长啊。也许我的工程中还有很多这样的Model，然后，然后……靠，好烦啊。再然后，某天，服务端的同事告诉我有N个接口需要加字段，额～～崩溃中。而且，从上面的<code>Model</code>中，我无法将其还原为对应的<code>JSON</code>串，且如果某些信息变了，那么归档的数据可能就无法使用了。</p>
<p><code>Mantle</code>就是针对这几个问题而开发的一个开源库。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>其实<code>Mantle</code>的使用还是很简单的，它最主要的就是二个类和一个协议，即：</p>
<ol>
<li><code>MTLModel</code>类：通常是作为我们的<code>Model</code>的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li><code>MTLJSONAdapter</code>类：用于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，相当于是一个适配器。</li>
<li><code>MTLJSONSerializing</code>协议：需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。</li>
</ol>
<p>还以<code>GHIssue</code>为例，我们通常会以以下方式来定义我们的<code>Model</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GHIssue</span> : <span class="title">MTLModel</span> &lt;<span class="title">MTLJSONSerializing</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *URL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *HTMLURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSNumber</span> *number;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) GHIssueState state;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到，我们的<code>Model</code>继承了通常是<code>MTLModel</code>类，同时实现了<code>MTLJSONSerializing</code>协议。这样，我们不再需要像上面那样写一大堆的赋值代码和编码解码方法，而只需要实现<code>MTLJSONSerializing</code>协议的<code>+JSONKeyPathsByPropertyKey</code>类方法，将我们的属性名的键值与<code>JSON</code>字典的键值做一个映射，我们便可以在<code>MTLJSONAdapter</code>对象的帮助下自动进行赋值操作和编码解码操作。我们来看看<code>GHIssue</code>类的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GHIssue</span></span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"URL"</span>: <span class="string">@"url"</span>,</div><div class="line">        <span class="string">@"HTMLURL"</span>: <span class="string">@"html_url"</span>,</div><div class="line">        <span class="string">@"reporterLogin"</span>: <span class="string">@"user.login"</span>,</div><div class="line">        <span class="string">@"assignee"</span>: <span class="string">@"assignee"</span>,</div><div class="line">        <span class="string">@"updatedAt"</span>: <span class="string">@"updated_at"</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到，<code>Model</code>对象的属性与<code>JSON</code>数据之间的映射是通过字典来实现的。通过这种对应关系，<code>Model</code>对象便可以和<code>JSON</code>数据相互转换。需要注意的是返回中字典中的<code>key</code>值在<code>Model</code>对象中必须有对应的属性，否则Model对象将无法初始化成功。</p>
<p>当然这两者的值之间的转换关系可能需要我们自己来定义，这时我们就可以在<code>Model</code>中自定义<code>+(NSValueTransformer *)&lt;key&gt;JSONTransformer</code>方法来完成这一操作，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GHIssue</span></span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)URLJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> valueTransformerForName:<span class="built_in">MTLURLValueTransformerName</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)HTMLURLJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> valueTransformerForName:<span class="built_in">MTLURLValueTransformerName</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)stateJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> mtl_valueMappingTransformerWithDictionary:@&#123;</div><div class="line">        <span class="string">@"open"</span>: @(GHIssueStateOpen),</div><div class="line">        <span class="string">@"closed"</span>: @(GHIssueStateClosed)</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>​    </p>
<p>这样，在转换过程中，会自动调用这些方法来做数据的转换。而如果没有实现相应的方法，则会调用默认的<code>+JSONTransformerForKey:</code>来做处理，具体的实现可以参考<a href="http://southpeak.github.io/blog/2015/01/11/sourcecode-mantle/">《Mantle实现分析》</a>。</p>
<p>有了上面这些准备工作，我们就需要通过<code>MTLJSONAdapter</code>类来适配<code>MTLModel</code>对象和<code>JSON</code>数据了，这个更容易了，代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *JSONDictionary = ...;</div><div class="line"></div><div class="line">GHIssue *issue = [<span class="built_in">MTLJSONAdapter</span> modelOfClass:GHIssue.class fromJSONDictionary:JSONDictionary error:&amp;error];</div></pre></td></tr></table></figure>
<p>这样就根据一个<code>JSON</code>字典创建了一个<code>GHIssue</code>对象，而如果要从这个对象中获取到相应的<code>JSON</code>字典，则可以如下操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *JSONDictionary = [<span class="built_in">MTLJSONAdapter</span> JSONDictionaryFromModel:issue];</div></pre></td></tr></table></figure>
<p>以上便是<code>Mantle</code>的简单使用，当然更多的使用方式还需要在实践中多挖掘了。</p>
<p>这里还需要注意的是：</p>
<ol>
<li><code>MTLModel</code>的转换只针对我们定义的属性，而无法支持成员变量。</li>
<li>支持嵌套属性的转换，这对于对象属性来说非常有用。</li>
</ol>
<h2 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h2><p>想在我们的工程中使用<code>Mantle</code>，可以通过以下步骤导入：</p>
<ol>
<li>将<code>Mantle</code>库作为应用的子模块添加进来。</li>
<li>运行<code>Mantle</code>文件夹下的<code>script/bootstrap</code>脚本。</li>
<li>将<code>Mantle.xcodeproj</code>拖进我们的<code>XCode</code>工程或工作空间。</li>
<li>在程序<code>target</code>的<code>Build Phases</code>选项卡中，在<code>Link Binary With Libraries</code>下添加<code>Mantle</code>的相关信息。在<code>iOS</code>工程中，添加<code>libMantle.a</code>库。</li>
<li>在<code>&quot;Header Search Paths&quot;</code>设置中添加<code>&quot;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&quot; $(inherited)</code>。</li>
<li>对于<code>iOS</code>目标，在<code>&quot;Other Linker Flags&quot;</code>设置中添加<code>-ObjC</code>。</li>
<li>如果我们将<code>Mantle</code>添加到工程(而不是工作空间)，则我们需要将<code>Mantle</code>依赖的库添加到程序的<code>&quot;Target Dependencies&quot;</code>中。</li>
</ol>
<p>不过，我还是喜欢用<code>CocoaPods</code>来处理，只需要在<code>Podfile</code>中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;Mantle&apos;, &apos;~&gt; 1.5.3&apos;</div></pre></td></tr></table></figure>
<p>然后在对应目录下运行<code>pod install</code>，稍等片刻便可以使用<code>Mantle</code>了。关于<code>CocoaPods</code>的使用，可参考<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">github上的cocoapods工程</a>。</p>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p><code>Mantle</code>使用简单方便，极大的简化了我们的代码，可以满足我们大部分的需求。不过有时候我们可能会遇到这样的情况，由服务端提供的两个接口A和B，其实际上返回的数据可以转换为程序的同一个<code>Model</code>，只不过由于提供接口的是两个人，而且没有相互约定；抑或是服务端接口返回的数据与本地数据库的数据可以转换化同一个<code>Model</code>，但由于历史原因，这两者的字段也没对应上，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A接口返回的JSON数据为</span></div><div class="line">&#123;<span class="string">"user"</span>: <span class="string">"abc"</span>, <span class="string">"password"</span>: <span class="string">"abc"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// B接口返回的JSON数据为</span></div><div class="line">&#123;<span class="string">"user"</span>: <span class="string">"123"</span>, <span class="string">"pwd"</span>: <span class="string">"123"</span>&#125;</div></pre></td></tr></table></figure>
<p>这种情况下如何使用<code>Mantle</code>呢？看着实际上都一样，只是字段名不一样。这时似乎就不好处理了。因为<code>+JSONKeyPathsByPropertyKey</code>中，字典的<code>key</code>表示的是<code>MTLModel</code>的属性键值，是通过属性的键值去找相应的<code>JSON</code>数据的<code>key</code>。因此，这种情况下可能就得定义两个<code>Model</code>了。</p>
<p>在我们之前的工程中，也有做过类似<code>Mantle</code>的处理，只不过没有做得这么细致。针对上面的问题，我们的方案是刚好反过来，这个映射字典的key是<code>JSON</code>字典的<code>key</code>值，而映射字典的<code>value</code>是对象属性的<code>key</code>值。这样，我们就可以将不回数据来源的<code>JSON</code>字典的不同<code>key</code>映射到同一个<code>Model</code>对象的同一个属性上了。</p>
<p>另外一方面，由于转换过程涉及到一些映射查找操作，所以性能上也不如直接写赋值语句来得快。不过<code>Mantle</code>已以通过缓存对此做了优化，所以这一点还是可以接受的。</p>
<h2 id="参考与推荐"><a href="#参考与推荐" class="headerlink" title="参考与推荐"></a>参考与推荐</h2><ol>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle工程</a></li>
<li><a href="http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a></li>
<li><a href="http://ourui.github.io/blog/2014/01/22/mantle-use/" target="_blank" rel="external">Mantle 初步使用</a></li>
<li><a href="http://blog.codingcoder.com/use-mantle-to-model/" target="_blank" rel="external">使用Mantle处理Model层对象</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/08/quartz2d-13/" itemprop="url">
                  Quartz 2D编程指南之十三：PDF文档的创建、显示及转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-08T22:51:40+08:00" content="2015-01-08">
              2015-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PDF文档存储依赖于分辨率的向量图形、文本和位图，并用于程序的一系列指令中。一个PDF文档可以包含多页的图形和文本。PDF可用于创建跨平台、只读的文档，也可用于绘制依赖于分辨率的图形。</p>
<p>Quartz为所有应用程序创建高保真的PDF文档，这些文档保留应用的绘制操作，如图13-1所示。PDF文档的结果将通过系统的其它部分或第三方法的产品来有针对性地进行优化。Quartz创建的PDF文档在Preview和Acrobat中都能正确的显示。</p>
<p><strong>Figure 13-1  Quartz creates high-quality PDF documents</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/postscript_to_PDF.gif" alt="image"></p>
<p>Quartz不仅仅只使用PDF作为它的数字页，它同样包含一些API来显示和生成PDF文件，及完成一些其它PDF相关的工作。</p>
<h2 id="打开和查看PDF"><a href="#打开和查看PDF" class="headerlink" title="打开和查看PDF"></a>打开和查看PDF</h2><p>Quartz提供了CGPDFDocumentRef数据类型来表示PDF文档。我们可以使用CGPDFDocumentCreateWithProvider或CGPDFDocumentCreateWithURL来创建CGPDFDocument对象。在创建CGPDFDocument对象后，我们可以将其绘制到图形上下文中。图13-2显示了在一个窗体中绘制PDF文档。</p>
<p><strong>Figure 13-2  A PDF document</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_up.gif" alt="image"></p>
<p>代码清单13-1显示了如何创建一个CGPDFDocument对象及获取文档的页数。</p>
<p><strong>Listing 13-1  Creating a CGPDFDocument object from a PDF file</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGPDFDocumentRef <span class="title">MyGetPDFDocumentRef</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></div><div class="line">&#123;</div><div class="line">    CFStringRef path;</div><div class="line">    CFURLRef url;</div><div class="line">    CGPDFDocumentRef document;</div><div class="line">    <span class="keyword">size_t</span> count;</div><div class="line"> </div><div class="line">    path = CFStringCreateWithCString (<span class="literal">NULL</span>, filename,</div><div class="line">                         kCFStringEncodingUTF8);</div><div class="line">    url = CFURLCreateWithFileSystemPath (<span class="literal">NULL</span>, path, </div><div class="line">                        kCFURLPOSIXPathStyle, <span class="number">0</span>);</div><div class="line">    CFRelease (path);</div><div class="line">    document = CGPDFDocumentCreateWithURL (url);</div><div class="line">    CFRelease(url);</div><div class="line">    count = CGPDFDocumentGetNumberOfPages (document);</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"`%s' needs at least one page!"</span>, filename);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码清单显示了如何将一个PDF页绘制到图形上下文中。</p>
<p><strong>Listing 13-2  Drawing a PDF page</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDisplayPDFPage</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                    <span class="keyword">size_t</span> pageNumber,</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *filename)</div><div class="line">&#123;</div><div class="line">    CGPDFDocumentRef document;</div><div class="line">    CGPDFPageRef page;</div><div class="line"> </div><div class="line">    document = MyGetPDFDocumentRef (filename);</div><div class="line">    page = CGPDFDocumentGetPage (document, pageNumber);</div><div class="line">    CGContextDrawPDFPage (myContext, page);</div><div class="line">    CGPDFDocumentRelease (document);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为PDF页创建一个转换"><a href="#为PDF页创建一个转换" class="headerlink" title="为PDF页创建一个转换"></a>为PDF页创建一个转换</h2><p>Quartz提供了函数CGPDFPageGetDrawingTransform来创建一个仿射变换，该变换基于将PDF页的BOX映射到指定的矩形中。函数原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGAffineTransform <span class="title">CGPDFPageGetDrawingTransform</span> <span class="params">(</span></span></div><div class="line">        CGPPageRef page,</div><div class="line">        CGPDFBox box,</div><div class="line">        CGRect rect,</div><div class="line">        <span class="keyword">int</span> rotate,</div><div class="line">        <span class="keyword">bool</span> preserveAspectRatio</div><div class="line">);</div></pre></td></tr></table></figure>
<p>该函数通过如下算法来返回一个仿射变换：</p>
<ol>
<li>将在box参数中指定的PDF box的类型相关的矩形(media, crop, bleed, trim, art)与指定的PDF页的/MediaBox入口求交集。相交的部分即为一个有效的矩形(effectiverectangle)。</li>
<li>将effective rectangle旋转参数/Rotate入口指定的角度。</li>
<li>将得到的矩形放到rect参数指定的中间。</li>
<li>如果rotate参数是一个非零且是90的倍数，函数将effective rectangel旋转该值指定的角度。正值往右旋转；负值往左旋转。需要注意的是我们传入的是角度，而不是弧度。记住PDF页的/Rotate入口也包含一个旋转，我们提供的rotate参数是与/Rotate入口接合在一起的。</li>
<li>如果需要，可以缩放矩形，从而与我们提供的矩形保持一致。</li>
<li>如果我们通过传递true值给preserveAspectRadio参数以指定保持长宽比，则最后的矩形将与rect参数的矩形的边一致。</li>
</ol>
<p>【注：上面这段翻译得不是很好】</p>
<p>例如，我们可以使用这个函数来创建一个与图13-3类似的PDF浏览程序。如果我们提供一个Rotate Left/Rotate Right属性，则可以调用CGPDFPageGetDrawingTransform来根据当前的窗体大小和旋转设置计算出适当的转换。</p>
<p><strong>Figure 13-3  A PDF page rotated 90 degrees to the right</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_rotate.gif" alt="image"></p>
<p>程序清单13-3显示了为一个PDF页创建及应用仿射变换，然后绘制PDF。</p>
<p><strong>Listing 13-3  Creating an affine transform for a PDF page</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawPDFPageInRect</span> <span class="params">(CGContextRef context,</span></span></div><div class="line">                    CGPDFPageRef page,</div><div class="line">                    CGPDFBox box,</div><div class="line">                    CGRect rect,</div><div class="line">                    <span class="keyword">int</span> rotation,</div><div class="line">                    <span class="keyword">bool</span> preserveAspectRatio)</div><div class="line">&#123;</div><div class="line">    CGAffineTransform m;</div><div class="line"> </div><div class="line">    m = CGPDFPageGetDrawingTransform (page, box, rect, rotation,</div><div class="line">                                    preserveAspectRato);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    CGContextConcatCTM (context, m);</div><div class="line">    CGContextClipToRect (context,CGPDFPageGetBoxRect (page, box));</div><div class="line">    CGContextDrawPDFPage (context, page);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="创建PDF文件"><a href="#创建PDF文件" class="headerlink" title="创建PDF文件"></a>创建PDF文件</h2><p>使用Quartz创建PDF与绘制其它图形上下文一下简单。我们指定一个PDF文件地址，设置一个PDF图形上下文，并使用与其它图形上下文一样的绘制程序。如代码清单13-4所示的MyCreatePDFFile函数，显示了创建一个PDF的所有工作。</p>
<p>注意，代码在CGPDFContextBeginPage和CGPDFContextEndPage中来绘制PDF。我们可以传递一个CFDictionary对象来指定页属性，包括media, crop, bleed,trim和art boxes。</p>
<p><strong>Listing 13-4  Creating a PDF file</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCreatePDFFile</span> <span class="params">(CGRect pageRect, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></div><div class="line">&#123;</div><div class="line">    CGContextRef pdfContext;</div><div class="line">    CFStringRef path;</div><div class="line">    CFURLRef url;</div><div class="line">    CFDataRef boxData = <span class="literal">NULL</span>;</div><div class="line">    CFMutableDictionaryRef myDictionary = <span class="literal">NULL</span>;</div><div class="line">    CFMutableDictionaryRef pageDictionary = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">    path = CFStringCreateWithCString (<span class="literal">NULL</span>, filename, </div><div class="line">                                kCFStringEncodingUTF8);</div><div class="line">    url = CFURLCreateWithFileSystemPath (<span class="literal">NULL</span>, path, </div><div class="line">                     kCFURLPOSIXPathStyle, <span class="number">0</span>);</div><div class="line">    CFRelease (path);</div><div class="line">    myDictionary = CFDictionaryCreateMutable(<span class="literal">NULL</span>, <span class="number">0</span>,</div><div class="line">                        &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                        &amp;kCFTypeDictionaryValueCallBacks); </div><div class="line">    CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR(<span class="string">"My PDF File"</span>));</div><div class="line">    CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR(<span class="string">"My Name"</span>));</div><div class="line">    pdfContext = CGPDFContextCreateWithURL (url, &amp;pageRect, myDictionary); </div><div class="line">    CFRelease(myDictionary);</div><div class="line">    CFRelease(url);</div><div class="line">    pageDictionary = CFDictionaryCreateMutable(<span class="literal">NULL</span>, <span class="number">0</span>,</div><div class="line">                        &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                        &amp;kCFTypeDictionaryValueCallBacks); </div><div class="line">    boxData = CFDataCreate(<span class="literal">NULL</span>,(<span class="keyword">const</span> UInt8 *)&amp;pageRect, <span class="keyword">sizeof</span> (CGRect));</div><div class="line">    CFDictionarySetValue(pageDictionary, kCGPDFContextMediaBox, boxData);</div><div class="line">    CGPDFContextBeginPage (pdfContext, pageDictionary); </div><div class="line">    myDrawContent (pdfContext);</div><div class="line">    CGPDFContextEndPage (pdfContext);</div><div class="line">    CGContextRelease (pdfContext);</div><div class="line">    CFRelease(pageDictionary); </div><div class="line">    CFRelease(boxData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h2><p>我们可以在PDF上下文中添加链接和锚点。Quartz提供了三个函数，每个函数都以PDF图形上下文作为参数，还有链接的信息：</p>
<ol>
<li>CGPDFContextSetURLForRect可以让我们指定在点击当前PDF页中的矩形时打开一个URL。</li>
<li>CGPDFContextSetDestinationForRect指定在点击当前PDF页中的矩形区域时设置目标以进行跳转。我们需要提供一个目标名。</li>
<li>CGPDFContextAddDestinationAtPoint指定在点击当前PDF页中的一个点时设置目标以进行跳转。我们需要提供一个目标名。</li>
</ol>
<h2 id="保护PDF内容"><a href="#保护PDF内容" class="headerlink" title="保护PDF内容"></a>保护PDF内容</h2><p>为了保护PDF内容，我们可以在辅助字典中指定一些安全选项并传递给CGPDFContextCreate。我们可以通过包含如下关键字来设置所有者密码、用户密码、PDF是否可以被打印或拷贝：</p>
<ol>
<li>kCGPDFContextOwnerPassword: 定义PDF文档的所有者密码。如果指定该值，则文档使用所有者密码来加密；否则文档不加密。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。该值没有默认值。如果该值不能表示成ASCII，则无法创建文档并返回NULL。Quartz使用40-bit加密。</li>
<li>kCGPDFContextUserPassword: 定义PDF文档的用户密码。如果文档加密了，则该值是文档的用户密码。如果没有指定，则用户密码为空。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。如果该值不能表示成ASCII，则无法创建文档并返回NULL。</li>
<li>kCGPDFContextAllowsPrinting:指定当使用用户密码锁定时文档是否可以打印。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
<li>kCGPDFContextAllowsCopying: 指定当使用用户密码锁定时文档是否可以拷贝。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
</ol>
<p>代码清单14-4(下一章)显示了确认PDF文档是否被锁定，及用密码打开文档。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/08/quartz2d-12/" itemprop="url">
                  Quartz 2D编程指南之十二：Core Graphics层绘制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-08T22:47:51+08:00" content="2015-01-08">
              2015-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CGLayer对象(CGLayerRef数据类型)允许程序使用层来进行绘制。</p>
<p>层适合于以下几种情况：</p>
<ol>
<li>高质量离屏渲染，以绘制我们想重用的图形。例如，我们可能要建立一个场景并重用相同的背景。将背景场景绘制于一个层上，然后在需要的时候再绘制层。一个额外的好处是我们不需要知道颜色空间或其它设备依赖的信息来绘制层。</li>
<li>重复绘制。例如，我们可能想创建一个由相同元素反复绘制而组成的模式。将元素绘制到一个层中，然后重复绘制这个层，如图12-1所示。任何我们重复绘制的Quartz对象，包括CGPath, CGShading和CGPDFPage对象，都可以通过将其绘制到CGLayer来优化性能。注意一个层不仅仅是用于离屏绘制；我们也可以将其用于那些不是面向屏幕的图形上下文，如PDF图形上下文。</li>
<li>缓存。虽然我们可以将层用于此目的，但通常不需要这样做，因为Quartz Compositor已经做了此事。如果我们必须绘制一个缓存，则使用层来代替位图图形上下文。</li>
</ol>
<p><strong>Figure 12-1  Repeatedly painting the same butterfly image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/stamp_layers.gif" alt="image"></p>
<p>CGLayer对象和透明层是与CGPath对象以及CGContext函数创建的路径并行的。对于一个CGLayer或者CGPath对象，我们可以将其绘制到一个抽象目标，之后可以将其完整地绘制到另一个目标，如显示器或才PDF中。当我们在透明层上绘制或者使用绘制路径的CGContext函数时，可以直接绘制到图形上下文表示的目标上，而不需要负责组装绘制的中间抽象目标。</p>
<h2 id="层如何工作"><a href="#层如何工作" class="headerlink" title="层如何工作"></a>层如何工作</h2><p>一个层由CGLayerRef数据类型表示，是为优化性能而设计的。在可能的时候，Quartz使用合适的机制将一个CGLayer对象缓存到与之相关的Quartz图形上下文中。例如，与显卡相关的图形上下文可能将层缓存到显卡中，这样绘制在层中的内容时，就比渲染从一个位图图形上下文中构造的类似图像要快得多。基于这个原因，层比位图图形上下文更适用于离屏绘制。</p>
<p>所有的Quartz绘制函数都是绘制到图形上下文中。图形上下文提供了一个抽象的渲染目标，而将我们从目标的细节中解放出来。我们使用用户空间，Quartz执行必要的转换来将绘图正确地渲染到目标。当我们使用CGLayer对象来绘制时，我们也是绘制到图形上下文中。图12-1演示了层绘制的必要步骤。</p>
<p><strong>Figure 12-2  Layer drawing</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/layer_context.gif" alt="image"></p>
<p>所有在图形上下文中层的绘制都是以使用函数CGLayerCreateWithContext创建一个CGLayer对象开始的。用于创建CGLayer对象的图形上下文通常是一个window图形上下文。Quartz创建一个层，使得它具有图形上下文的所有特性：包括分辨率，颜色空间和图形状态设置。如果我们不想使用图形上下文的大小，则可以提供一个大小给层。在图12-2中，左侧显示了用于创建层的图形上下文。框右侧的灰色部分，即标记为CGLayer对象的部分表示新创建的层。</p>
<p>在我们可以绘制层之前，我们必须通过调用CGLayerGetContext函数来获取与层相关的图形上下文。这个图形上下文与用于创建层的图形上下文是差不多的。只要用于创建层的图形上下文是一个window图形上下文，则CGLayer图形上下文会尽可能地被缓存到GPU中。图12-2中位于框右侧的白色部分表示新创建的层图形上下文。</p>
<p>在层图形上下文中绘制与在其它图形上下文中绘制一样，将层图形上下文作为参数传给绘制函数。图12-2显示了一片绘制到层图形上下文的叶子。</p>
<p>当我们准备使用层的内容时，我们可以调用函数CGContextDrawLayerInRect或者CGContextDrawLayerAtPoint将层绘制到一个图形上下文。通常情况下，我们会将层绘制到创建层对象的图形上下文中，但这不是必须的。我们可以将层绘制到任意的图形上下文，记住：层带有创建层对象的图形上下文的所有特性，这可能会产生一些限制(如性能或分辨率)。例如，与屏幕关联的层可能会被缓存到显卡中。如果目标上下文是一个打印机或PDF上下文，则可能需要将层对象从显卡中取出并放到内存中，从而导致性能很差。</p>
<p>图12-2显示了层的内容–叶子–被重复地绘制到创建层对象的图形上下文中。我们可以在释放CGLayer对象之前，任意地重复使用层中的绘图。</p>
<h2 id="使用层来绘制"><a href="#使用层来绘制" class="headerlink" title="使用层来绘制"></a>使用层来绘制</h2><p>我们需要按照如下几个步骤来使用层对象进行绘制：</p>
<ol>
<li>创建一个使用已存在的图形上下文初始化的层对象</li>
<li>为层获取图形上下文</li>
<li>绘制到CGLayer图形上下文</li>
<li>将层绘制到目标图形上下文</li>
</ol>
<p>我们将在下面详细描述这几个步骤。</p>
<h3 id="创建一个使用已存在的图形上下文初始化的层对象"><a href="#创建一个使用已存在的图形上下文初始化的层对象" class="headerlink" title="创建一个使用已存在的图形上下文初始化的层对象"></a>创建一个使用已存在的图形上下文初始化的层对象</h3><p>函数CGLayerCreateWithContext返回一个使用已存在的图形上下文初始化的层对象。这个层对象继承了该图形上下文的所有特性，包括颜色空间、大小、分辨率和像素格式。后期当我们绘制层对象到一个目标时，Quartz会自动对层与目标上下文进行颜色匹配。</p>
<p>函数CGLayerCreateWithContext带有三个参数：</p>
<ol>
<li>用于创建层的图形上下文。通常我们传递一个window图形上下文以便后面可以离屏绘制层。</li>
<li>层相对于图形上下文的大小。层的大小可以和图形上下文一样，或者更小。如果想要获得层的大小，我们可以调用函数CGLayerGetSize。</li>
<li>一个辅助字典。这个参数现在已经不用了，所以传递NULL即可。</li>
</ol>
<h3 id="为层获取图形上下文"><a href="#为层获取图形上下文" class="headerlink" title="为层获取图形上下文"></a>为层获取图形上下文</h3><p>Quartz总是在一个图形上下文中进行绘制。现在我们有了一个层对象，我们必须创建一个与层相关的图形上下文。所有绘制到层图形上下文的内容都是层的一部分。</p>
<p>函数CGLayerGetContext获取一个层对象作为参数，并返回与之相关的图形上下文。</p>
<h3 id="绘制到CGLayer图形上下文"><a href="#绘制到CGLayer图形上下文" class="headerlink" title="绘制到CGLayer图形上下文"></a>绘制到CGLayer图形上下文</h3><p>在获取到与层相关的图形上下文之后，我们可以在层图形上下文中绘制任何东西。我们可以打开一个PDF文件或一个图像文件，并将文件内容绘制到层中。我们可以使用Quartz 2D的任何函数来绘制矩形、直线或其它绘制单元。图12-3显示了在层中绘制一个矩形和直线。</p>
<p><strong>Figure 12-3  A layer that contains two rectangles and a series of lines</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_layer.gif" alt="image"></p>
<p>例如，为了在CGLayer图形上下文中绘制一个填充矩形，我们调用函数CGContextFillRect，并提供从CGLayerGetContext函数中获取到的图形上下文作为参数。假设这个图形上下文命名为myLayerContext，则函数调用如下：</p>
<pre><code>CGContextFillRect (myLayerContext, myRect)
</code></pre><h3 id="将层绘制到目标图形上下文"><a href="#将层绘制到目标图形上下文" class="headerlink" title="将层绘制到目标图形上下文"></a>将层绘制到目标图形上下文</h3><p>当我们已经准备好将层绘制到目标图形上下文时，我们可以使用以下任一一个函数：</p>
<ol>
<li>CGContextDrawLayerInRect：将层绘制到图形上下文中指定的矩形内。</li>
<li>CGContextDrawLayerAtPoint：将层绘制到图形上下文中指定的点。</li>
</ol>
<p>通常情况下，我们提供的目标图形上下文是一个window图形上下文，这也是我们用于创建层对象所使用的图形上下文。图12-4显示了重复绘制图12-3所绘制的层。为了达到模式效果，我们可以使用上面两个方法中的任意一个，只是每次改变偏移量而已。例如，我们每次绘制层时，可以调用函数CGContextTranslateCTM来改变坐标系统的原点。</p>
<p><strong>Figure 12-4  Drawing a layer repeatedly</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_pattern.gif" alt="image"></p>
<blockquote>
<p>注意：我们不必要将层绘制到初始层所使用的图形上下文中。然而，如果我们将层绘制到其它图形上下文中，原始图形上下文的所有限制都会反映到我们的绘图中。</p>
</blockquote>
<h2 id="例子：使用多个CGLayer对象来绘制旗子"><a href="#例子：使用多个CGLayer对象来绘制旗子" class="headerlink" title="例子：使用多个CGLayer对象来绘制旗子"></a>例子：使用多个CGLayer对象来绘制旗子</h2><p>这一节演示了如何使用CGLayer对象来在屏幕上绘制图12-5中的旗子。首先我们会看到如何将旗子分解成简单的绘制单元，然后会看到要完成这些任务的代码。</p>
<p><strong>Figure 12-5  The result of using layers to draw the United States flag</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/us_flag.gif" alt="image"></p>
<p>从上面可以看出，旗子主要分三部分：</p>
<ol>
<li>红色条纹和白色条纹的模式。我们可以将这个模式分解为一个单一的红色条纹，因为对于屏幕绘制来说，我们可以假设其背景颜色为白色。我们创建一个红色矩形，然后以变化的偏移量来重复绘制这个矩形，以创建美国国旗上的七条红色条纹。我们将红色矩形绘制到一个层，然后将其绘制到屏幕上七次。</li>
<li>一个蓝色矩形。我们只需要一个蓝色矩形，所以没有必要使用层。当绘制蓝色矩形时，直接将其绘制到屏幕上。</li>
<li>50个白色星星的模式。与红色条纹一下，可以使用层来绘制星星。我们创建星星边框的一个路径，然后使用白条来填充。将一个星星绘制到层，然后重复50次绘制这个层，每次绘制时适当调整偏移量。</li>
</ol>
<p>代码清单12-2完成了对图12-5的绘制。myDrawFlag例程在一个Cocoa程序中调用。这个程序传递一个window图形上下文和一个与图形上下文相关的视图的大小。</p>
<p><strong>Listing 12-1  Code that uses layers to draw a flag</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDrawFlag</span> <span class="params">(CGContextRef context, CGRect* contextRect)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>          i, j,</div><div class="line">                 num_six_star_rows = <span class="number">5</span>,</div><div class="line">                 num_five_star_rows = <span class="number">4</span>;</div><div class="line">    CGFloat      start_x = <span class="number">5.0</span>,</div><div class="line">                 start_y = <span class="number">108.0</span>,</div><div class="line">                 red_stripe_spacing = <span class="number">34.0</span>,</div><div class="line">                 h_spacing = <span class="number">26.0</span>,</div><div class="line">                 v_spacing = <span class="number">22.0</span>;</div><div class="line">    CGContextRef myLayerContext1,</div><div class="line">                 myLayerContext2;</div><div class="line">    CGLayerRef   stripeLayer,</div><div class="line">                 starLayer;</div><div class="line">    CGRect       myBoundingBox,</div><div class="line">                 stripeRect,</div><div class="line">                 starField;</div><div class="line"> <span class="comment">// ***** Setting up the primitives *****</span></div><div class="line"> 	CGPoint point1 = &#123;<span class="number">5</span>, <span class="number">5</span>&#125;, point2 = &#123;<span class="number">10</span>, <span class="number">15</span>&#125;, point3 = &#123;<span class="number">10</span>, <span class="number">15</span>&#125;, point4 = &#123;<span class="number">15</span>, <span class="number">5</span>&#125;;</div><div class="line"> 	CGPoint point5 = &#123;<span class="number">15</span>, <span class="number">5</span>&#125;, point6 = &#123;<span class="number">2.5</span>, <span class="number">11</span>&#125;, point7 = &#123;<span class="number">2.5</span>, <span class="number">11</span>&#125;, point8 = &#123;<span class="number">16.5</span>, <span class="number">11</span>&#125;;</div><div class="line"> 	CGPoint point9 = &#123;<span class="number">16.5</span>, <span class="number">11</span>&#125;, point10 = &#123;<span class="number">5</span>, <span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">const</span> CGPoint myStarPoints[] = &#123;point1, point2,</div><div class="line">                                    point3, point4,</div><div class="line">                                    point5, point6,</div><div class="line">                                    point7, point8,</div><div class="line">                                    point9, point10&#125;;</div><div class="line"> </div><div class="line">    stripeRect  = CGRectMake (<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">17</span>); <span class="comment">// stripe</span></div><div class="line">    starField  =  CGRectMake (<span class="number">0</span>, <span class="number">102</span>, <span class="number">160</span>, <span class="number">119</span>); <span class="comment">// star field</span></div><div class="line"> </div><div class="line">    myBoundingBox = CGRectMake (<span class="number">0</span>, <span class="number">0</span>, contextRect-&gt;size.width, </div><div class="line">                                      contextRect-&gt;size.height);</div><div class="line"> </div><div class="line">     <span class="comment">// ***** Creating layers and drawing to them *****</span></div><div class="line">    stripeLayer = CGLayerCreateWithContext (context, </div><div class="line">                            stripeRect.size, <span class="literal">NULL</span>);</div><div class="line">    myLayerContext1 = CGLayerGetContext (stripeLayer);</div><div class="line"> </div><div class="line">    CGContextSetRGBFillColor (myLayerContext1, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myLayerContext1, stripeRect);</div><div class="line"> </div><div class="line">    starLayer = CGLayerCreateWithContext (context,</div><div class="line">                            starField.size, <span class="literal">NULL</span>);</div><div class="line">    myLayerContext2 = CGLayerGetContext (starLayer);</div><div class="line">    CGContextSetRGBFillColor (myLayerContext2, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1</span>);</div><div class="line">    CGContextAddLines (myLayerContext2, myStarPoints, <span class="number">10</span>);</div><div class="line">    CGContextFillPath (myLayerContext2);    </div><div class="line"> </div><div class="line">     <span class="comment">// ***** Drawing to the window graphics context *****</span></div><div class="line">    CGContextSaveGState(context);    </div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">7</span>;  i++)   </div><div class="line">    &#123;</div><div class="line">        CGContextDrawLayerAtPoint (context, CGPointZero, stripeLayer);</div><div class="line">        CGContextTranslateCTM (context, <span class="number">0.0</span>, red_stripe_spacing);</div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGContextSetRGBFillColor (context, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.329</span>, <span class="number">1.0</span>);</div><div class="line">    CGContextFillRect (context, starField);</div><div class="line"> </div><div class="line">    CGContextSaveGState (context);              </div><div class="line">    CGContextTranslateCTM (context, start_x, start_y);      </div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt; num_six_star_rows;  j++)   </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">6</span>;  i++)</div><div class="line">        &#123;</div><div class="line">            CGContextDrawLayerAtPoint (context,CGPointZero,</div><div class="line">                                            starLayer);</div><div class="line">            CGContextTranslateCTM (context, h_spacing, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing); </div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGContextSaveGState(context);</div><div class="line">    CGContextTranslateCTM (context, start_x + h_spacing/<span class="number">2</span>, </div><div class="line">                                 start_y + v_spacing/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt; num_five_star_rows;  j++) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">5</span>;  i++)</div><div class="line">        &#123;</div><div class="line">        CGContextDrawLayerAtPoint (context, CGPointZero,</div><div class="line">                            starLayer);</div><div class="line">            CGContextTranslateCTM (context, h_spacing, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing);</div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGLayerRelease(stripeLayer);</div><div class="line">    CGLayerRelease(starLayer);        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此不再翻译对代码的注释，请各位看官查看文档原文<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219-TPXREF101" target="_blank" rel="external">Core Graphics Layer Drawing</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/05/quartz2d-11/" itemprop="url">
                  Quartz 2D编程指南之十一：位图与图像遮罩
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-05T23:10:23+08:00" content="2015-01-05">
              2015-01-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>位图与图像遮罩和Quartz中的其它绘制元素一样。这两者在Quartz中都是用CGImageRef数据类型来表示。正如在本章后面看到的一样，我们有一系列的方法来创建一个图像。其中一些需要数据提供者或图像源来提供位图数据。另外一些函数则通过拷贝图像或在图像上应用操作来从已存在的图像中创建图像。不管我们是以何种方式来创建图像，我们都可以将图像绘制到任何类型的图形上下文。记住，位图是在指定分辨率下的一个字节数组。如果我们将位图绘制到一个依赖于分辨率的图形上下文中(如PDF图形上下文)，则位图受限于创建它的图形上下文的分辨率。</p>
<p>我们可以通过调用CGImageMaskCreate函数来创建一个Quartz图像遮罩。我们将在“创建图像遮罩”一节中看到如何创建遮罩。使用图像遮罩不是绘制遮罩的唯一方法，具体的我们都会在下面看到。</p>
<h2 id="位图和图像遮罩"><a href="#位图和图像遮罩" class="headerlink" title="位图和图像遮罩"></a>位图和图像遮罩</h2><p>一个位图是一个像素数组。每一个像素表示图像中的一个点。JPEG, TIFF和PNG图像文件都是位图。应用程序的icon也是位图。位图被限定在一个矩形内。但是通过使用alpha分量，它们可以呈现不同的形式，也可以旋转或被裁剪，如图11-1所示：</p>
<p><strong>Figure 11-1  Bitmap images</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/images.gif" alt="image"></p>
<p>位图中的每一个采样包含特定颜色空间下的一个或更多颜色分量，以及一个额外的用于指定alpha值以表示透明度的分量。每一个分量可以是从1-32位。在Mac OS X中，Quartz支持浮点值分量。在Mac OS X和iOS中支持的格式将会在下文中介绍。ColorSync提供了位图支持的颜色空间。</p>
<p>Quartz同样支持图像遮罩(image masks)。一个图像遮罩也是一个位图，它指定了一个绘制区域，而不是颜色。从效果上来说，一个图像遮罩更像一个模块，它指定在page中绘制颜色的位置。Quartz使用当前的填充颜色来绘制一个图像遮罩。一个颜色遮罩可以有1-8位的深度。</p>
<h2 id="位图信息"><a href="#位图信息" class="headerlink" title="位图信息"></a>位图信息</h2><p>Quartz提供了很多图像格式并内建了多种常用的格式。在iOS中，这些格式包括JPEG, GIF, PNG, TIF, ICO, GMP, XBM, 和CUR。其它的位图格式或专有格式需要我们指定图像格式的详细信息，以便Quartz能正确地解析图像。我们提供给CGImageCreate函数的图像数据必须是以像素为单位的，而不是基于扫描线的。Quartz不支持平面数据。</p>
<p>这一节描述了与位图相关的信息。当我们创建并使用Quartz图像时(使用CGImageRef数据类型)，我们将看到一些Quartz图像创建函数需要我们指定所有的信息，而其它函数只需要部分信息。我们所需要提供的信息依赖于位图数据的编码，以及位图是表示一个图像还是图像遮罩。</p>
<blockquote>
<p>注意：当使用原始图像数据时，为了获得更好的性能，我们可以使用vImage框架。我们可以使用vImageBuffer_InitWithCGImage函数从一个CGImageRef引用导入图像数据到vImage中。</p>
</blockquote>
<p>创建一个位图(CGImageRef)时，Quartz使用以下信息：</p>
<ol>
<li>位图数据源：可以是一个Quartz数据提供者或者是一个Quartz图像源。</li>
<li>可选的解码数组。(Decode Array)</li>
<li>插值设置：这是一个布尔值，指定Quartz在重置图像大小时是否使用插值算法。</li>
<li>渲染意图：指定如何映射位于图形上下文中的目标颜色空间中的颜色。该值在图像遮罩中不需要。</li>
<li>图像尺寸</li>
<li>像素格式，包括每个分量中的位数，每个像素的位数和每行中的字节数。</li>
<li>对于图像来说，颜色空间和位图布局信息描述了alpha的位置和位置是否使用浮点值。图像遮罩不需要这个信息。</li>
</ol>
<h3 id="解码数组"><a href="#解码数组" class="headerlink" title="解码数组"></a>解码数组</h3><p>一个解码数组将图像颜色值映射到其它颜色值，这对于诸如对一个图像做去饱和或者反转颜色值非常有用。数组包含每个颜色分量的一个数值对。当Quartz渲染图像时，它利用一个线性转换将原始分量值映射到一个目标颜色空间中的指定范围内一个相关值。例如，在RGB颜色空间中的一个图像的解码数组包含6个输入，分别用于红、绿、蓝颜色分量。</p>
<h3 id="像素格式"><a href="#像素格式" class="headerlink" title="像素格式"></a>像素格式</h3><p>像素格式包含以下信息：</p>
<ol>
<li>每个分量的位数，即在一个像素中每个独立颜色分量的位数。对于一个图像遮罩，这个值是源像素中遮罩bit的数目。例如，如果源图片是8-bit的遮罩，则指定每个分量是8位。</li>
<li>每个像素的位数，即一个源像素所占的总的位数。这个值必须至少是每个分量的位数乘以每个像素中分量的数目。</li>
<li>每行的字节数，即图像中水平行的字节数。</li>
</ol>
<h3 id="颜色空间和位图布局"><a href="#颜色空间和位图布局" class="headerlink" title="颜色空间和位图布局"></a>颜色空间和位图布局</h3><p>为了确保Quartz能正确的解析每个像素的位，我们必须指定：</p>
<ol>
<li>一个位图是否包含alpha通道。Quartz包含RGB,CMYK和灰度颜色空间。它也支持alpha，或者透明度，虽然并不是所有位图图像格式都支持alpha通道。当它可用时，alpha分量可以位于像素最显著的位置，也可以是最不显著的位置。</li>
<li>对于有alpha分量的位图，指定颜色分量是否已经乘以了alpha值。预乘alpha(Premultiplied alpha)表示一个已将颜色分量乘以了alpha值的源颜色。这种预处理通过消除每个颜色分量的额外的乘法运算来加速图片的渲染。</li>
<li>采样的数据格式–是整型还是浮点型。</li>
</ol>
<p>当我们使用CGImageCreate函数来创建一个图像时，我们提供一个类型为CGImageBitmapInfo的bitmapInfo参数，来指定位置布局信息。以下的常量指定了alpha分量的位置及颜色分量是否做预处理：</p>
<ol>
<li>kCGImageAlphaLast：alpha分量存储在每个像素中最不显著的位置，如RGBA。</li>
<li>kCGImageAlphaFirst：alpha分量存储在每个像素中最显著的位置，如ARGB。</li>
<li>kCGImageAlphaPremultipliedLast：alpha分量存储在每个像素中最不显著的位置，但颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaPremultipliedFirst：alpha分量存储在每个像素中最显著的位置，同时颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaNoneSkipLast：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最不显著位置的位将被忽略。</li>
<li>kCGImageAlphaNoneSkipFirst：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最显著位置的位将被忽略。</li>
<li>kCGImageAlphaNone：等于kCGImageAlphaNoneSkipLast。</li>
</ol>
<p>我们使用常量kCGBitmapFloatComponents来标识一个位图格式使用浮点值。对于浮点格式，我们将这个常量与上而描述的合适的常量进行逻辑OR操作。例如，对于每个像素有128位的使用预处理的浮点格式，同时alpha值位于像素中最不显示位置，我们将以下信息提供给Quartz：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kCGImageAlphaPremultipliedLast | kCGBitmapFloatComponents</div></pre></td></tr></table></figure>
<p>图11-2演示了一个像素在使用16-或32-bit整型像素格式的CMYK和RGB颜色空间中如何表示。32-bit整型像素格式中，每个分量占8位。16-bit整型像素格式中每个分量占5位。Quartz同样支持128-bit浮点像素格式，每个分量占32位。128-bit格式没有显示在下图中。</p>
<p><strong>Figure 11-2  32-bit and 16-bit pixel formats for CMYK and RGB color spaces in Quartz 2D</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif" alt="image"></p>
<h2 id="创建图像"><a href="#创建图像" class="headerlink" title="创建图像"></a>创建图像</h2><p>表11-1罗列了Quartz提供的用于创建CGImageRef对象的函数。函数的选择依赖于图像的数据源。最常用的函数是CGImageCreate。它可以从任何类型的位图数据来创建一个图像。然而，它是最复杂的函数，因为需要提供所有的位图信息。为了使用这个函数，我们需要熟悉上面讨论的位图图像信息的内容。</p>
<p>如果我们想从一个标准的图像格式，如PNG或JPEG，来创建一个CGImage对象，则最简单的方法是调用函数CGImageSourceCreateWithURL来创建一个图像源，然后调用CGImageSourceCreateImageAtIndex以使用从图像源中索引index指定的图像数据来创建一个图像。如果源图像文件只包含一个图像，则索引为0。如果图像文件格式支持包含多个图像的文件，则需要提供所需要图像的索引值，记住起始值是0。</p>
<p>如果我们已经将内容渲染到一个位图图形上下文，并想要从中获取到CGImage对象，则调用CGBitmapContextCreateImage函数。</p>
<p>有几个函数可以操作已有的图像，如拷贝、创建一个缩略图，或从一个大图像中创建一个图像。不管如何创建一个图像对象，我们都使用函数CGContextDrawImage将图像绘制到一个图形上下文中。记住CGImage是不可变的。当不再需要一个CGImage对象时，调用CGImageRelease函数来释放它。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table11-1.png?raw=true" alt="image"></p>
<p>接下来将讨论如何创建：</p>
<ol>
<li>从一个已存在图像中创建一个子图像</li>
<li>从一个图像图形上下文中创建一个图像</li>
</ol>
<h3 id="从一个大图片中创建一个图像"><a href="#从一个大图片中创建一个图像" class="headerlink" title="从一个大图片中创建一个图像"></a>从一个大图片中创建一个图像</h3><p>我们可以使用CGImageCreateWithImageInRect函数从一个大图像中创建一个图像。图11-3演示了这一情形。</p>
<p><strong>Figure 11-3  A subimage created from a larger image</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/subimage.gif" alt="image"></p>
<p>函数CGImageCreateWithImageInRect返回的图像保留了源图像的一个引用，这意味着我们在调用完这个函数后可以释放源图像。</p>
<p>图11-4是另外一个例子。在这种情况下，公鸡的头部被从大图中提取出来，然后绘制到一个大于子图像的矩形中。</p>
<p>代码清单11-1显示了创建并绘制子图像的过程。CGContextDrawImage函数绘制公鸡头部的矩形区域是所提取的子图像的四倍大小。清单中的只是一个代码片断。我们需要声明合适的变量，创建公鸡头像，并部署公鸡图像及公鸡头部子图像。因为只是代码片断，所以没有演示如何创建一个图形上下文。我们可以使用任何我们所喜欢的图形上下文。创建图形上下文的例子可以查看“图形上下文”一章。</p>
<p><strong>Figure 11-4  An image, a subimage taken from it and drawn so it’s enlarged</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_image_zoom.gif" alt="image"></p>
<p><strong>Listing 11-1  Code that creates a subimage and draws it enlarged</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myImageArea = CGRectMake (rooster_head_x_origin, rooster_head_y_origin,</div><div class="line">                            myWidth, myHeight);</div><div class="line">mySubimage = CGImageCreateWithImageInRect (myRoosterImage, myImageArea);</div><div class="line">myRect = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, myWidth*<span class="number">2</span>, myHeight*<span class="number">2</span>);</div><div class="line">CGContextDrawImage(context, myRect, mySubimage);</div></pre></td></tr></table></figure>
<h3 id="从一个位图图形上下文创建一个图像"><a href="#从一个位图图形上下文创建一个图像" class="headerlink" title="从一个位图图形上下文创建一个图像"></a>从一个位图图形上下文创建一个图像</h3><p>为了从一个已存在的位图图形上下文创建一个图像，我们可以调用函数CGBitmapContextCreateImage，如以下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGImageRef myImage;</div><div class="line">myImage = CGBitmapContextCreateImage (myBitmapContext);</div></pre></td></tr></table></figure>
<p>这个函数返回的CGImage对象是通过一个拷贝操作创建的。因此我们对位图图形上下文所做的修改都不会影响到已返回的CGImage对象。在一些情况下，这个拷贝操作实际上沿用了copy-on-write语义，即只有当位图图形上下文中的数据被修改时才会去实际拷贝这些数据。我们可能需要在绘制额外数据到位图图形上下文之前使用结果数据或者释放它们，以便我们可以避免实际去拷贝这些数据。</p>
<p>如何创建一个位图图形上下文，可以参考”创建图形上下文”相关的内容。</p>
<h2 id="创建一个图像遮罩"><a href="#创建一个图像遮罩" class="headerlink" title="创建一个图像遮罩"></a>创建一个图像遮罩</h2><p>一个Quartz位图图像遮罩如同艺术家使用丝网印刷品(silkscreen)一样。一个位图图像遮罩定义了如何转换颜色，而不是使用哪些颜色。图像遮罩中的每个采样值指定了在特定位置中，当前填充颜色值被遮罩的数量。采样值指定了遮罩的不透明度。值越大，表示越不透明，Quartz在指定位置绘制的颜色越少。我们可以将采样值当成alpha值的反转。1表示透明的，而0表示不透明。</p>
<p>图像遮罩的每个分量可能是1，2，4或者8位。对于1-bit的遮罩，采样值1指定遮罩的区域掩盖了当前的填充颜色。值为0表示当绘制遮罩时，显示当前的填充颜色。我们可以将1-bit遮罩当成黑色和白色；要么完全遮挡，要么完全显示。</p>
<p>每个分量中有2，4，8位的图像遮罩代表灰度值。每个分量使用以下的公式将值映射到[0, 1]之间的值：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inline_equations.jpg" alt="image"></p>
<p>例如，一个4-bit的遮罩其值位于[0, 1]之间，且增长的步长为1/15。0和1这两个值分别是最小和最大值–分别表示完全遮盖或完全透明。0和1之间的值使用(1-MaskSampleValue)这个公式来处理局部绘制。例如，如果一个8-bit遮罩的采样值设置为0.7，则那些alpha值为(1-0.7)，即0.3的颜色将会被绘制。</p>
<p>函数CGImageMaskCreate从我们提供的位图图像信息中创建一个Quartz图像遮罩。我们提供的信息与创建图像所提供的信息是一样的，只是不需要提供颜色空间信息，位图信息常量或渲染意图，我们可以从代码清单11-2中看到这个函数原型：</p>
<p><strong>Listing 11-2  The prototype for the function CGImageMaskCreate</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGImageRef <span class="title">CGImageMaskCreate</span> <span class="params">(</span></span></div><div class="line">        <span class="keyword">size_t</span> width,</div><div class="line">        <span class="keyword">size_t</span> height,</div><div class="line">        <span class="keyword">size_t</span> bitsPerComponent,</div><div class="line">        <span class="keyword">size_t</span> bitsPerPixel,</div><div class="line">        <span class="keyword">size_t</span> bytesPerRow,</div><div class="line">        CGDataProviderRef provider,</div><div class="line">        <span class="keyword">const</span> CGFloat decode[],</div><div class="line">        <span class="keyword">bool</span> shouldInterpolate</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="遮罩图像"><a href="#遮罩图像" class="headerlink" title="遮罩图像"></a>遮罩图像</h2><p>遮罩技术可以让我们通过控制图片的哪一部分被绘制，以生成很多有趣的效果，我们可以：</p>
<ol>
<li>在一个图像上使用图像遮罩。我们也可以把一个图像作为遮罩图，以获取同使用图像遮罩相反的效果。</li>
<li>使用颜色来遮罩图像的一部分，其中包含被称为颜色遮罩的技术</li>
<li>将图形上下文剪切到一个图像或图像遮罩，当Quartz绘制内容到剪切的图形上下文时来遮罩一个图像。</li>
</ol>
<h3 id="使用一个图像遮罩来遮罩图像"><a href="#使用一个图像遮罩来遮罩图像" class="headerlink" title="使用一个图像遮罩来遮罩图像"></a>使用一个图像遮罩来遮罩图像</h3><p>函数CGImageCreateWithMask通过将图像遮罩使用到一个图像上的方式来创建一个图像。这个函数带有两个参数：</p>
<ol>
<li>原始图像，遮罩将用于其上。这个图像不能是图像遮罩，也不能有与之相关的遮罩颜色。</li>
<li>一个图像遮罩，通过调用CGImageMaskCreate函数创建的。也可以提供一个图像来替代图像遮罩，但这将给出非常不同的结果。这将在下面描述。</li>
</ol>
<p>一个图像遮罩的采样如同一个反转的alpha值。一个图像遮罩采样值(S)：</p>
<ol>
<li>为1时，则不会绘制对应的图像样本。</li>
<li>为0时，则允许完全绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为(1-S)。</li>
</ol>
<p>图11-5显示了一个由Quartz图像创建函数创建的图像，而图11-6显示了一个使用CGImageMaskCreate函数创建的图像遮罩。图11-7则显示了一个使用CGImageCreateWithMask函数将图像遮罩应用于一个图像的效果。</p>
<p><strong>Figure 11-5  The original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers.gif" alt="image"></p>
<p><strong>Figure 11-6  An image mask</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tiger_mask.gif" alt="image"></p>
<p>注意，源图像中与遮罩黑色区域对应的区域绘制出来，而与白色区域对应的部分则没有绘制出来。而与遮罩灰色区域对应的区域则使用一个与(1-图像遮罩采样值)相同的alpha值来绘制。</p>
<p><strong>Figure 11-7  The image that results from applying the image mask to the original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_create_w_mask.gif" alt="image"></p>
<h3 id="使用一个图像来遮罩一个图像"><a href="#使用一个图像来遮罩一个图像" class="headerlink" title="使用一个图像来遮罩一个图像"></a>使用一个图像来遮罩一个图像</h3><p>我们可以使用函数CGImageCreateWithMask来用一个图像遮罩另一个图像，而不是使用一个图像遮罩。我们可以使用这种方式来达到与使用图像遮罩相反的效果。那此时我们传递给CGImageCreateWithMask函数的就不是一个图像遮罩了，而是传递一个通过Quartz图像创建函数创建的图像。</p>
<p>用于遮罩的图像的采样也是操作alpha值。一个图像采样值(S)：</p>
<ol>
<li>为1时，则允许完全绘制对应的图像样本。</li>
<li>为0时，则不会绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为S。</li>
</ol>
<p>图11-8显示了调用CGImageCreateWithMask函数将图11-6中的图像作为遮罩应用于图11-5中的图像上的效果。在这个例子中，我们假定图11-6中的图像是使用Quartz图像创建函数(如CGImageCreate)创建的。比较图11-8与图11-7，可以看出使用图像采样时，可以获取与使用图像遮罩采样相反的效果。</p>
<p>在图11-8的结果图像中，源图像中与图像的黑色区域对应的区域没有绘制出来。与白色区域对应的区域则绘制出来了。在遮罩中与灰色区域对应的区域则使用与遮罩图像采样值相同的alpha值来绘制。</p>
<p><strong>Figure 11-8  The image that results from masking the original image with an image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_mask_image.gif" alt="image"></p>
<h3 id="使用颜色来遮罩图像"><a href="#使用颜色来遮罩图像" class="headerlink" title="使用颜色来遮罩图像"></a>使用颜色来遮罩图像</h3><p>函数CGImageCreateWithMaskingColors通过遮罩一种颜色或一个颜色范围内的颜色来创建一个图像。使用这个函数，我们可以执行如图11-9所示的颜色遮罩，当然也可以遮罩一个范围内的颜色，如图11-11、11-12和11-13所示的效果。</p>
<p>函数CGImageCreateWithMaskingColors有两个参数：</p>
<ol>
<li>一个图像，它不能是遮罩图像，也不能是使用过图像遮罩或颜色遮罩的图像。</li>
<li>一个颜色分量数组，指定了一个颜色或一组颜色值，以用于遮罩图像。</li>
</ol>
<p><strong>Figure 11-9  Chroma key masking</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/chroma_key.gif" alt="image"></p>
<p>颜色分量数组中元素的个数必须等于图像所在颜色空间的颜色分量数目的两倍。对于颜色空间中的每一个颜色分量，提供一个最小值和一个最大值来限定遮罩颜色的范围。如果只使用一个颜色，则设置最大值等于最小值即可。颜色分量数组中的值按以下顺序来提供：</p>
<pre><code>{min[1], max[1], ... min[N], max[N]}，其中N是分量的数目
</code></pre><p>如果图像使用整型像素分量，则颜色分量数组中的每个值必须在[0 .. 2^bitsPerComponent - 1]范围之内。如果图像使用浮点像素分量，则值可以是表示任何有效的颜色分量值的浮点数。</p>
<p>一个图像采样如果其颜色值在以下范围内，则不会被绘制：</p>
<pre><code>{c[1], ... c[N]}，其中min[i] &lt;= c[i] &lt;= max[i] for 1 &lt;= i &lt;= N
</code></pre><p>图11-10中两只老虎的图像使用了每个分量有8位的RGB颜色空间。为了在这个图像上屏蔽一组颜色，我们提供一组在[0, 255]区间内的最小和最大颜色分量值。</p>
<p><strong>Figure 11-10  The original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers1.gif" alt="image"></p>
<p>代码清单11-3演示了如何设置颜色分量数组，并将其提供给CGImageCreateWithMaskingColors函数以达到图11-11的效果。</p>
<p><strong>Listing 11-3  Masking light to mid-range brown colors in an image</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGImageRef myColorMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123;<span class="number">124</span>, <span class="number">255</span>,  <span class="number">68</span>, <span class="number">222</span>, <span class="number">0</span>, <span class="number">165</span>&#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextDrawImage (context, myContextRect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-11  An image with light to midrange brown colors masked out</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/beige_brown_masking.gif" alt="image"></p>
<p>代码清单11-14同样操作图11-10并得到图11-12的效果。这个例子遮罩了一组暗色。</p>
<p><strong>Listing 11-4  Masking shades of brown to black</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGImageRef myMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">124</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextDrawImage (context, myContextRect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-12  A image after masking colors from dark brown to black</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/brown_black_masking_colors.gif" alt="image"></p>
<p>我们同样可以设置一个填充颜色来作为图像的遮罩颜色，以达到图11-13的效果，其中被遮罩区域使用了填充颜色。代码清单11-15演示了这一过程</p>
<p><strong>Listing 11-5  Masking a range of colors and setting a fill color and</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGImageRef myMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">124</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextSetRGBFillColor (myContext, <span class="number">0.6373</span>,<span class="number">0.6373</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">CGContextFillRect(context, rect);</div><div class="line">CGContextDrawImage(context, rect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-13  An image drawn after masking a range of colors and setting a fill color</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/fill_color_with_mask.gif" alt="image"></p>
<h3 id="通过裁减上下文来遮罩一个图片"><a href="#通过裁减上下文来遮罩一个图片" class="headerlink" title="通过裁减上下文来遮罩一个图片"></a>通过裁减上下文来遮罩一个图片</h3><p>函数CGContextClipToMask将遮罩映射为一个矩形并将其与图形上下文的当前裁减区域求个交集。我们提供以下参数：</p>
<ol>
<li>需要裁减的图形上下文</li>
<li>要使用遮罩的矩形区域</li>
<li>一个图像遮罩，其通过CGImageMaskCreate函数创建。我们可以使用图像来替代图像遮罩以达到相反的效果。但图像必须使用Quartz图像创建函数来创建，但不能是使用过图像遮罩或颜色遮罩的图像。</li>
</ol>
<p>裁减区域的结果依赖于是否提供了一个图像遮罩或图像给CGContextClipToMask函数。</p>
<p>我们看看图11-14.假设它是通过调用CGImageMaskCreate函数创建的一个图像遮罩，然后将其作为CGContextClipToMask函数的参数。结果上下文允许绘制黑色区域，而不绘制白色区域，并使用(1-S)的alpha值来绘制灰色区域，其中S是图像遮罩的采样值。如果使用CGContextDrawImage函数来将一个图像绘制到裁减上下文，则可以获得图11-15所示的结果。</p>
<p><strong>Figure 11-14  A masking image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/the_mask.gif" alt="image"></p>
<p><strong>Figure 11-15  An image drawn to a context after clipping the content with an image mask</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/mask_as_mask.gif" alt="image"></p>
<p>当遮罩图像被当成一个图像时，可以获得相反的结果，如图11-16所示：</p>
<p><strong>Figure 11-16  An image drawn to a context after clipping the content with an image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inverse_mask_clip.gif" alt="image"></p>
<h2 id="在图像中使用混合模式"><a href="#在图像中使用混合模式" class="headerlink" title="在图像中使用混合模式"></a>在图像中使用混合模式</h2><p>此处略，类似于在颜色中使用混合模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/11/quartz2d-10/" itemprop="url">
                  Quartz 2D编程指南之十：Quartz 2D中的数据管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-11T09:19:08+08:00" content="2014-12-11">
              2014-12-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>管理数据是每一个图形应用程序所需要处理的工作。对于Quartz来说，数据管理涉及为Quartz 2D程序提供数据，及从中获取数据。一些Quartz 2D程序将数据传输到Quartz中，如从文件或程序其它部分获取图片或PDF数据。另一些程序则获取Quartz数据，如将图像或PDF数据写入到文件，或提供给程序其它部分这些数据。</p>
<p>Quartz提供了一系列的函数来管理数据。通过学习本章，我们可以了解到哪些函数是最适合我们的程序的。</p>
<blockquote>
<p>注：我们推荐使用图像I/O框架来读取和写入数据，该框架在iOS 4、Mac OS X 10.4或者更高版本中可用。查看《Image I/OProgramming Guide 》可以获取更多关于CGImageSourceRef和CGImageDestinationRef的信息。图像源和目标不仅提供了访问图像数据的方法，不提供了更多访问图像原数据的方法。</p>
</blockquote>
<p>Quartz可识别三种类型的数据源和目标：</p>
<ol>
<li>URL：通过URL指定的数据可以作为数据的提供者和接收者。我们使用Core Foundation数据类型CFURLRef作为参数传递给Quartz函数。</li>
<li>CFData：Core Foundation数据类型CFDataRef和CFMutableDataRef可简化Core Foundation对象的内存分配行为。CFData是一个”toll-freebridged”类，CocoaFoundation中对应的类是NSData；如果在Quartz 2D中使用Cocoa框架，你可以传递一个NSData对象给Quartz方法，以取代CFData对象。</li>
<li>原始数据：我们可以提供一个指向任何类型数据的指针，连同处理这些数据基本内存管理的回调函数集合。</li>
</ol>
<p>这些数据，无论是URL、CFData对象，还是数据缓存，都可以是图像数据或PDF数据。图像数据可以是任何格式的数据。Quartz能够解析大部分常用的图像文件格式。一些Quartz数据管理函数专门用于处理图像数据，一些只处理PDF数据，还有一些可同时处理PDF和图像数据。</p>
<p>URL，CFData和原始数据源和目标中的数据都是在Mac OS X 或者iOS图像领域范围之外的，如图10-1所示。Mac OS X或iOS的其它图像技术通常会提供它们自己的方式来和Quartz通信。例如，一个Mac OS X 应用程序可以传输一个Quartz图像给Core Image，并使用Core Image来实现更复杂的效果。</p>
<p><strong>Figure 10-1  Moving data to and from Quartz 2D in Mac OS X</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/movingdata.gif" alt="image"></p>
<h2 id="传输数据给Quartz-2D"><a href="#传输数据给Quartz-2D" class="headerlink" title="传输数据给Quartz 2D"></a>传输数据给Quartz 2D</h2><p>表10-1列出了从数据源获取数据的方法。所有的这些函数，除了CGPDFDocumentCreateWithURL，都返回一个图像源(CGImageSourceRef)或者数据提供者(CGDataProviderRef)。图像源和数据提供者抽象了数据访问工作，并避免了程序去管理原始内存缓存。</p>
<p>图像源是将图像数据传输给Quartz的首先方式。图像源可表示很多种图像数据。一个图像源可表示多于一个图像，也可表示缩略图、图像的属性和图像文件。当我们拥有CGImageSourceRef对象后，我们可以完成如下工作：</p>
<ol>
<li>使用函数CGImageSourceCreateImageAtIndex,CGImageSourceCreateThumbnailAtIndex, CGImageSourceCreateIncremental创建图像(CGImageRef). 一个CGImageRef数据类型表示一个单独的Quartz图像。</li>
<li>通过函数CGImageSourceUpdateData或CGImageSourceUpdateDataProvider来添加内容到图像源中。</li>
<li>使用函数CGImageSourceGetCount, CGImageSourceCopyProperties和CGImageSourceCopyTypeIdentifiers获取图像源的信息。</li>
</ol>
<p>CFPDFDocumentCreateWithURL函数可以方便地从URL指定的文件创建PDF文档。</p>
<p>数据提供者是比较老的机制，它有很多限制。它们可用于获取图像或PDF数据。</p>
<p>我们可以将数据提供者用于：</p>
<ol>
<li>一个图像创建函数，如CGImageCreate,CGImageCreateWithPNGDataProvider或者CGImageCreateWithJPEGDataProvider。</li>
<li>PDF文档的创建函数CGPDFDocumentCreateWithProvider.</li>
<li>函数CGImageSourceUpdateDataProvider用于更新已存在的图像源。</li>
</ol>
<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>
<p><strong>Table 10-1  Functions that move data into Quartz 2D</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table10-1.png?raw=true" alt="image"></p>
<h2 id="获取Quartz-2D的数据"><a href="#获取Quartz-2D的数据" class="headerlink" title="获取Quartz 2D的数据"></a>获取Quartz 2D的数据</h2><p>表10-2列出地从Quartz 2D中获取数据的方法。所有这些方法，除了CGPDFContextCreateWithURL，都返回一个图像目标(CGImageDestinationRef)或者是数据消费者(CGDataComsumerRef)。图像目标和数据消费者抽象的数据写入工作，让Quartz来处理细节。</p>
<p>一个图像目标是获取Quartz数据的首先方法。与图像源一样，图像目标也可以表示很多图像数据，如一个单独图片、多个图片、缩略图、图像属性或者图片文件。在获取到CGImageDestinationRef后，我们可以完成以下工作：</p>
<ol>
<li>使用函数CGImageDestinationAddImage或者CGImageDestinationAddImageFromSource添加一个图像(CGImageRef)到目标中。一个CGImageRef表示一个图片。</li>
<li>使用函数CGImageDestinationSetProperties设置属性</li>
<li>使用函数CGImageDestinationCopyTypeIdentifiers和CGImageDestinationGetTypeID从图像目标中获取信息。</li>
</ol>
<p>函数CGPDFContextCreateWithURL可以方便地将PDF数据写入URL指定的位置。</p>
<p>数据消费者是一种老的机制，有很多限制。它们用于写图像或PDF数据。我们可以将数据消费者用于：</p>
<ol>
<li>PDF上下文创建函数CGPDFContextCreate。该函数返回一个图形上下文，用于记录一系列的PDF绘制命令。</li>
<li>函数CGImageDestinationCreateWithDataConsumer，用于从数据消费者中创建图像目标。</li>
</ol>
<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>
<p><strong>Table 10-2  Functions that move data out of Quartz 2D</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table10-2.png?raw=true" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/10/quartz2d-9/" itemprop="url">
                  Quartz 2D编程指南之九：透明层
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-10T09:13:04+08:00" content="2014-12-10">
              2014-12-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>透明层(TransparencyLayers)通过组合两个或多个对象来生成一个组合图形。组合图形被看成是单一对象。当需要在一组对象上使用特效时，透明层非常有用，如图9-1所示的给三个圆使用阴影的效果。</p>
<p><strong>Figure 9-1  Three circles as a composite in a transparency layer</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer1.gif" alt="image"></p>
<p>如果没有使用透明层来渲染图9-1中的三个圆，对它们使用阴影的效果将是如图9-2所示：</p>
<p><strong>Figure 9-2  Three circles painted as separate entities</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer2.gif" alt="image"> </p>
<h2 id="透明层的工作方式"><a href="#透明层的工作方式" class="headerlink" title="透明层的工作方式"></a>透明层的工作方式</h2><p>Quartz的透明层类似于许多流行的图形应用中的层。层是独立的实体。Quartz维护为每个上下文维护一个透明层栈，并且透明层是可以嵌套的。但由于层通常是栈的一部分，所以我们不能单独操作它们。</p>
<p>我们通过调用函数CGContextBeginTransparencyLayer来开始一个透明层，该函数需要两个参数：图形上下文与CFDictionary对象。字典中包含我们所提供的指定层额外信息的选项，但由于Quartz 2D API中没有使用字典，所以我们传递一个NULL。在调用这个函数后，图形状态参数保持不变，除了alpha值[默认设置为1]、阴影[默认关闭]、混合模式[默认设置为normal]、及其它影响最终组合的参数。</p>
<p>在开始透明层操作后，我们可以绘制任何想显示在层上的对象。指定上下文中的绘制操作将被当成一个组合对象绘制到一个透明背景上。这个背景被当作一个独立于图形上下文的目标缓存。</p>
<p>当绘制完成后，我们调用函数CGContextEndTransparencyLayer。Quartz将结合对象放入上下文，并使用上下文的全局alpha值、阴影状态及裁减区域作用于组合对象。</p>
<h2 id="在透明层中进行绘制"><a href="#在透明层中进行绘制" class="headerlink" title="在透明层中进行绘制"></a>在透明层中进行绘制</h2><p>在透明层中绘制需要三步：</p>
<ol>
<li>调用函数CGContextBeginTransparencyLayer</li>
<li>在透明层中绘制需要组合的对象</li>
<li>调用函数CGContextEndTransparencyLayer</li>
</ol>
<p>图9-3显示了在透明层中绘制三个矩形，其中将这三个矩形当成一个整体来渲染阴影。</p>
<p><strong>Figure 9-3  Three rectangles painted to a transparency layer</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_code.gif" alt="image"></p>
<p>代码清单9-1显示了如何利用透明层生成图9-3所示的矩形。</p>
<p><strong>Listing 9-1  Painting to a transparency layer</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawTransparencyLayer</span> <span class="params">(CGContext myContext, <span class="keyword">float</span> wd,<span class="keyword">float</span> ht)</span></span></div><div class="line">&#123;</div><div class="line">    CGSize myShadowOffset = CGSizeMake (<span class="number">10</span>, <span class="number">-20</span>);</div><div class="line">    CGContextSetShadow (myContext, myShadowOffset, <span class="number">10</span>);   </div><div class="line">    CGContextBeginTransparencyLayer (myContext, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Your drawing code here</span></div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span>+ <span class="number">50</span>,ht/<span class="number">2</span> ,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span><span class="number">-50</span>,ht/<span class="number">2</span><span class="number">-100</span>,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span>,ht/<span class="number">2</span><span class="number">-50</span>,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextEndTransparencyLayer (myContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/10/quartz2d-8/" itemprop="url">
                  Quartz 2D编程指南之八：渐变
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-10T09:00:26+08:00" content="2014-12-10">
              2014-12-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Quartz提供了两个不透明数据odgago创建渐变：CGShadingRef和CGGradientRef。我们可以使用任何一个来创建轴向(axial)或径向(radial)渐变。一个渐变是从一个颜色到另外一种颜色的填充。</p>
<p>一个轴向渐变(也称为线性渐变)沿着由两个端点连接的轴线渐变。所有位于垂直于轴线的某条线上的点都具有相同的颜色值。</p>
<p>一个径向渐变也是沿着两个端点连接的轴线渐变，不过路径通常由两个圆来定义。</p>
<p>本章提供了一些我们使用Quartz能够创建的轴向和径向渐变的类型的例子，并比较绘制渐变的两种方法，然后演示了如何使用每种不透明数据类型来创建渐变。</p>
<h2 id="轴向和径向渐变实例"><a href="#轴向和径向渐变实例" class="headerlink" title="轴向和径向渐变实例"></a>轴向和径向渐变实例</h2><p>Quartz函数提供了一个丰富的功能来创建渐变效果。这一部分显示了一些我们能达到的效果。图8-1中的轴向渐变由橙色向黄色渐变。在这个例子中，渐变轴相对于原点倾斜了45度角。</p>
<p><strong>Figure 8-1  An axial gradient along a 45 degree axis</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_color_gradient.jpg" alt="image"></p>
<p>Quartz也允许我们指定一系列的颜色和位置值，以沿着轴来创建更复杂的轴向渐变，如图8-2所示。起始点的颜色值是红色，结束点的颜色是紫罗兰色。同时，在轴上有五个位置，它们的颜色值分别被设置为橙、黄、绿、蓝和靛蓝。我们可以把它看成沿着同一轴线的六段连续的线性渐变。虽然这里的轴线与图8-1是一样的，但这不是必须的。轴线的角度由我们提供的两个端点定义。</p>
<p><strong>Figure 8-2  An axial gradient created with seven locations and colors</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rainbow_gradient.jpg" alt="image"></p>
<p>图8-3显示了一个径向渐变，它从一个小的明亮的红色圆渐变到一个大小黑色的圆。</p>
<p><strong>Figure 8-3  A radial gradient that varies between two circles</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/cylinder6.gif" alt="image"></p>
<p>使用Quartz，我们不局限于创建颜色值改变的渐变；我们可以只修改alpha值，或者创建alpha值与其它颜色组件一起改变的渐变。图8-4显示了一个渐变，其红、绿、蓝组件的值是不变的，但alpha值从1.0渐变到0.1。</p>
<p>注意：如果我们使用alpha值来改变一个渐变，则在绘制一个PDF内容时我们不能捕获这个渐变。因此，这样的渐变无法打印。如果需要绘制一个渐变到PDF，则需要让alpha值为1.0。</p>
<p><strong>Figure 8-4  A radial gradient created by varying only the alpha component</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/alpha_only.jpg" alt="image"></p>
<p>我们可以把一个圆放置到一个径向渐变中来创建各种形状。如果一个圆是另一个的一部分或者完全在另一个的外面，则Quartz创建了圆锥和一个圆柱。径向渐变的一个通常用法就是创建一个球体阴影，如图8-5所示。在这种情况下，一个单一的点(半径为0的圆)位于一个大圆以内。</p>
<p><strong>Figure 8-5  A radial gradient that varies between a point and a circle</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/shaded_sphere.gif" alt="image"></p>
<p>我们可以像图8-6一样通过内嵌几个径向渐变来创建更复杂的效果。它使用同心圆来创建图形中的各环形部分。</p>
<p><strong>Figure 8-6  Nested radial gradients</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/torus.gif" alt="image"></p>
<h2 id="CGShading和CGGradient对象的对比"><a href="#CGShading和CGGradient对象的对比" class="headerlink" title="CGShading和CGGradient对象的对比"></a>CGShading和CGGradient对象的对比</h2><p>我们有两个对象类型用于创建渐变，你可能想知道哪一个更好用。本节就来回答这个问题。</p>
<p>CGShadingRef这个不透明数据类型给我们更多的控制权，以确定如何计算每个端点的颜色。在我们创建CGShading对象之前，我们必须创建一个CGFunction对象(CGFunctionRef)，这个对象定义了一个用于计算渐变颜色的函数。写一个自定义的函数让我们能够创建平滑的渐变，如图8-3，8-3和8-5及更多非传统的效果，如图8-12所示。</p>
<p>当创建一个CGShading对象时，我们指定其是轴向还是径向。除了计算函数外，我们还需要提供一个颜色空间、起始点和结束点或者是半径，这取决于是绘制轴向还是径向渐变。在绘制时，我们只是简单地传递CGShading对象及绘制上下文给CGContextDrawShading函数。Quartz为渐变上的每个点调用渐变计算函数。</p>
<p>一个CGGradient对象是CGShading对象的子集，其更易于使用。CGGradientRef不透明类型易于作用，因为Quartz在渐变的每一个顶点上计算颜色值。我们不需要提供一个渐变计算函数。当创建一个渐变对象时，我们提供一个位置和颜色的数组。Quartz使用对应的颜色值来计算每个梯度的渐变，。我们可以使用单一的起始与结束点来设置一个渐变对象，如图8-1所示，或者提供一组端点来创建一个类似于图8-2的的效果。使用CGShading对象可以提供多于两个位置的能力。</p>
<p>当我们创建一个CGGradient对象时，我们需要设置一个颜色空间、位置、和每个位置对应的颜色值。当使用一个渐变对象绘制上下文时，我们指定Quartz是绘制一个轴向还是径向渐变。在绘制时，我们指定开始结束点或半径，这取决于我们是绘制轴向还是径向渐变。而CGShading的几何形状是在创建时定义的，而不是绘制时。</p>
<p>表8-1总结了两种不透明数据类型之间的区别。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table8-1.png?raw=true" alt="image"></p>
<h2 id="扩展渐变端点外部的颜色"><a href="#扩展渐变端点外部的颜色" class="headerlink" title="扩展渐变端点外部的颜色"></a>扩展渐变端点外部的颜色</h2><p>当我们创建一个渐变时，我们可以选择使用纯色来填充渐变端点外部的空间。Quartz使用使用渐变边界上的颜色作为填充颜色。我们可以扩展渐变起点、终点或两端的颜色。我们可以扩展使用CGShading对象或CGGradient对象创建的轴向或径向渐变。</p>
<p>图8-7演示了一个轴向渐变，它扩展了起点和终点两侧的区域。图片中的线段显示了渐变的轴线。我们可以看到，填充颜色与起点和终点的颜色是对应的。</p>
<p><strong>Figure 8-7  Extending an axial gradient</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/extend_axial2.gif" alt="image"></p>
<p>图8-8对比了一个未使用扩展的径向渐变和一个在起点和终点两侧使用扩展的径向渐变。Quartz获取了起点和终点的颜色值，并使用这边纯色值来扩展立面。</p>
<p><strong>Figure 8-8  Extending a radial gradient</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/extend_radial.gif" alt="image"></p>
<h2 id="使用CGGradient对象"><a href="#使用CGGradient对象" class="headerlink" title="使用CGGradient对象"></a>使用CGGradient对象</h2><p>一个CGGradient对象是一个渐变的抽象定义–它简单地指定了颜色值和位置，但没有指定几何形状。我们可以在轴向和径向几何形状中使用这个对象。作为一个抽象定义，CGGradient对象可能比CGShading对象更容易重用。没有将几何形状存储在CGGradient对象中，这样允许我们使用相同的颜色方案来绘制不同的几何图形，而不需要为多个图形创建多个CGGradient对象。</p>
<p>因为Quartz为我们计算渐变，使用一个CGGradient对象来创建和绘制一个渐变则更直接，只需要以下几步：</p>
<ol>
<li>创建一个CGGradient对象，提供一个颜色空间，一个饱含两个或更多颜色组件的数组，一个包含两个或多个位置的数组，和两个数组中元素的个数。</li>
<li>调用CGContextDrawLinearGradient或CGContextDrawRadialGradient函数并提供一个上下文、一个CGGradient对象、绘制选项和开始结束几何图形来绘制渐变。</li>
<li>当不再需要时释放CGGradient对象。</li>
</ol>
<p>一个位置是一个值区间在0.0到1.0之间的CGFloat值，它指定了沿着渐变的轴线的标准化距离。值0.0指定的轴线的起点，1.0指定了轴线的终点。其它的值指定了一个距离的比例。最低限度情况下，Quartz使用两个位置值。如果我们传递NULL值作为位置数组参数，则Quartz使用0作为第一个位置，1作为第二个位置。</p>
<p>每个颜色的颜色组件的数目取决于颜色空间。对于离屏绘制，我们使用一个RGB颜色空间。因为Quartz使用alpha来绘制，每个离屏颜色都有四个组件–红、绿、蓝和alpha。所以，对于离屏绘制，我们提供的颜色组件数组的元素的数目必须是位置数目的4倍。Quartz的RGBA颜色组件可以在0.0到1.0之间改变。</p>
<p>代码清单8-1是创建一个CGGradient对象的代码片断。在声明了必须的变量后，代码设置了位置和颜色组件数组。然后创建了一个通用的RGB颜色空间。(在iOS中，不管RGB颜色空间是否可用，我们都应该调用CGColorSpaceCreateDeviceRGB)。然后，它传递必要的参数到CGGradientCreateWithColorComponents函数。我们同样可以使用CGGradientCreateWithColors，如果我们的程序设置了CGColor对象，这是一种便捷的方法。</p>
<p><strong>Listing 8-1  Creating a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CGGradientRef myGradient;</div><div class="line">CGColorSpaceRef myColorspace;</div><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">2</span>;</div><div class="line">CGFloat locations[<span class="number">2</span>] = &#123; <span class="number">0.0</span>, <span class="number">1.0</span> &#125;;</div><div class="line">CGFloat components[<span class="number">8</span>] = &#123; <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">1.0</span>,  <span class="comment">// Start color</span></div><div class="line">                          <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.3</span>, <span class="number">1.0</span> &#125;; <span class="comment">// End color</span></div><div class="line"> </div><div class="line">myColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">myGradient = CGGradientCreateWithColorComponents (myColorspace, components,</div><div class="line">                          locations, num_locations);</div></pre></td></tr></table></figure>
<p>在创建了CGGradient对象后，我们可以使用它来绘制一个轴向或线性渐变。代码清单8-2声明并设置了线性渐变的起始点然后绘制渐变。图8-1显示了结果。代码没有演示如何获取CGContext对象。</p>
<p><strong>Listing 8-2  Painting an axial gradient using a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">myStartPoint.x = <span class="number">0.0</span>;</div><div class="line">myStartPoint.y = <span class="number">0.0</span>;</div><div class="line">myEndPoint.x = <span class="number">1.0</span>;</div><div class="line">myEndPoint.y = <span class="number">1.0</span>;</div><div class="line">CGContextDrawLinearGradient (myContext, myGradient, myStartPoint, myEndPoint, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>代码清单8-3使用代码清单8-1中创建的CGGradient对象来绘制图8-9中径向渐变。这个例子同时也演示了使用纯色来填充渐变的扩展区域。</p>
<p><strong>Listing 8-3  Painting a radial gradient using a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">CGFloat myStartRadius, myEndRadius;</div><div class="line">myStartPoint.x = <span class="number">0.15</span>;</div><div class="line">myStartPoint.y = <span class="number">0.15</span>;</div><div class="line">myEndPoint.x = <span class="number">0.5</span>;</div><div class="line">myEndPoint.y = <span class="number">0.5</span>;</div><div class="line">myStartRadius = <span class="number">0.1</span>;</div><div class="line">myEndRadius = <span class="number">0.25</span>;</div><div class="line">CGContextDrawRadialGradient (myContext, myGradient, myStartPoint,</div><div class="line">                         myStartRadius, myEndPoint, myEndRadius,</div><div class="line">                         kCGGradientDrawsAfterEndLocation);</div></pre></td></tr></table></figure>
<p><strong>Figure 8-9  A radial gradient painted using a CGGradient object</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/radial_cggradient.jpg" alt="image"></p>
<p>图8-4中的径向渐变使用代码清单8-4中的变量来创建。</p>
<p><strong>Listing 8-4  The variables used to create a radial gradient by varying alpha</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">CGFloat myStartRadius, myEndRadius;</div><div class="line">myStartPoint.x = <span class="number">0.2</span>;</div><div class="line">myStartPoint.y = <span class="number">0.5</span>;</div><div class="line">myEndPoint.x = <span class="number">0.65</span>;</div><div class="line">myEndPoint.y = <span class="number">0.5</span>;</div><div class="line">myStartRadius = <span class="number">0.1</span>;</div><div class="line">myEndRadius = <span class="number">0.25</span>;</div><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">2</span>;</div><div class="line">CGFloat locations[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1.0</span> &#125;;</div><div class="line">CGFloat components[<span class="number">8</span>] = &#123; <span class="number">0.95</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">1.0</span>,</div><div class="line">                          <span class="number">0.95</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.1</span> &#125;;</div></pre></td></tr></table></figure>
<p>代码清单8-5显示了用于创建图8-10中的灰色渐变的变量，其中有3个位置。</p>
<p><strong>Listing 8-5  The variables used to create a gray gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">3</span>;</div><div class="line">CGFloat locations[<span class="number">3</span>] = &#123; <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>&#125;;</div><div class="line">CGFloat components[<span class="number">12</span>] = &#123;  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</div><div class="line">                            <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>,</div><div class="line">                            <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</div></pre></td></tr></table></figure>
<p><strong>Figure 8-10  An axial gradient with three locations</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/gray_gradient_3.jpg" alt="image"></p>
<h2 id="使用CGShading对象"><a href="#使用CGShading对象" class="headerlink" title="使用CGShading对象"></a>使用CGShading对象</h2><p>我们通过调用函数CGShadingCreateAxial或CGShadingCreateRadial创建一个CGShading对象来设置一个渐变，调用这些函数需要提供以下参数：</p>
<ol>
<li>CGColorSpace对象：颜色空间</li>
<li>起始点和终点。对于轴向渐变，有轴线的起始点和终点的坐标。对于径向渐变，有起始圆和终点圆中心的坐标。</li>
<li>用于定义渐变区域的圆的起始半径与终止半径。</li>
<li>一个CGFunction对象，可以通过CGFunctionCreate函数来获取。这个回调例程必须返回绘制到特定点的颜色值。</li>
<li>一个布尔值，用于指定是否使用纯色来绘制起始点与终点的扩展区域。</li>
</ol>
<p>我们提供给CGShading创建函数的CGFunction对象包含一个回调结构体，及Quartz需要实现这个回调的所有信息。也许设置CGShasing对象的最棘手的部分是创建CGFunction对象。当我们调用CGFunctionCreate函数时，我们提供以下参数： </p>
<ol>
<li>指向回调所需要的数据的指针</li>
<li>回调的输入值的个数。Quartz要求回调携带一个输入值。</li>
<li>一个浮点数的数组。Quartz只会提供数组中的一个元素给回调函数。一个转入值的范围是0(渐变的开始点的颜色)到1(渐变的结束点的颜色)。</li>
<li>回调提供的输出值的数目。对于每一个输入值，我们的回调必须为每个颜色组件提供一个值，以及一个alpha值来指定透明度。颜色组件值由Quartz提供的颜色空间来解释，并会提供给CGShading创建函数。例如，如果我们使用RGB颜色空间，则我们提供值4作为输出值(R,G,B,A)的数目。</li>
<li>一个浮点数的数组，用于指定每个颜色组件的值及alpha值。</li>
<li>一个回调数据结构，包含结构体的版本(设置为0)、生成颜色组件值的回调、一个可选的用于释放回调中info参数表示的数据。该回调类似于以下格式：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info, <span class="keyword">const</span> CGFloat *in, CGFloat *out)</span></span></div></pre></td></tr></table></figure>
<p>在创建CGShading对象后，如果需要我们可以设置额外的裁减操作。然后调用CGContextDrawShading函数来使用渐变来绘制上下文的裁减区域。当调用这个函数时，Quartz调用回调函数来获取从起点到终点这个范围内的颜色值。</p>
<p>当不再需要CGShading对象时，我们调用CGShadingRelease来释放它。</p>
<p>下面我们将一步步地通过代码来看看如何使用CGShading对象来绘制渐变。</p>
<h3 id="使用CGShading对象绘制一个轴向渐变"><a href="#使用CGShading对象绘制一个轴向渐变" class="headerlink" title="使用CGShading对象绘制一个轴向渐变"></a>使用CGShading对象绘制一个轴向渐变</h3><p>绘制轴向和径向渐变的步骤是差不多的。这个例子演示了如何使用一个CGShading对象来绘制一个轴向渐变，并在图形上下文中绘制一个半圆形的裁减路径，然后将渐变绘制到裁减区域来达到图8-11的效果。</p>
<p><strong>Figure 8-11  An axial gradient that is clipped and painted</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/axial_shading_arc.gif" alt="image"></p>
<p>为了绘制图中的轴向渐变，需要按以下步骤来处理：</p>
<ol>
<li>设置CGFunction对象来计算颜色值</li>
<li>创建轴向渐变的CGShading对象</li>
<li>裁减上下文</li>
<li>使用CGShading对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<h4 id="设置CGFunction对象来计算颜色值"><a href="#设置CGFunction对象来计算颜色值" class="headerlink" title="设置CGFunction对象来计算颜色值"></a>设置CGFunction对象来计算颜色值</h4><p>我们可以以我们想要的方式来计算颜色值，我们的颜色计算函数包含以下三个参数：</p>
<ol>
<li>void *info：这个值可以为NULL或者是一个指向传递给CGShading创建函数的数据。</li>
<li>const CGFloat *in：Quartz传递in数组给回调。数组中的值必须在为CGFunction对象定义的输入值范围内。例如，输入范围是0到1；看代码清单8-7</li>
<li>CGFloat *out：我们的回调函数传递out数组给Quartz。它包含用于颜色空间中每个颜色组件的元素及一个alpha值。输出值应该在CGFunction对象中定义的输出值的范围内，例如，输出范围是0到1；看代码清单8-7。</li>
</ol>
<p>更多关于参数的信息可以查看CGFunctionEvaluateCallback。</p>
<p>代码清单8-6演示了一个函数，它通过将一个常数数组中的值乘以输入值来计算颜色组件值。因为输入值在0到1之间，所以输入值位于黑色(对于RGB来说值为0, 0, 0)和紫色(1, 0, 0.5)之间。注意最后一个组件通常设置为1，表示颜色总是完全不透明的。</p>
<p><strong>Listing 8-6  Computing color component values</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info,</span></span></div><div class="line">                            <span class="keyword">const</span> CGFloat *in,</div><div class="line">                            CGFloat *out)</div><div class="line">&#123;</div><div class="line">    CGFloat v;</div><div class="line">    <span class="keyword">size_t</span> k, components;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat c[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">.5</span>, <span class="number">0</span> &#125;;</div><div class="line"> </div><div class="line">    components = (<span class="keyword">size_t</span>)info;</div><div class="line"> </div><div class="line">    v = *in;</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; components <span class="number">-1</span>; k++)</div><div class="line">        *out++ = c[k] * v;</div><div class="line">     *out++ = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在写完回调计算颜色值后，我们将其打包以作为CGFunction对象的一部分。代码清单显示了一个函数，它创建了一个包含代码清单8-6中的回调函数的CGFunction对象。</p>
<p><strong>Listing 8-7  Creating a CGFunction object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> CGFunctionRef <span class="title">myGetFunction</span> <span class="params">(CGColorSpaceRef colorspace)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> numComponents;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat input_value_range [<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat output_value_ranges [<span class="number">8</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFunctionCallbacks callbacks = &#123; <span class="number">0</span>,</div><div class="line">                                &amp;myCalculateShadingValues,</div><div class="line">                                <span class="literal">NULL</span> &#125;;</div><div class="line"> </div><div class="line">    numComponents = <span class="number">1</span> + CGColorSpaceGetNumberOfComponents (colorspace);</div><div class="line">    <span class="keyword">return</span> CGFunctionCreate ((<span class="keyword">void</span> *) numComponents,</div><div class="line">                                <span class="number">1</span>, </div><div class="line">                                input_value_range, </div><div class="line">                                numComponents, </div><div class="line">                                output_value_ranges, </div><div class="line">                                &amp;callbacks);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建一个轴向渐变的CGShading对象"><a href="#创建一个轴向渐变的CGShading对象" class="headerlink" title="创建一个轴向渐变的CGShading对象"></a>创建一个轴向渐变的CGShading对象</h4><p>为了创建一个CGShading对象，我们调用CGShadingCreateAxial函数，如代码清单8-8所示。我们传递一个颜色空间，开始点和结束点，一个CGFunction对象，和一个用于指定是否填充渐变的开始点和结束点扩展的布尔值。</p>
<p><strong>Listing 8-8  Creating a CGShading object for an axial gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CGPoint     startPoint,</div><div class="line">            endPoint;</div><div class="line">CGFunctionRef myFunctionObject;</div><div class="line">CGShadingRef myShading;</div><div class="line"> </div><div class="line">startPoint = CGPointMake(<span class="number">0</span>,<span class="number">0.5</span>);</div><div class="line">endPoint = CGPointMake(<span class="number">1</span>,<span class="number">0.5</span>);</div><div class="line">colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">myFunctionObject = myGetFunction (colorspace);</div><div class="line"> </div><div class="line">myShading = CGShadingCreateAxial (colorspace,</div><div class="line">                        startPoint, endPoint,</div><div class="line">                        myFunctionObject,</div><div class="line">                        <span class="literal">false</span>, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="裁减上下文"><a href="#裁减上下文" class="headerlink" title="裁减上下文"></a>裁减上下文</h4><p>当绘制一个渐变时，Quartz填充当前上下文。绘制一个渐变与操作颜色和模式不同，后者是用于描边或填充一个路径对象。因此，如果要我们的渐变出现在一个特定形状中，我们需要裁减上下文。代码清单8-9的代码添加了一个半圆形到当前上下文，以便渐变绘制到这个裁减区域，如图8-11。</p>
<p>如果我们仔细看，会发现代码绘制的是一个半圆，而图中显示的是一个半椭圆形。为什么呢？我们会看到，当我们查看后面完整的绘制代码时，上下文被缩放了。稍后会详细说明。虽然我们不需要使用缩放或裁减，这些在Quartz 2D中的选项可以帮助我们达到有趣的效果。</p>
<p><strong>Listing 8-9  Adding a semicircle clip to the graphics context</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGContextBeginPath (myContext);</div><div class="line">CGContextAddArc (myContext, <span class="number">.5</span>, <span class="number">.5</span>, <span class="number">.3</span>, <span class="number">0</span>,</div><div class="line">               my_convert_to_radians (<span class="number">180</span>), <span class="number">0</span>);</div><div class="line">CGContextClosePath (myContext);</div><div class="line">CGContextClip (myContext);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象来绘制轴向渐变"><a href="#使用CGShading对象来绘制轴向渐变" class="headerlink" title="使用CGShading对象来绘制轴向渐变"></a>使用CGShading对象来绘制轴向渐变</h4><p>调用函数CGContextDrawShading使用CGShading对象为指定的颜色渐变来填充当前上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawShading (myContext, myShading);</div></pre></td></tr></table></figure>
<h4 id="释放对象"><a href="#释放对象" class="headerlink" title="释放对象"></a>释放对象</h4><p>当我们不再需要CGShading对象时，可以调用函数CGShadingRelease来释放它。我们需要同时释放CGColorSpace对象和CGFunction对象，如代码清单8-10所示：</p>
<p><strong>Listing 8-10  Releasing objects</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGShadingRelease (myShading);</div><div class="line">CGColorSpaceRelease (colorspace);</div><div class="line">CGFunctionRelease (myFunctionObject);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象绘制轴向渐变的完整例程"><a href="#使用CGShading对象绘制轴向渐变的完整例程" class="headerlink" title="使用CGShading对象绘制轴向渐变的完整例程"></a>使用CGShading对象绘制轴向渐变的完整例程</h4><p>代码清单8-11显示了绘制一个轴向渐变的完整例程，使用8-7中的CGFunction对象和8-6中的回调函数。</p>
<p><strong>Listing 8-11  Painting an axial gradient using a CGShading object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPaintAxialShading</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                            CGRect bounds)</div><div class="line">&#123;</div><div class="line">    CGPoint     startPoint,</div><div class="line">                endPoint;</div><div class="line">    CGAffineTransform myTransform;</div><div class="line">    CGFloat width = bounds.size.width;</div><div class="line">    CGFloat height = bounds.size.height;</div><div class="line"> </div><div class="line"> </div><div class="line">    startPoint = CGPointMake(<span class="number">0</span>,<span class="number">0.5</span>); </div><div class="line">    endPoint = CGPointMake(<span class="number">1</span>,<span class="number">0.5</span>);</div><div class="line"> </div><div class="line">    colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    myShadingFunction = myGetFunction(colorspace);</div><div class="line"> </div><div class="line">    shading = CGShadingCreateAxial (colorspace, </div><div class="line">                                 startPoint, endPoint,</div><div class="line">                                 myShadingFunction,</div><div class="line">                                 <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line"> </div><div class="line">    myTransform = CGAffineTransformMakeScale (width, height);</div><div class="line">    CGContextConcatCTM (myContext, myTransform);</div><div class="line">    CGContextSaveGState (myContext);</div><div class="line"> </div><div class="line">    CGContextClipToRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line"> </div><div class="line">    CGContextBeginPath (myContext);</div><div class="line">    CGContextAddArc (myContext, <span class="number">.5</span>, <span class="number">.5</span>, <span class="number">.3</span>, <span class="number">0</span>,</div><div class="line">                        my_convert_to_radians (<span class="number">180</span>), <span class="number">0</span>);</div><div class="line">    CGContextClosePath (myContext);</div><div class="line">    CGContextClip (myContext);</div><div class="line"> </div><div class="line">    CGContextDrawShading (myContext, shading);</div><div class="line">    CGColorSpaceRelease (colorspace);</div><div class="line">    CGShadingRelease (shading);</div><div class="line">    CGFunctionRelease (myShadingFunction);</div><div class="line"> </div><div class="line">    CGContextRestoreGState (myContext); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用CGShading对象绘制一个径向渐变"><a href="#使用CGShading对象绘制一个径向渐变" class="headerlink" title="使用CGShading对象绘制一个径向渐变"></a>使用CGShading对象绘制一个径向渐变</h3><p>这个例子演示了如何使用CGShading对象来生成如图8-12所示的输出</p>
<p><strong>Figure 8-12  A radial gradient created using a CGShading object</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/radial_shading.gif" alt="image"></p>
<p>为了绘制一个径向渐变，我们需要按以下步骤来处理：</p>
<ol>
<li>设置CGFunction对象来计算颜色值</li>
<li>创建径向渐变的CGShading对象</li>
<li>使用CGShading对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<h4 id="设置CGFunction对象来计算颜色值-1"><a href="#设置CGFunction对象来计算颜色值-1" class="headerlink" title="设置CGFunction对象来计算颜色值"></a>设置CGFunction对象来计算颜色值</h4><p>计算径向渐变和轴向渐变颜色值的函数没有什么区别。事实上，我们可以依照上面的轴向的”设置CGFunction对象来计算颜色值”。代码清单8-12用于计算颜色，使用颜色按正弦变化。图8-12与图8-11的结果非常不同。虽然颜色输出值不同，代码清单8-12的代码与8-6中的函数遵循相同的原型。每个函数获取一个输入值并计算N个值，即颜色空间的每个颜色组件加一个alpha值。</p>
<p><strong>Listing 8-12  Computing color component values</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info,</span></span></div><div class="line">                                <span class="keyword">const</span> CGFloat *in,</div><div class="line">                                CGFloat *out)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> k, components;</div><div class="line">    <span class="keyword">double</span> frequency[<span class="number">4</span>] = &#123; <span class="number">55</span>, <span class="number">220</span>, <span class="number">110</span>, <span class="number">0</span> &#125;;</div><div class="line">    components = (<span class="keyword">size_t</span>)info;</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; components - <span class="number">1</span>; k++)</div><div class="line">        *out++ = (<span class="number">1</span> + <span class="built_in">sin</span>(*in * frequency[k]))/<span class="number">2</span>;</div><div class="line">     *out++ = <span class="number">1</span>; <span class="comment">// alpha</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在写完颜色计算函数后调用它，我们需要创建一个CGFunction对象，如在轴向中”设置CGFunction对象来计算颜色值”所描述的一样。</p>
<h4 id="创建径向渐变的CGShading对象"><a href="#创建径向渐变的CGShading对象" class="headerlink" title="创建径向渐变的CGShading对象"></a>创建径向渐变的CGShading对象</h4><p>为了创建一个CGShading对象或者一个径向渐变，我们调用CGShadingCreateRadial函数，如代码清单8-13所求，传递一个颜色空间、开始点和结束点，开始半径和结束半径，一个CGFunction对象，和一个用于指定是否填充渐变的开始点和结束点扩展的布尔值。</p>
<p><strong>Listing 8-13  Creating a CGShading object for a radial gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CGPoint startPoint, endPoint;</div><div class="line">CGFloat startRadius, endRadius;</div><div class="line"> </div><div class="line">startPoint = CGPointMake(<span class="number">0.25</span>,<span class="number">0.3</span>);</div><div class="line">startRadius = <span class="number">.1</span>;</div><div class="line">endPoint = CGPointMake(<span class="number">.7</span>,<span class="number">0.7</span>);</div><div class="line">endRadius = <span class="number">.25</span>;</div><div class="line">colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">myShadingFunction = myGetFunction (colorspace);</div><div class="line">CGShadingCreateRadial (colorspace,</div><div class="line">               startPoint,</div><div class="line">               startRadius,</div><div class="line">               endPoint,</div><div class="line">               endRadius,</div><div class="line">               myShadingFunction,</div><div class="line">               <span class="literal">false</span>,</div><div class="line">               <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象来绘制径向渐变"><a href="#使用CGShading对象来绘制径向渐变" class="headerlink" title="使用CGShading对象来绘制径向渐变"></a>使用CGShading对象来绘制径向渐变</h4><p>调用函数CGContextDrawShading使用CGShading对象为指定的颜色渐变来填充当前上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawShading (myContext, myShading);</div></pre></td></tr></table></figure>
<p>注意我们使用相同的函数来绘制渐变，而不管它是轴向还是径向。</p>
<h4 id="释放对象-1"><a href="#释放对象-1" class="headerlink" title="释放对象"></a>释放对象</h4><p>当我们不再需要CGShading对象时，可以调用函数CGShadingRelease来释放它。我们需要同时释放CGColorSpace对象和CGFunction对象，如代码清单8-14所示：</p>
<p><strong>Listing 8-10  Releasing objects</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGShadingRelease (myShading);</div><div class="line">CGColorSpaceRelease (colorspace);</div><div class="line">CGFunctionRelease (myFunctionObject);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象绘制径向渐变的完整例程"><a href="#使用CGShading对象绘制径向渐变的完整例程" class="headerlink" title="使用CGShading对象绘制径向渐变的完整例程"></a>使用CGShading对象绘制径向渐变的完整例程</h4><p>代码清单8-15显示了绘制一个轴径向渐变的完整例程，使用8-7中的CGFunction对象和8-12中的回调函数。</p>
<p><strong>Listing 8-15  A routine that paints a radial gradient using a CGShading object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPaintRadialShading</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                            CGRect bounds);</div><div class="line">&#123;</div><div class="line">    CGPoint startPoint,</div><div class="line">            endPoint;</div><div class="line">    CGFloat startRadius,</div><div class="line">            endRadius;</div><div class="line">    CGAffineTransform myTransform;</div><div class="line">    CGFloat width = bounds.size.width;</div><div class="line">    CGFloat height = bounds.size.height;</div><div class="line"> </div><div class="line">    startPoint = CGPointMake(<span class="number">0.25</span>,<span class="number">0.3</span>); </div><div class="line">    startRadius = <span class="number">.1</span>;  </div><div class="line">    endPoint = CGPointMake(<span class="number">.7</span>,<span class="number">0.7</span>); </div><div class="line">    endRadius = <span class="number">.25</span>; </div><div class="line"> </div><div class="line">    colorspace = CGColorSpaceCreateDeviceRGB(); </div><div class="line">    myShadingFunction = myGetFunction (colorspace);</div><div class="line"> </div><div class="line">    shading = CGShadingCreateRadial (colorspace, </div><div class="line">                            startPoint, startRadius,</div><div class="line">                            endPoint, endRadius,</div><div class="line">                            myShadingFunction,</div><div class="line">                            <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line"> </div><div class="line">    myTransform = CGAffineTransformMakeScale (width, height); </div><div class="line">    CGContextConcatCTM (myContext, myTransform); </div><div class="line">    CGContextSaveGState (myContext); </div><div class="line"> </div><div class="line">    CGContextClipToRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)); </div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line"> </div><div class="line">    CGContextDrawShading (myContext, shading); </div><div class="line">    CGColorSpaceRelease (colorspace); </div><div class="line">    CGShadingRelease (shading);</div><div class="line">    CGFunctionRelease (myShadingFunction);</div><div class="line"> </div><div class="line">    CGContextRestoreGState (myContext); </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
